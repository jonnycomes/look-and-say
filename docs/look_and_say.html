<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>look_and_say API documentation</title>
<meta name="description" content="A python module for exploring look and say sequences in the spirit of John H Conway â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em;max-height:300px;overflow-y:scroll}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>look_and_say</code></h1>
</header>
<section id="section-intro">
<p>A python module for exploring look and say sequences in the spirit of John H Conway.</p>
<p>The following assumes familiarity with the terminology and notation for look and sequences introduced by Conway in his delightful article <a href="https://link.springer.com/chapter/10.1007/978-1-4612-4808-8_53">The Weird and Wonderful Chemistry of Audioactive Decay</a>. </p>
<p>This module can be used to recover several of Conway's results on standard look and say sequences. Additionally, it can be used to discover new results on various nonstandard look and say sequences. For an introduction to nonstandard look and say sequences, see the <a href="https://jonnycomes.github.io/look_and_say/papers/intro_nonstandard_look_and_say/look_and_say_intro.pdf">notes here</a>.</p>
<h1 id="example-sessions">Example Sessions</h1>
<h2 id="standard-decimal">Standard decimal</h2>
<p>The following session illustrates how the <code><a title="look_and_say" href="#look_and_say">look_and_say</a></code> module can be used to recover some of Conway's results.
</p>
<pre><code class="language-python">&gt;&gt;&gt; from look_and_say import *
&gt;&gt;&gt; 
&gt;&gt;&gt; # The default LookAndSay object uses the standard decimal number system:
... decimal = LookAndSay()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Perform the fundamental look and say operation:
... decimal.say_what_you_see('1222111')
'113231'
&gt;&gt;&gt; 
&gt;&gt;&gt; # Generate a look and say sequence
... decimal.generate_sequence(seed='1', num_iterations=5)
&gt;&gt;&gt; decimal.get_sequence()
['1', '11', '21', '1211', '111221', '312211']
&gt;&gt;&gt; 
&gt;&gt;&gt; # Use Conway's splitting theorem to search for all the elements 
... # in the look and say sequence generated from the seed '1'. 
... # This will generate Conway's 92 common elements: 
... chem = Chemistry(decimal)
&gt;&gt;&gt; chem.generate_elements('1')
&gt;&gt;&gt; chem.get_elements()
[H, He, Li, Be, B, C, N, O, F, Ne, Na, Mg, Al, Si, P, S, Cl, Ar, K, Ca, Sc, Ti, V, Cr, Mn, Fe, Co, Ni, Cu, Zn, Ga, Ge, As, Se, Br, Kr, Rb, Sr, Y, Zr, Nb, Mo, Tc, Ru, Rh, Pd, Ag, Cd, In, Sn, Sb, Te, I, Xe, Cs, Ba, La, Ce, Pr, Nd, Pm, Sm, Eu, Gd, Tb, Dy, Ho, Er, Tm, Yb, Lu, Hf, Ta, W, Re, Os, Ir, Pt, Au, Hg, Tl, Pb, Bi, Po, At, Rn, Fr, Ra, Ac, Th, Pa, U]
&gt;&gt;&gt; 
&gt;&gt;&gt; # The periodic table is a dictionary holding the chemical properties of each element.
... pt = chem.get_periodic_table(abundance_sum=10**6)
&gt;&gt;&gt; print('Hydrogen:', pt['H'])
Hydrogen: {'string': '22', 'abundance': 91790.383216, 'decay': [H]}
&gt;&gt;&gt; print('Thulium:', pt['Tm'])
Thulium: {'string': '11131221133112', 'abundance': 1204.9083841, 'decay': [Er, Ca, Co]}
&gt;&gt;&gt; 
&gt;&gt;&gt; # Conway's constant can be found as the maximal real eigenvalue of the 
... # characteristic polynomial of the decay matrix:
... chem.get_max_eigenvalue()
1.3035772690342984
&gt;&gt;&gt; chem.get_char_poly()
lambda**18*(lambda - 1)**2*(lambda + 1)*(lambda**71 - lambda**69 - 2*lambda**68 - lambda**67 + 2*lambda**66 + 2*lambda**65 + lambda**64 - lambda**63 - lambda**62 - lambda**61 - lambda**60 - lambda**59 + 2*lambda**58 + 5*lambda**57 + 3*lambda**56 - 2*lambda**55 - 10*lambda**54 - 3*lambda**53 - 2*lambda**52 + 6*lambda**51 + 6*lambda**50 + lambda**49 + 9*lambda**48 - 3*lambda**47 - 7*lambda**46 - 8*lambda**45 - 8*lambda**44 + 10*lambda**43 + 6*lambda**42 + 8*lambda**41 - 5*lambda**40 - 12*lambda**39 + 7*lambda**38 - 7*lambda**37 + 7*lambda**36 + lambda**35 - 3*lambda**34 + 10*lambda**33 + lambda**32 - 6*lambda**31 - 2*lambda**30 - 10*lambda**29 - 3*lambda**28 + 2*lambda**27 + 9*lambda**26 - 3*lambda**25 + 14*lambda**24 - 8*lambda**23 - 7*lambda**21 + 9*lambda**20 + 3*lambda**19 - 4*lambda**18 - 10*lambda**17 - 7*lambda**16 + 12*lambda**15 + 7*lambda**14 + 2*lambda**13 - 12*lambda**12 - 4*lambda**11 - 2*lambda**10 + 5*lambda**9 + lambda**7 - 7*lambda**6 + 7*lambda**5 - 4*lambda**4 + 12*lambda**3 - 6*lambda**2 + 3*lambda - 6)

</code></pre>
<h2 id="gray-code">Gray code</h2>
<p>The following session shows how to use the module to explore a nonstandard look and say sequence. We use the binary number system known as <a href="https://en.wikipedia.org/wiki/Gray_code#n-ary_Gray_code">Gray code</a> to generate the sequence. The corresponding LookAndSay object depends on the <em>say function</em> which converts a positive integer into its Gray code.</p>
<pre><code class="language-python">&gt;&gt;&gt; from look_and_say import *
&gt;&gt;&gt;
&gt;&gt;&gt; # Define the &quot;say function&quot;
&gt;&gt;&gt; def gray(num):
...     assert num &lt; 8, &quot;This say function can only count to 7.&quot;
...     gray_code = {1:'1', 2:'11', 3:'10', 4:'110', 5:'111', 6:'101', 7:'100'}
...     return gray_code[num]
... 
&gt;&gt;&gt; # Create the LookAndSay object and generate a look and say sequence
&gt;&gt;&gt; gray_ls = LookAndSay(gray)
&gt;&gt;&gt; gray_ls.generate_sequence(seed='0', num_iterations=6)
&gt;&gt;&gt; gray_ls.get_sequence()
['0', '10', '1110', '10110', '111011110', '10110110110', '1110111101111011110']
&gt;&gt;&gt; 
&gt;&gt;&gt; # Use a BinaryChemistry object to determine the chemical properties
&gt;&gt;&gt; gray_chem = BinaryChemistry(gray_ls)
&gt;&gt;&gt; gray_chem.generate_elements('0')
&gt;&gt;&gt; gray_chem.print_periodic_table()
element   string   abundance    decay
E1        10       0.0          [E3]
E2        110      58.5786438   [E4]
E3        1110     0.0          [E1, E2]
E4        11110    41.4213562   [E2, E2]
&gt;&gt;&gt; 
&gt;&gt;&gt; # The maximal real eigenvalue of the decay matrix gives the long term
&gt;&gt;&gt; # growth rate of the look and say sequence.
&gt;&gt;&gt; gray_chem.get_max_eigenvalue()
1.4142135623730947
&gt;&gt;&gt; 
&gt;&gt;&gt; # The growth rate is the maximal real root of the characteristic polynomial
&gt;&gt;&gt; gray_chem.get_char_poly()
(lambda - 1)*(lambda + 1)*(lambda**2 - 2)

</code></pre>
<h2 id="standard-ternary">Standard ternary</h2>
<p>The following session illustrates how to use the module to explore look and say sequences using the standard ternary number system (i.e. using base 3 with digits 0, 1, and 2). The results are similar to those discussed <a href="http://www.njohnston.ca/2011/01/further-variants-of-the-look-and-say-sequence/">here</a>. </p>
<p>To construct the corresponding LookAndSay object requires a <em>say function</em> which, in this case, is a function that converts an integer to it's standard ternary representation. The construction of the Chemistry object requires both the LookAndSay object as well as a <em>splitting function</em> which determines when the terms of the look and say sequences split. In this case, one can show that the terms will always split after a run of 0's as well as between a 2 (on the left) and either a 10 or a 1110 (on the right). We use a SplitFuncFactory object to create the splitting function. </p>
<pre><code class="language-python">&gt;&gt;&gt; from look_and_say import *
&gt;&gt;&gt; 
&gt;&gt;&gt; # Define a &quot;say function&quot;
... def ternary(num):
...     '''Returns the ternary representation of a nonnegative integer'''
...     if num &lt; 3:
...         return str(num)
...     return ternary(num // 3) + str(num % 3)
...  
&gt;&gt;&gt; # Use the Split Function Factory to create a split function:
... sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_after('0')
&gt;&gt;&gt; sff.declare_splitting_pairs(('2', '1110'), ('2', '10'))
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Instantiate the LookAndSay and Chemistry objects:
... ternary_ls = LookAndSay(ternary)
&gt;&gt;&gt; ternary_chem = Chemistry(ternary_ls, split)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Generate elements and order them according to relative abundances:
... ternary_chem.generate_elements('0', '1', '2')
&gt;&gt;&gt; ternary_chem.order_elements('abundance')
&gt;&gt;&gt; 
&gt;&gt;&gt; # Print chemical properties:
... ternary_chem.print_periodic_table()
element   string     abundance    decay
E1        10         18.5037375   [E4]
E2        22110      13.9680582   [E5]
E3        2110       13.9680582   [E6]
E4        1110       13.9680582   [E1, E7]
E5        222110     10.5441752   [E1, E2]
E6        122110     10.5441752   [E8]
E7        110        10.5441752   [E3]
E8        11222110   7.9595623    [E3, E2]
E9        222112     0.0          [E1, E10]
E10       22112      0.0          [E9]
E11       212221     0.0          [E16, E4, E13]
E12       2112       0.0          [E14]
E13       211        0.0          [E15]
E14       122112     0.0          [E17]
E15       1221       0.0          [E18]
E16       12         0.0          [E20]
E17       11222112   0.0          [E3, E10]
E18       112211     0.0          [E11]
E19       112        0.0          [E12]
E20       1112       0.0          [E1, E19]
&gt;&gt;&gt;
&gt;&gt;&gt; # Show the characteristic polynomial and its maximal real root, 
&gt;&gt;&gt; # which gives the generic growth rate of the look and say sequences.
&gt;&gt;&gt; print(ternary_chem.get_char_poly(latex=True))
\lambda^{6} \left(\lambda - 1\right)^{2} \left(\lambda + 1\right)^{2} \left(\lambda^{2} + 1\right) \left(\lambda^{3} - \lambda - 1\right) \left(\lambda^{5} - \lambda^{3} + 1\right)
&gt;&gt;&gt; print(ternary_chem.get_max_eigenvalue())
1.3247179572447458

</code></pre>
<h1 id="projects-that-used-the-look_and_say-module">Projects that used the look_and_say module</h1>
<ul>
<li>
<p>A D3 force graph showing <a href="https://observablehq.com/@jonnycomes/the-decay-of-conways-look-and-say-elements">the decay of Conway's elements</a>.</p>
</li>
<li>
<p>A D3 collapsable tree showing the <a href="https://observablehq.com/@jonnycomes/descendants-of-methuselum">descendants of Methuselum</a>.</p>
</li>
</ul>
<h1 id="acknowledgments">Acknowledgments</h1>
<ul>
<li>The initial implementation of the proof() method in the Cosmology class was written with Ethan Bassingthwaite and Monika de los Rios in the Spring of 2022 at The College of Idaho. We followed the strategy of Zeilberger's proof with implementation similar to that of Litherland.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ./docs/SUMMARY.md

.. include:: ./docs/EXAMPLESESSIONS.md

.. include:: ./docs/PROJECTS.md

.. include:: ./docs/ACKNOWLEDGMENTS.md
&#34;&#34;&#34;

import numpy
import sympy

################## Conway&#39;s Conventions ############################

def split_Conway(string):
    &#34;&#34;&#34;
    Splits a string into a list of substrings according to Conway&#39;s Splitting Theorem.
    Assumes the string is not empty. 

    ## Example Session:
    ```python
    &gt;&gt;&gt; from look_and_say import split_Conway
    &gt;&gt;&gt; string = &#39;1211132213&#39;
    &gt;&gt;&gt; chunks = split_Conway(string)
    &gt;&gt;&gt; print(chunks)
    [&#39;12&#39;, &#39;1113&#39;, &#39;22&#39;, &#39;13&#39;]

    ```
    &#34;&#34;&#34;
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if _is_split_pair_Conway(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks

def _is_split_pair_Conway(L, R):
    &#34;&#34;&#34;Implementation of Conway&#39;s Splitting Theorem&#34;&#34;&#34;
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    if L[-1] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and R[0] in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]: # n] and [m
            return True
    if L[-1] == &#39;2&#39;: # 2]
            if len(R) &gt; 1 and R[0] == &#39;1&#39; and R[1] != &#39;1&#39; and (len(R) == 2 or R[2] != R[1]): #[1^1X^1
                    return True
            if len(R) &gt; 2 and R[0] == &#39;1&#39; and R[1] == &#39;1&#39; and R[2] == &#39;1&#39; and (len(R) == 3 or R[3] != &#39;1&#39;): #[1^3
                    return True
            if R[0] == &#39;3&#39; and (len(R) == 1 or (R[1] != &#39;3&#39; and (len(R) &lt; 4 or R[2] != R[1] or R[3] != R[1]))): #[3^1X^\not=3
                    return True
            if R[0] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 1 or R[1] != R[0]): #[n^1
                    return True
    if L[-1] != &#39;2&#39; and len(R) &gt; 1 and R[0] == &#39;2&#39; and R[1] == &#39;2&#39;: # \not=2]
            if len(R) &gt; 3 and R[2] == &#39;1&#39; and R[3] != &#39;1&#39; and (len(R) == 4 or R[4] != R[3]): #[2^21^1X^1
                    return True
            if len(R) &gt; 4 and R[2] == &#39;1&#39; and R[3] == &#39;1&#39; and R[4] == &#39;1&#39; and (len(R) == 5 or R[5] != &#39;1&#39;): #[2^21^3
                    return True
            if len(R) &gt; 2 and R[2] == &#39;3&#39; and (len(R) == 3 or (R[3] != &#39;3&#39; and (len(R) &lt; 6 or R[4] != R[3] or R[5] != R[3]))): #[2^23^1X^\not=3
                    return True 
            if len(R) == 2 or (len(R) &gt; 2 and R[2] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 3 or R[3] != R[2])): #[2^2n^(0 or 1)
                    return True
    return False

_CONWAY_ELEMENTS = {&#39;3&#39;: {&#39;name&#39;: &#39;U&#39;, &#39;number&#39;: 92}, &#39;13&#39;: {&#39;name&#39;: &#39;Pa&#39;, &#39;number&#39;: 91}, &#39;1113&#39;: {&#39;name&#39;: &#39;Th&#39;, &#39;number&#39;: 90}, &#39;3113&#39;: {&#39;name&#39;: &#39;Ac&#39;, &#39;number&#39;: 89}, &#39;132113&#39;: {&#39;name&#39;: &#39;Ra&#39;, &#39;number&#39;: 88}, &#39;1113122113&#39;: {&#39;name&#39;: &#39;Fr&#39;, &#39;number&#39;: 87}, &#39;311311222113&#39;: {&#39;name&#39;: &#39;Rn&#39;, &#39;number&#39;: 86}, &#39;1322113&#39;: {&#39;name&#39;: &#39;At&#39;, &#39;number&#39;: 85}, &#39;1113222113&#39;: {&#39;name&#39;: &#39;Po&#39;, &#39;number&#39;: 84}, &#39;3113322113&#39;: {&#39;name&#39;: &#39;Bi&#39;, &#39;number&#39;: 83}, &#39;123222113&#39;: {&#39;name&#39;: &#39;Pb&#39;, &#39;number&#39;: 82}, &#39;111213322113&#39;: {&#39;name&#39;: &#39;Tl&#39;, &#39;number&#39;: 81}, &#39;31121123222113&#39;: {&#39;name&#39;: &#39;Hg&#39;, &#39;number&#39;: 80}, &#39;132112211213322113&#39;: {&#39;name&#39;: &#39;Au&#39;, &#39;number&#39;: 79}, &#39;111312212221121123222113&#39;: {&#39;name&#39;: &#39;Pt&#39;, &#39;number&#39;: 78}, &#39;3113112211322112211213322113&#39;: {&#39;name&#39;: &#39;Ir&#39;, &#39;number&#39;: 77}, &#39;1321132122211322212221121123222113&#39;: {&#39;name&#39;: &#39;Os&#39;, &#39;number&#39;: 76}, &#39;111312211312113221133211322112211213322113&#39;: {&#39;name&#39;: &#39;Re&#39;, &#39;number&#39;: 75}, &#39;312211322212221121123222113&#39;: {&#39;name&#39;: &#39;W&#39;, &#39;number&#39;: 74}, &#39;13112221133211322112211213322113&#39;: {&#39;name&#39;: &#39;Ta&#39;, &#39;number&#39;: 73}, &#39;11132&#39;: {&#39;name&#39;: &#39;Hf&#39;, &#39;number&#39;: 72}, &#39;311312&#39;: {&#39;name&#39;: &#39;Lu&#39;, &#39;number&#39;: 71}, &#39;1321131112&#39;: {&#39;name&#39;: &#39;Yb&#39;, &#39;number&#39;: 70}, &#39;11131221133112&#39;: {&#39;name&#39;: &#39;Tm&#39;, &#39;number&#39;: 69}, &#39;311311222&#39;: {&#39;name&#39;: &#39;Er&#39;, &#39;number&#39;: 68}, &#39;1321132&#39;: {&#39;name&#39;: &#39;Ho&#39;, &#39;number&#39;: 67}, &#39;111312211312&#39;: {&#39;name&#39;: &#39;Dy&#39;, &#39;number&#39;: 66}, &#39;3113112221131112&#39;: {&#39;name&#39;: &#39;Tb&#39;, &#39;number&#39;: 65}, &#39;13221133112&#39;: {&#39;name&#39;: &#39;Gd&#39;, &#39;number&#39;: 64}, &#39;1113222&#39;: {&#39;name&#39;: &#39;Eu&#39;, &#39;number&#39;: 63}, &#39;311332&#39;: {&#39;name&#39;: &#39;Sm&#39;, &#39;number&#39;: 62}, &#39;132&#39;: {&#39;name&#39;: &#39;Pm&#39;, &#39;number&#39;: 61}, &#39;111312&#39;: {&#39;name&#39;: &#39;Nd&#39;, &#39;number&#39;: 60}, &#39;31131112&#39;: {&#39;name&#39;: &#39;Pr&#39;, &#39;number&#39;: 59}, &#39;1321133112&#39;: {&#39;name&#39;: &#39;Ce&#39;, &#39;number&#39;: 58}, &#39;11131&#39;: {&#39;name&#39;: &#39;La&#39;, &#39;number&#39;: 57}, &#39;311311&#39;: {&#39;name&#39;: &#39;Ba&#39;, &#39;number&#39;: 56}, &#39;13211321&#39;: {&#39;name&#39;: &#39;Cs&#39;, &#39;number&#39;: 55}, &#39;11131221131211&#39;: {&#39;name&#39;: &#39;Xe&#39;, &#39;number&#39;: 54}, &#39;311311222113111221&#39;: {&#39;name&#39;: &#39;I&#39;, &#39;number&#39;: 53}, &#39;1322113312211&#39;: {&#39;name&#39;: &#39;Te&#39;, &#39;number&#39;: 52}, &#39;3112221&#39;: {&#39;name&#39;: &#39;Sb&#39;, &#39;number&#39;: 51}, &#39;13211&#39;: {&#39;name&#39;: &#39;Sn&#39;, &#39;number&#39;: 50}, &#39;11131221&#39;: {&#39;name&#39;: &#39;In&#39;, &#39;number&#39;: 49}, &#39;3113112211&#39;: {&#39;name&#39;: &#39;Cd&#39;, &#39;number&#39;: 48}, &#39;132113212221&#39;: {&#39;name&#39;: &#39;Ag&#39;, &#39;number&#39;: 47}, &#39;111312211312113211&#39;: {&#39;name&#39;: &#39;Pd&#39;, &#39;number&#39;: 46}, &#39;311311222113111221131221&#39;: {&#39;name&#39;: &#39;Rh&#39;, &#39;number&#39;: 45}, &#39;132211331222113112211&#39;: {&#39;name&#39;: &#39;Ru&#39;, &#39;number&#39;: 44}, &#39;311322113212221&#39;: {&#39;name&#39;: &#39;Tc&#39;, &#39;number&#39;: 43}, &#39;13211322211312113211&#39;: {&#39;name&#39;: &#39;Mo&#39;, &#39;number&#39;: 42}, &#39;1113122113322113111221131221&#39;: {&#39;name&#39;: &#39;Nb&#39;, &#39;number&#39;: 41}, &#39;12322211331222113112211&#39;: {&#39;name&#39;: &#39;Zr&#39;, &#39;number&#39;: 40}, &#39;1112133&#39;: {&#39;name&#39;: &#39;Y&#39;, &#39;number&#39;: 39}, &#39;3112112&#39;: {&#39;name&#39;: &#39;Sr&#39;, &#39;number&#39;: 38}, &#39;1321122112&#39;: {&#39;name&#39;: &#39;Rb&#39;, &#39;number&#39;: 37}, &#39;11131221222112&#39;: {&#39;name&#39;: &#39;Kr&#39;, &#39;number&#39;: 36}, &#39;3113112211322112&#39;: {&#39;name&#39;: &#39;Br&#39;, &#39;number&#39;: 35}, &#39;13211321222113222112&#39;: {&#39;name&#39;: &#39;Se&#39;, &#39;number&#39;: 34}, &#39;11131221131211322113322112&#39;: {&#39;name&#39;: &#39;As&#39;, &#39;number&#39;: 33}, &#39;31131122211311122113222&#39;: {&#39;name&#39;: &#39;Ge&#39;, &#39;number&#39;: 32}, &#39;13221133122211332&#39;: {&#39;name&#39;: &#39;Ga&#39;, &#39;number&#39;: 31}, &#39;312&#39;: {&#39;name&#39;: &#39;Zn&#39;, &#39;number&#39;: 30}, &#39;131112&#39;: {&#39;name&#39;: &#39;Cu&#39;, &#39;number&#39;: 29}, &#39;11133112&#39;: {&#39;name&#39;: &#39;Ni&#39;, &#39;number&#39;: 28}, &#39;32112&#39;: {&#39;name&#39;: &#39;Co&#39;, &#39;number&#39;: 27}, &#39;13122112&#39;: {&#39;name&#39;: &#39;Fe&#39;, &#39;number&#39;: 26}, &#39;111311222112&#39;: {&#39;name&#39;: &#39;Mn&#39;, &#39;number&#39;: 25}, &#39;31132&#39;: {&#39;name&#39;: &#39;Cr&#39;, &#39;number&#39;: 24}, &#39;13211312&#39;: {&#39;name&#39;: &#39;V&#39;, &#39;number&#39;: 23}, &#39;11131221131112&#39;: {&#39;name&#39;: &#39;Ti&#39;, &#39;number&#39;: 22}, &#39;3113112221133112&#39;: {&#39;name&#39;: &#39;Sc&#39;, &#39;number&#39;: 21}, &#39;12&#39;: {&#39;name&#39;: &#39;Ca&#39;, &#39;number&#39;: 20}, &#39;1112&#39;: {&#39;name&#39;: &#39;K&#39;, &#39;number&#39;: 19}, &#39;3112&#39;: {&#39;name&#39;: &#39;Ar&#39;, &#39;number&#39;: 18}, &#39;132112&#39;: {&#39;name&#39;: &#39;Cl&#39;, &#39;number&#39;: 17}, &#39;1113122112&#39;: {&#39;name&#39;: &#39;S&#39;, &#39;number&#39;: 16}, &#39;311311222112&#39;: {&#39;name&#39;: &#39;P&#39;, &#39;number&#39;: 15}, &#39;1322112&#39;: {&#39;name&#39;: &#39;Si&#39;, &#39;number&#39;: 14}, &#39;1113222112&#39;: {&#39;name&#39;: &#39;Al&#39;, &#39;number&#39;: 13}, &#39;3113322112&#39;: {&#39;name&#39;: &#39;Mg&#39;, &#39;number&#39;: 12}, &#39;123222112&#39;: {&#39;name&#39;: &#39;Na&#39;, &#39;number&#39;: 11}, &#39;111213322112&#39;: {&#39;name&#39;: &#39;Ne&#39;, &#39;number&#39;: 10}, &#39;31121123222112&#39;: {&#39;name&#39;: &#39;F&#39;, &#39;number&#39;: 9}, &#39;132112211213322112&#39;: {&#39;name&#39;: &#39;O&#39;, &#39;number&#39;: 8}, &#39;111312212221121123222112&#39;: {&#39;name&#39;: &#39;N&#39;, &#39;number&#39;: 7}, &#39;3113112211322112211213322112&#39;: {&#39;name&#39;: &#39;C&#39;, &#39;number&#39;: 6}, &#39;1321132122211322212221121123222112&#39;: {&#39;name&#39;: &#39;B&#39;, &#39;number&#39;: 5}, &#39;111312211312113221133211322112211213322112&#39;: {&#39;name&#39;: &#39;Be&#39;, &#39;number&#39;: 4}, &#39;312211322212221121123222112&#39;: {&#39;name&#39;: &#39;Li&#39;, &#39;number&#39;: 3}, &#39;13112221133211322112211213322112&#39;: {&#39;name&#39;: &#39;He&#39;, &#39;number&#39;: 2}, &#39;22&#39;: {&#39;name&#39;: &#39;H&#39;, &#39;number&#39;: 1}}

def _conway_name(element):
    string = element.get_string()
    if string in _CONWAY_ELEMENTS:
        return _CONWAY_ELEMENTS[string][&#39;name&#39;]
    Pu = &#39;31221132221222112112322211n&#39;
    Np = &#39;1311222113321132211221121332211n&#39;
    if len(string) == len(Pu) and string[:-1] == Pu[:-1]:
        return &#39;Pu&#39; + string[-1]
    if len(string) == len(Np) and string[:-1] == Np[:-1]:
        return &#39;Np&#39; + string[-1]
    return element.get_name()

def _conway_number(element):
    string = element.get_string()
    if string in _CONWAY_ELEMENTS:
        return _CONWAY_ELEMENTS[string][&#39;number&#39;]
    else: # Handling transuranic elements
        return 92 * int(string[:9]) + ord(string[-1])

################# LOOK AND SAY #################################

class LookAndSay():
    &#34;&#34;&#34;
    A class responsible for the fundamental say-what-you-see operation
    that generates a look and say sequence. The parameter ``say`` in the
    constructor is a function that determines the decay of a chunk of the form
    \\(a^b\\). The say function can have one or two parameters:

    * If the say function accepts one parameter, the LookAndSay object will correspond to the decay \\(a^b\\to say(b)a\\).
    * If the say function accepts two parameters, the LookAndSay object will correspond to the decay \\(a^b\\to say(b, a)\\).

    When no parameter is passed to the constructor, the LookAndSay
    object will correspond to standard base ten look and say sequences.

    
    ## Example Session: Default Constructor. 
    The following example uses the default (standard) look and say sequences.
    Note that the ratios of lengths are approaching Conway&#39;s constant.
    ```python 
    &gt;&gt;&gt; ls = LookAndSay()  
    &gt;&gt;&gt; ls.generate_sequence(&#39;55555&#39;, 35)
    &gt;&gt;&gt; sequence = ls.get_sequence()
    &gt;&gt;&gt; first_terms = sequence[:10]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(&#39;Sequence:&#39;, first_terms)
    Sequence: [&#39;55555&#39;, &#39;55&#39;, &#39;25&#39;, &#39;1215&#39;, &#39;11121115&#39;, &#39;31123115&#39;, &#39;132112132115&#39;, &#39;11131221121113122115&#39;, &#39;311311222112311311222115&#39;, &#39;1321132132211213211321322115&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(&#39;Ratios of lengths:&#39;, ls.get_length_ratios())
    Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(&#39;Just the last ratio:&#39;, ls.get_last_length_ratio())
    Just the last ratio: 1.312784588441331

    ```

    ## Example Sessions: One parameter say functions

    Here is an implementation of a Roman look and say:
    ```python
    &gt;&gt;&gt; def roman_say(num):
    ...     assert num &lt; 10, &#34;This Roman can only count to 9.&#34;
    ...     roman = {1:&#39;I&#39;, 2:&#39;II&#39;, 3:&#39;III&#39;, 4:&#39;IV&#39;, 5:&#39;V&#39;, 6:&#39;VI&#39;, 7:&#39;VII&#39;, 8:&#39;VIII&#39;, 9:&#39;IX&#39;}
    ...     return roman[num]
    ... 
    &gt;&gt;&gt; roman_ls = LookAndSay(roman_say)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; roman_ls.generate_sequence(&#39;I&#39;, 10)
    &gt;&gt;&gt; print(roman_ls.get_sequence())
    [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IIII&#39;, &#39;IVI&#39;, &#39;IIIVII&#39;, &#39;IIIIIVIII&#39;, &#39;VIIVIIII&#39;, &#39;IVIIIIVIVI&#39;, &#39;IIIVIVIIVIIIVII&#39;, &#39;IIIIIVIIIVIIIIVIIIIIVIII&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; roman_ls.generate_sequence(&#39;V&#39;, 10)
    &gt;&gt;&gt; print(roman_ls.get_sequence())
    [&#39;V&#39;, &#39;IV&#39;, &#39;IIIV&#39;, &#39;IIIIIV&#39;, &#39;VIIV&#39;, &#39;IVIIIIV&#39;, &#39;IIIVIVIIV&#39;, &#39;IIIIIVIIIVIIIIV&#39;, &#39;VIIVIIIIIVIVIIV&#39;, &#39;IVIIIIVVIIVIIIVIIIIV&#39;, &#39;IIIVIVIIIVIIIIVIIIIIVIVIIV&#39;]

    ```

    Here is a standard binary look and say:
    ```python
    &gt;&gt;&gt; def binary_say(num):
    ...     return &#34;{0:b}&#34;.format(num)
    ... 
    &gt;&gt;&gt; binary_ls = LookAndSay(binary_say)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; binary_ls.generate_sequence(&#39;0&#39;, 9)
    &gt;&gt;&gt; print(binary_ls.get_sequence())
    [&#39;0&#39;, &#39;10&#39;, &#39;1110&#39;, &#39;11110&#39;, &#39;100110&#39;, &#39;1110010110&#39;, &#39;111100111010110&#39;, &#39;100110011110111010110&#39;, &#39;1110010110010011011110111010110&#39;, &#39;1111001110101100111001011010011011110111010110&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; binary_ls.generate_sequence(&#39;1&#39;, 9)
    &gt;&gt;&gt; print(binary_ls.get_sequence())
    [&#39;1&#39;, &#39;11&#39;, &#39;101&#39;, &#39;111011&#39;, &#39;11110101&#39;, &#39;100110111011&#39;, &#39;111001011011110101&#39;, &#39;111100111010110100110111011&#39;, &#39;100110011110111010110111001011011110101&#39;, &#39;1110010110010011011110111010110111100111010110100110111011&#39;]

    ```
    
    ## Example Sessions: Two parameter say functions

    Here is a *look-and-say-again* from the paper [*Stuttering Conway Sequences Are Still Conway Sequences* by Brier et al](https://arxiv.org/abs/2006.06837).
    The say function for this example corresponds to the decay \\(a^b\\to bbaa\\).
    ```python
    &gt;&gt;&gt; def say_again(char_count, char):
    ...     return 2 * str(char_count) + 2 * char
    ... 
    &gt;&gt;&gt; look_and_say_again = LookAndSay(say_again)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_and_say_again.generate_sequence(&#39;1&#39;, 10)
    &gt;&gt;&gt; print(look_and_say_again.get_sequence())
    [&#39;1&#39;, &#39;1111&#39;, &#39;4411&#39;, &#39;22442211&#39;, &#39;2222224422222211&#39;, &#39;6622224466222211&#39;, &#39;226644222244226644222211&#39;, &#39;2222226622444422224422222266224444222211&#39;, &#39;662222662222444444222244662222662222444444222211&#39;, &#39;22664422226644226644442222442266442222664422664444222211&#39;, &#39;2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_and_say_again.generate_sequence(&#39;2&#39;, 10)
    &gt;&gt;&gt; print(look_and_say_again.get_sequence())
    [&#39;2&#39;, &#39;1122&#39;, &#39;22112222&#39;, &#39;222222114422&#39;, &#39;6622221122442222&#39;, &#39;226644222211222222444422&#39;, &#39;22222266224444222211662244442222&#39;, &#39;6622226622224444442222112266222244444422&#39;, &#39;226644222266442266444422221122222266442266442222&#39;, &#39;222222662244442222662244222222664444442222116622226622442222226622444422&#39;, &#39;66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222&#39;]

    ```

    Here is [Morrill&#39;s *Look Knave*](https://www.cambridge.org/core/journals/bulletin-of-the-australian-mathematical-society/article/abs/look-knave/BFC51822DED97095C96ABD2255AEDC2A):
    ```python
    &gt;&gt;&gt; def knave_say(bit_count, bit):
    ...     flip = {&#39;0&#39;:&#39;1&#39;, &#39;1&#39;:&#39;0&#39;}
    ...     return &#34;{0:b}&#34;.format(bit_count) + flip[bit]
    ... 
    &gt;&gt;&gt; look_knave = LookAndSay(knave_say)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_knave.generate_sequence(&#39;0&#39;, 12)
    &gt;&gt;&gt; print(look_knave.get_sequence())
    [&#39;0&#39;, &#39;11&#39;, &#39;100&#39;, &#39;10101&#39;, &#39;1011101110&#39;, &#39;10111101111011&#39;, &#39;1011100011100011100&#39;, &#39;1011110111110111110101&#39;, &#39;1011100011101011101011101110&#39;, &#39;10111101111101110111101110111101111011&#39;, &#39;10111000111010111101110001111011100011100011100&#39;, &#39;1011110111110111011100011110111100011110111110111110101&#39;, &#39;1011100011101011110111101111000111000111100011101011101011101110&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_knave.generate_sequence(&#39;1&#39;, 12)
    &gt;&gt;&gt; print(look_knave.get_sequence())
    [&#39;1&#39;, &#39;10&#39;, &#39;1011&#39;, &#39;1011100&#39;, &#39;1011110101&#39;, &#39;1011100011101110&#39;, &#39;10111101111101111011&#39;, &#39;1011100011101011100011100&#39;, &#39;1011110111110111011110111110101&#39;, &#39;101110001110101111011100011101011101110&#39;, &#39;10111101111101110111000111101111101110111101111011&#39;, &#39;10111000111010111101111011110001110101111011100011100011100&#39;, &#39;10111101111101110111000111000111000111110111011100011110111110111110101&#39;]

    ```
    &#34;&#34;&#34;
    def __init__(self, say = None):
        super(LookAndSay, self).__init__()
        self._is_Conway = False
        if say == None:
            say = (lambda n : str(n))
            self._is_Conway = True
        self.say = say
        self.sequence = []

    def _chunk_op(self, char_count, char):
        &#34;&#34;&#34;
        Conversion of the say function to a two parameter function 
        if the say function takes only one parameter; 
        just a copy of the say function otherwise.
        &#34;&#34;&#34;
        try:
            return self.say(char_count, char)
        except:
            return self.say(char_count) + char

    def get_sequence(self):
        &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
        return self.sequence

    def say_what_you_see(self, string):
        &#34;&#34;&#34;
        The fundamental look and say operation that generates each 
        term of a look and say sequence from its predecessor. For example, 
        using the standard (default) LookAndSay object, 
        ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
        &#34;&#34;&#34;
        if not string: return None # handles empty string, which is falsy
        letter = string[0]
        result = &#39;&#39;
        count = 0
        for ch in string:
            if ch == letter: 
                count += 1
            else:
                result += self._chunk_op(count, letter)
                count = 1
                letter = ch 
        result += self._chunk_op(count, letter)
        return result
     
    def generate_sequence(self, seed, num_iterations):
        &#34;&#34;&#34;
        Generates the look and say sequence. The parameter ``seed`` is 
        the initial term in the sequence, and ``num_iterations`` is the 
        number of terms generated.
        &#34;&#34;&#34;
        if not seed: return None # handles empty seed, which is falsy
        result = [seed]
        for _ in range(num_iterations):
            result.append(self.say_what_you_see(result[-1]))
        self.sequence = result

    def get_length_ratios(self):
        &#34;&#34;&#34;
        Returns a list of the ratios of lengths of 
        successive terms in the look and say sequence.
        &#34;&#34;&#34;
        num_iterations = len(self.sequence)
        assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
        return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]

    def get_last_length_ratio(self):
        &#34;&#34;&#34;
        Returns the ratio of the lengths of the last 
        two terms of the look and say sequence
        &#34;&#34;&#34;
        return self.get_length_ratios()[-1]



########### CHEMISTRY #####################

class Chemistry():
    &#34;&#34;&#34;
    A class responsible for generating all the persistent elements 
    appearing in look and say sequences, along with 
    the chemical properties of those elements.

    Parameters in the constructor are a LookAndSay object ``las`` and
    a splitting function ``split``. The user is responsible
    for verifying that the provided splitting function is valid for the given
    LookAndSay object. The default splitting function corresponds to 
    Conway&#39;s original Splitting Theorem.

    ## Example Session: Conway&#39;s Constant and his 92 Common Elements

    ```python
    &gt;&gt;&gt; ls = LookAndSay()
    &gt;&gt;&gt; chem = Chemistry(ls)
    &gt;&gt;&gt; chem.generate_elements(&#39;1&#39;)
    &gt;&gt;&gt; chem.print_periodic_table() 
    element   string                                       abundance   decay
    H         22                                           9.1790383   [H]
    He        13112221133211322112211213322112             0.3237297   [Hf, Pa, H, Ca, Li]
    Li        312211322212221121123222112                  0.4220067   [He]
    Be        111312211312113221133211322112211213322112   0.2263886   [Ge, Ca, Li]
    B         1321132122211322212221121123222112           0.295115    [Be]
    C         3113112211322112211213322112                 0.3847053   [B]
    N         111312212221121123222112                     0.501493    [C]
    O         132112211213322112                           0.6537349   [N]
    F         31121123222112                               0.852194    [O]
    Ne        111213322112                                 1.1109007   [F]
    Na        123222112                                    1.4481449   [Ne]
    Mg        3113322112                                   1.8850441   [Pm, Na]
    Al        1113222112                                   2.4573007   [Mg]
    Si        1322112                                      3.2032813   [Al]
    P         311311222112                                 1.4895887   [Ho, Si]
    S         1113122112                                   1.9417939   [P]
    Cl        132112                                       2.5312784   [S]
    Ar        3112                                         3.299717    [Cl]
    K         1112                                         4.3014361   [Ar]
    Ca        12                                           5.6072543   [K]
    Sc        3113112221133112                             0.9302097   [Ho, Pa, H, Ca, Co]
    Ti        11131221131112                               1.2126003   [Sc]
    V         13211312                                     1.5807182   [Ti]
    Cr        31132                                        2.0605883   [V]
    Mn        111311222112                                 2.686136    [Cr, Si]
    Fe        13122112                                     3.5015859   [Mn]
    Co        32112                                        4.5645877   [Fe]
    Ni        11133112                                     1.3871124   [Zn, Co]
    Cu        131112                                       1.8082082   [Ni]
    Zn        312                                          2.3571391   [Cu]
    Ga        13221133122211332                            0.1447891   [Eu, Ca, Ac, H, Ca, Zn]
    Ge        31131122211311122113222                      0.1887437   [Ho, Ga]
    As        11131221131211322113322112                   0.0027246   [Ge, Na]
    Se        13211321222113222112                         0.0035518   [As]
    Br        3113112211322112                             0.00463     [Se]
    Kr        11131221222112                               0.0060355   [Br]
    Rb        1321122112                                   0.0078678   [Kr]
    Sr        3112112                                      0.0102563   [Rb]
    Y         1112133                                      0.0133699   [Sr, U]
    Zr        12322211331222113112211                      0.0174286   [Y, H, Ca, Tc]
    Nb        1113122113322113111221131221                 0.0227196   [Er, Zr]
    Mo        13211322211312113211                         0.0296167   [Nb]
    Tc        311322113212221                              0.0386077   [Mo]
    Ru        132211331222113112211                        0.0328995   [Eu, Ca, Tc]
    Rh        311311222113111221131221                     0.042887    [Ho, Ru]
    Pd        111312211312113211                           0.0559065   [Rh]
    Ag        132113212221                                 0.0728785   [Pd]
    Cd        3113112211                                   0.0950027   [Ag]
    In        11131221                                     0.1238434   [Cd]
    Sn        13211                                        0.1614395   [In]
    Sb        3112221                                      0.2104488   [Pm, Sn]
    Te        1322113312211                                0.2743363   [Eu, Ca, Sb]
    I         311311222113111221                           0.3576186   [Ho, Te]
    Xe        11131221131211                               0.4661834   [I]
    Cs        13211321                                     0.6077061   [Xe]
    Ba        311311                                       0.7921919   [Cs]
    La        11131                                        1.0326833   [Ba]
    Ce        1321133112                                   1.3461825   [La, H, Ca, Co]
    Pr        31131112                                     1.7548529   [Ce]
    Nd        111312                                       2.2875864   [Pr]
    Pm        132                                          2.9820456   [Nd]
    Sm        311332                                       1.5408115   [Pm, Ca, Zn]
    Eu        1113222                                      2.0085669   [Sm]
    Gd        13221133112                                  2.1662973   [Eu, Ca, Co]
    Tb        3113112221131112                             2.8239359   [Ho, Gd]
    Dy        111312211312                                 3.6812186   [Tb]
    Ho        1321132                                      4.7987529   [Dy]
    Er        311311222                                    0.1098596   [Ho, Pm]
    Tm        11131221133112                               0.1204908   [Er, Ca, Co]
    Yb        1321131112                                   0.1570691   [Tm]
    Lu        311312                                       0.2047517   [Yb]
    Hf        11132                                        0.2669097   [Lu]
    Ta        13112221133211322112211213322113             0.0242077   [Hf, Pa, H, Ca, W]
    W         312211322212221121123222113                  0.0315567   [Ta]
    Re        111312211312113221133211322112211213322113   0.0169288   [Ge, Ca, W]
    Os        1321132122211322212221121123222113           0.022068    [Re]
    Ir        3113112211322112211213322113                 0.0287673   [Os]
    Pt        111312212221121123222113                     0.0375005   [Ir]
    Au        132112211213322113                           0.0488847   [Pt]
    Hg        31121123222113                               0.063725    [Au]
    Tl        111213322113                                 0.0830705   [Hg]
    Pb        123222113                                    0.1082888   [Tl]
    Bi        3113322113                                   0.1411629   [Pm, Pb]
    Po        1113222113                                   0.1840167   [Bi]
    At        1322113                                      0.23988     [Po]
    Rn        311311222113                                 0.3127021   [Ho, At]
    Fr        1113122113                                   0.4076313   [Rn]
    Ra        132113                                       0.5313789   [Fr]
    Ac        3113                                         0.6926935   [Ra]
    Th        1113                                         0.7581905   [Ac]
    Pa        13                                           0.9883599   [Th]
    U         3                                            0.0102563   [Pa]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(chem.get_char_poly())
    lambda**18*(lambda - 1)**2*(lambda + 1)*(lambda**71 - lambda**69 - 2*lambda**68 - lambda**67 + 2*lambda**66 + 2*lambda**65 + lambda**64 - lambda**63 - lambda**62 - lambda**61 - lambda**60 - lambda**59 + 2*lambda**58 + 5*lambda**57 + 3*lambda**56 - 2*lambda**55 - 10*lambda**54 - 3*lambda**53 - 2*lambda**52 + 6*lambda**51 + 6*lambda**50 + lambda**49 + 9*lambda**48 - 3*lambda**47 - 7*lambda**46 - 8*lambda**45 - 8*lambda**44 + 10*lambda**43 + 6*lambda**42 + 8*lambda**41 - 5*lambda**40 - 12*lambda**39 + 7*lambda**38 - 7*lambda**37 + 7*lambda**36 + lambda**35 - 3*lambda**34 + 10*lambda**33 + lambda**32 - 6*lambda**31 - 2*lambda**30 - 10*lambda**29 - 3*lambda**28 + 2*lambda**27 + 9*lambda**26 - 3*lambda**25 + 14*lambda**24 - 8*lambda**23 - 7*lambda**21 + 9*lambda**20 + 3*lambda**19 - 4*lambda**18 - 10*lambda**17 - 7*lambda**16 + 12*lambda**15 + 7*lambda**14 + 2*lambda**13 - 12*lambda**12 - 4*lambda**11 - 2*lambda**10 + 5*lambda**9 + lambda**7 - 7*lambda**6 + 7*lambda**5 - 4*lambda**4 + 12*lambda**3 - 6*lambda**2 + 3*lambda - 6)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(chem.get_max_eigenvalue())
    1.3035772690342984
   
    ```

    ## Example Session: Conway&#39;s Chemistry with Transuranic Elements
    In the following example, the seeds used to generate elements 
    guarantee that a few transuranic elements will appear. Also, we print the 
    periodic table using Conway&#39;s convention that abundances are given in 
    atoms per million.

    ```python
    &gt;&gt;&gt; ls = LookAndSay()
    &gt;&gt;&gt; chem = Chemistry(ls)
    &gt;&gt;&gt; chem.generate_elements(&#39;11111&#39;, &#39;78&#39;)
    &gt;&gt;&gt; chem.print_periodic_table(abundance_sum = 10**6)
    element   string                                       abundance       decay
    H         22                                           91790.383216    [H]
    He        13112221133211322112211213322112             3237.2968587    [Hf, Pa, H, Ca, Li]
    Li        312211322212221121123222112                  4220.0665982    [He]
    Be        111312211312113221133211322112211213322112   2263.8860324    [Ge, Ca, Li]
    B         1321132122211322212221121123222112           2951.1503716    [Be]
    C         3113112211322112211213322112                 3847.0525419    [B]
    N         111312212221121123222112                     5014.9302464    [C]
    O         132112211213322112                           6537.349075     [N]
    F         31121123222112                               8521.9396539    [O]
    Ne        111213322112                                 11109.0068209   [F]
    Na        123222112                                    14481.4487733   [Ne]
    Mg        3113322112                                   18850.4412275   [Pm, Na]
    Al        1113222112                                   24573.0066954   [Mg]
    Si        1322112                                      32032.81296     [Al]
    P         311311222112                                 14895.8866582   [Ho, Si]
    S         1113122112                                   19417.9392497   [P]
    Cl        132112                                       25312.7842174   [S]
    Ar        3112                                         32997.1701218   [Cl]
    K         1112                                         43014.3609132   [Ar]
    Ca        12                                           56072.5431285   [K]
    Sc        3113112221133112                             9302.0974443    [Ho, Pa, H, Ca, Co]
    Ti        11131221131112                               12126.0027828   [Sc]
    V         13211312                                     15807.1815919   [Ti]
    Cr        31132                                        20605.8826107   [V]
    Mn        111311222112                                 26861.3601797   [Cr, Si]
    Fe        13122112                                     35015.8585455   [Mn]
    Co        32112                                        45645.8772557   [Fe]
    Ni        11133112                                     13871.1241997   [Zn, Co]
    Cu        131112                                       18082.0822027   [Ni]
    Zn        312                                          23571.3913363   [Cu]
    Ga        13221133122211332                            1447.8905642    [Eu, Ca, Ac, H, Ca, Zn]
    Ge        31131122211311122113222                      1887.4372276    [Ho, Ga]
    As        11131221131211322113322112                   27.2462161      [Ge, Na]
    Se        13211321222113222112                         35.5175479      [As]
    Br        3113112211322112                             46.2998682      [Se]
    Kr        11131221222112                               60.3554557      [Br]
    Rb        1321122112                                   78.6780001      [Kr]
    Sr        3112112                                      102.5628525     [Rb]
    Y         1112133                                      133.6986032     [Sr, U]
    Zr        12322211331222113112211                      174.28646       [Y, H, Ca, Tc]
    Nb        1113122113322113111221131221                 227.1958675     [Er, Zr]
    Mo        13211322211312113211                         296.1673685     [Nb]
    Tc        311322113212221                              386.0770494     [Mo]
    Ru        132211331222113112211                        328.9948058     [Eu, Ca, Tc]
    Rh        311311222113111221131221                     428.8701504     [Ho, Ru]
    Pd        111312211312113211                           559.0653795     [Rh]
    Ag        132113212221                                 728.7849206     [Pd]
    Cd        3113112211                                   950.0274565     [Ag]
    In        11131221                                     1238.4341972    [Cd]
    Sn        13211                                        1614.3946687    [In]
    Sb        3112221                                      2104.4881933    [Pm, Sn]
    Te        1322113312211                                2743.3629717    [Eu, Ca, Sb]
    I         311311222113111221                           3576.1856107    [Ho, Te]
    Xe        11131221131211                               4661.8342719    [I]
    Cs        13211321                                     6077.0611889    [Xe]
    Ba        311311                                       7921.9188284    [Cs]
    La        11131                                        10326.8333118   [Ba]
    Ce        1321133112                                   13461.8251664   [La, H, Ca, Co]
    Pr        31131112                                     17548.5292866   [Ce]
    Nd        111312                                       22875.863883    [Pr]
    Pm        132                                          29820.4561674   [Nd]
    Sm        311332                                       15408.1151815   [Pm, Ca, Zn]
    Eu        1113222                                      20085.6687093   [Sm]
    Gd        13221133112                                  21662.9728211   [Eu, Ca, Co]
    Tb        3113112221131112                             28239.3589492   [Ho, Gd]
    Dy        111312211312                                 36812.1864183   [Tb]
    Ho        1321132                                      47987.5294384   [Dy]
    Er        311311222                                    1098.5955997    [Ho, Pm]
    Tm        11131221133112                               1204.9083841    [Er, Ca, Co]
    Yb        1321131112                                   1570.6911808    [Tm]
    Lu        311312                                       2047.51732      [Yb]
    Hf        11132                                        2669.0970363    [Lu]
    Ta        13112221133211322112211213322113             242.0773667     [Hf, Pa, H, Ca, W]
    W         312211322212221121123222113                  315.5665525     [Ta]
    Re        111312211312113221133211322112211213322113   169.2880181     [Ge, Ca, W]
    Os        1321132122211322212221121123222113           220.6800123     [Re]
    Ir        3113112211322112211213322113                 287.6734477     [Os]
    Pt        111312212221121123222113                     375.0045674     [Ir]
    Au        132112211213322113                           488.8474298     [Pt]
    Hg        31121123222113                               637.2503975     [Au]
    Tl        111213322113                                 830.7051329     [Hg]
    Pb        123222113                                    1082.8883286    [Tl]
    Bi        3113322113                                   1411.62861      [Pm, Pb]
    Po        1113222113                                   1840.1669683    [Bi]
    At        1322113                                      2398.7998311    [Po]
    Rn        311311222113                                 3127.0209328    [Ho, At]
    Fr        1113122113                                   4076.3134078    [Rn]
    Ra        132113                                       5313.7894999    [Fr]
    Ac        3113                                         6926.9352045    [Ra]
    Th        1113                                         7581.9047124    [Ac]
    Pa        13                                           9883.5986391    [Th]
    U         3                                            102.5628525     [Pa]
    Np5       13112221133211322112211213322115             0.0             [Hf, Pa, H, Ca, Pu5]
    Np7       13112221133211322112211213322117             0.0             [Hf, Pa, H, Ca, Pu7]
    Np8       13112221133211322112211213322118             0.0             [Hf, Pa, H, Ca, Pu8]
    Pu5       312211322212221121123222115                  0.0             [Np5]
    Pu7       312211322212221121123222117                  0.0             [Np7]
    Pu8       312211322212221121123222118                  0.0             [Np8]
 
    ```

    ## Example Session: Standard Ternary

    ```python
    &gt;&gt;&gt; # Define the say function:
    ... def ternary(num):
    ...     if num &lt; 3:
    ...         return str(num)
    ...     return ternary(num // 3) + str(num % 3)
    ... 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Use the Split Function Factory to create a split function:
    ... sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;0&#39;)
    &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;2&#39;, &#39;1110&#39;), (&#39;2&#39;, &#39;10&#39;))
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Instantiate the LookAndSay and Chemistry objects:
    ... ternary_ls = LookAndSay(ternary)
    &gt;&gt;&gt; ternary_chem = Chemistry(ternary_ls, split)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Generate elements and order them according to relative abundances:
    ... ternary_chem.generate_elements(&#39;0&#39;, &#39;1&#39;, &#39;2&#39;)
    &gt;&gt;&gt; ternary_chem.order_elements(&#39;abundance&#39;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Print chemical properties:
    ... ternary_chem.print_periodic_table()
    element   string     abundance    decay
    E1        10         18.5037375   [E4]
    E2        22110      13.9680582   [E5]
    E3        2110       13.9680582   [E6]
    E4        1110       13.9680582   [E1, E7]
    E5        222110     10.5441752   [E1, E2]
    E6        122110     10.5441752   [E8]
    E7        110        10.5441752   [E3]
    E8        11222110   7.9595623    [E3, E2]
    E9        222112     0.0          [E1, E10]
    E10       22112      0.0          [E9]
    E11       212221     0.0          [E16, E4, E13]
    E12       2112       0.0          [E14]
    E13       211        0.0          [E15]
    E14       122112     0.0          [E17]
    E15       1221       0.0          [E18]
    E16       12         0.0          [E20]
    E17       11222112   0.0          [E3, E10]
    E18       112211     0.0          [E11]
    E19       112        0.0          [E12]
    E20       1112       0.0          [E1, E19]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(ternary_chem.get_char_poly())
    lambda**6*(lambda - 1)**2*(lambda + 1)**2*(lambda**2 + 1)*(lambda**3 - lambda - 1)*(lambda**5 - lambda**3 + 1)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(ternary_chem.get_max_eigenvalue())
    1.3247179572447458

    ```

    
    ## Example Session: Balanced Ternary
    In this example we find the chemical properties of a [balanced ternary](https://en.wikipedia.org/wiki/Balanced_ternary)
    look and say sequence. 

    ```python
    &gt;&gt;&gt; # Define a (partial) say function to convert integers to balanced ternary:
    ... def bal_tern(num):
    ...     assert num &lt; 11, &#34;bal_tern will only convert integers from 1 to 10.&#34;
    ...     repn = {1:&#39;1&#39;, 2:&#39;1T&#39;, 3:&#39;10&#39;, 4:&#39;11&#39;, 5:&#39;1TT&#39;, 6:&#39;1T0&#39;, 7:&#39;1T1&#39;, 8:&#39;10T&#39;, 9:&#39;100&#39;, 10:&#39;101&#39;}
    ...     return repn[num]
    ... 
    &gt;&gt;&gt; # Use the split function factory to generate an appropriate split function: 
    ... sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;0&#39;, &#39;T&#39;)
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Instantiate the look and say and chemistry objects:
    ... bal_tern_ls = LookAndSay(bal_tern)
    &gt;&gt;&gt; bal_tern_chem = Chemistry(bal_tern_ls, split)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Generate persistent elements from the seed &#39;0&#39;, and order them according to their relative abundance:
    ... bal_tern_chem.generate_elements(&#39;0&#39;)
    &gt;&gt;&gt; bal_tern_chem.order_elements(&#39;abundance&#39;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Print the chemical properties
    ... bal_tern_chem.print_periodic_table()
    element   string   abundance    decay
    E1        1T       23.6067977   [E3]
    E2        11T      23.6067977   [E1, E2]
    E3        111T     14.5898034   [E5, E2]
    E4        110      14.5898034   [E1, E4]
    E5        10       14.5898034   [E6]
    E6        1110     9.0169944    [E5, E4]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(bal_tern_chem.get_char_poly())
    lambda**3*(lambda - 1)*(lambda**2 - lambda - 1)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(bal_tern_chem.get_max_eigenvalue()) # golden!
    1.6180339887498945

    ```
    &#34;&#34;&#34;
    def __init__(self, las, split = split_Conway, elements = None):
        super(Chemistry, self).__init__()
        self.las = las
        self.split = split
        if elements == None:
            elements = []
        self.elements = elements

    def get_elements(self):
        &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
        return self.elements

    def clear_elements(self):
        &#34;&#34;&#34;Resets the list of elements back to the empty list.&#34;&#34;&#34;
        self.elements = []

    def _split_to_elements(self, string): 
        return [Element(chunk, self.las) for chunk in self.split(string)]

    def _generate_all_elements(self, strings):
        for string in strings:
            for elt in self._split_to_elements(string):
                if elt not in self.elements:
                    # add elt to the chemistry:
                    self.elements.append(elt)
                    # recursively set the decay for elt:
                    decay_elts = self._split_to_elements(self.las.say_what_you_see(elt.get_string()))
                    self._generate_all_elements(map(lambda e : e.get_string(), decay_elts))
                    elt._set_decay(decay_elts)
        # clean up decay for all elements:
        for elt in self.elements:
            dec = []
            for d in elt.get_decay():
                dec += [e for e in self.elements if e == d]
            elt._set_decay(dec)

    def _remove_intermittent_elements(self): 
        while True:
            common_elements = []
            for elt in self.elements:
                for d in elt.get_decay():
                    if d not in common_elements:
                        common_elements.append(d)
            if len(common_elements) &lt; len(self.elements):
                self.elements = list(common_elements)
            else: 
                break

    def generate_elements(self, *seeds, reset = True):
        &#34;&#34;&#34;
        Collects all the persistent elements from all the look and
        say sequences generated by the given seeds. The string(s) entered as the 
        parameter(s) will be used as the seed(s) for generating the elements. 
        By default, this method will clear any elements in the chemistry that exist 
        before this method is called (i.e. prior to collecting from the new seeds). 
        Use ``reset = False``  to keep the old elements. 
        &#34;&#34;&#34;
        if reset:
            self.clear_elements()
        strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
        self._generate_all_elements(strings)
        self._remove_intermittent_elements()
        self.order_elements(&#39;string&#39;)
        self._name_elements()

    def _name_elements(self):
        if self.las._is_Conway:
            for e in self.get_elements():
                e.set_name(_conway_name(e))
            self.elements = sorted(self.get_elements(), key = _conway_number)
        else:
            for i, e in enumerate(self.get_elements()):
                e.set_name(&#39;E&#39; + str(i + 1))

    def get_decay_matrix(self):
        &#34;&#34;&#34;
        Returns the decay matrix as a nested list of integers 
        (i.e. a list of the rows).
        The order of the columns and rows correspond to the order
        in the list of elements.
        &#34;&#34;&#34;
        mat = []
        e = self.elements
        for i in range(len(e)):
            row = []
            for j in range(len(e)):
                row.append(e[j].get_decay().count(e[i]))
            mat.append(row)
        return mat

    def get_max_eigenvalue(self):
        &#34;&#34;&#34;
        Returns the maximal real eigenvalue of the decay matrix.
        In the standard case, this will give Conway&#39;s constant. 
        In general, this will give the growth rate of the look and say sequence. 
        This method assumes the existence of a real eigenvalue which
        is larger than (the absolute value) of every other eigenvalue.
        This assumption is usually guaranteed by the Perron-Frobenius Theorem.
        &#34;&#34;&#34;
        assert len(self.elements) &gt; 0, &#34;The get_max_eigenvalue method requires a nonempty list of elements.\n\tTo fix: Use the generate_elements method prior to calling get_max_eigenvalue.&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        return max(eigenvalues).real

    def get_char_poly(self, factor = True, latex = False):
        &#34;&#34;&#34;
        Returns the characteristic polynomial of the decay matrix using sympy.
        By default the returned polynomial will be factored. 
        Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
        Use ``latex = True`` to return the polynomial formatted in latex.
        &#34;&#34;&#34;
        chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
        if factor:
            chi = sympy.factor(chi.as_expr())
        else:
            chi = chi.as_expr()
        if latex:
            return sympy.latex(chi)
        else:
            return chi

    def _get_abundances(self, dec_places = 7, abundance_sum = 100):
        &#34;&#34;&#34;
        Returns a list of relative abundances of each element.
        By default the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The abundances can be renormalized by setting the parameter ``abundance_sum``.
        The order of the list corresponds to the order of the list of elements.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        eigenvectors = eigenstuff[1]
        index = numpy.where(eigenvalues == max(eigenvalues))
        limiting_eigenvector_nparray = eigenvectors[:,index].real
        # The next two lines are converting the numpy array to a list
        limiting_eigenvector = limiting_eigenvector_nparray.tolist()
        limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
        abundance = [abs(round(abundance_sum * num / sum(limiting_eigenvector), dec_places)) for num in limiting_eigenvector]
        return abundance

    def get_periodic_table(self, dec_places = 7, abundance_sum = 100):
        &#34;&#34;&#34;
        Creates a periodic table including each element&#39;s name, string, relative abundance, and decay.
        Returns the periodic table as a nested dictionary.

        ## Example Session:
        ```python
        &gt;&gt;&gt; ls = LookAndSay()
        &gt;&gt;&gt; chem = Chemistry(ls)
        &gt;&gt;&gt; chem.generate_elements(&#39;4&#39;)
        &gt;&gt;&gt; print(chem.get_periodic_table())
        {&#39;H&#39;: {&#39;string&#39;: &#39;22&#39;, &#39;abundance&#39;: 9.1790383, &#39;decay&#39;: [H]}, &#39;He&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322112&#39;, &#39;abundance&#39;: 0.3237297, &#39;decay&#39;: [Hf, Pa, H, Ca, Li]}, &#39;Li&#39;: {&#39;string&#39;: &#39;312211322212221121123222112&#39;, &#39;abundance&#39;: 0.4220067, &#39;decay&#39;: [He]}, &#39;Be&#39;: {&#39;string&#39;: &#39;111312211312113221133211322112211213322112&#39;, &#39;abundance&#39;: 0.2263886, &#39;decay&#39;: [Ge, Ca, Li]}, &#39;B&#39;: {&#39;string&#39;: &#39;1321132122211322212221121123222112&#39;, &#39;abundance&#39;: 0.295115, &#39;decay&#39;: [Be]}, &#39;C&#39;: {&#39;string&#39;: &#39;3113112211322112211213322112&#39;, &#39;abundance&#39;: 0.3847053, &#39;decay&#39;: [B]}, &#39;N&#39;: {&#39;string&#39;: &#39;111312212221121123222112&#39;, &#39;abundance&#39;: 0.501493, &#39;decay&#39;: [C]}, &#39;O&#39;: {&#39;string&#39;: &#39;132112211213322112&#39;, &#39;abundance&#39;: 0.6537349, &#39;decay&#39;: [N]}, &#39;F&#39;: {&#39;string&#39;: &#39;31121123222112&#39;, &#39;abundance&#39;: 0.852194, &#39;decay&#39;: [O]}, &#39;Ne&#39;: {&#39;string&#39;: &#39;111213322112&#39;, &#39;abundance&#39;: 1.1109007, &#39;decay&#39;: [F]}, &#39;Na&#39;: {&#39;string&#39;: &#39;123222112&#39;, &#39;abundance&#39;: 1.4481449, &#39;decay&#39;: [Ne]}, &#39;Mg&#39;: {&#39;string&#39;: &#39;3113322112&#39;, &#39;abundance&#39;: 1.8850441, &#39;decay&#39;: [Pm, Na]}, &#39;Al&#39;: {&#39;string&#39;: &#39;1113222112&#39;, &#39;abundance&#39;: 2.4573007, &#39;decay&#39;: [Mg]}, &#39;Si&#39;: {&#39;string&#39;: &#39;1322112&#39;, &#39;abundance&#39;: 3.2032813, &#39;decay&#39;: [Al]}, &#39;P&#39;: {&#39;string&#39;: &#39;311311222112&#39;, &#39;abundance&#39;: 1.4895887, &#39;decay&#39;: [Ho, Si]}, &#39;S&#39;: {&#39;string&#39;: &#39;1113122112&#39;, &#39;abundance&#39;: 1.9417939, &#39;decay&#39;: [P]}, &#39;Cl&#39;: {&#39;string&#39;: &#39;132112&#39;, &#39;abundance&#39;: 2.5312784, &#39;decay&#39;: [S]}, &#39;Ar&#39;: {&#39;string&#39;: &#39;3112&#39;, &#39;abundance&#39;: 3.299717, &#39;decay&#39;: [Cl]}, &#39;K&#39;: {&#39;string&#39;: &#39;1112&#39;, &#39;abundance&#39;: 4.3014361, &#39;decay&#39;: [Ar]}, &#39;Ca&#39;: {&#39;string&#39;: &#39;12&#39;, &#39;abundance&#39;: 5.6072543, &#39;decay&#39;: [K]}, &#39;Sc&#39;: {&#39;string&#39;: &#39;3113112221133112&#39;, &#39;abundance&#39;: 0.9302097, &#39;decay&#39;: [Ho, Pa, H, Ca, Co]}, &#39;Ti&#39;: {&#39;string&#39;: &#39;11131221131112&#39;, &#39;abundance&#39;: 1.2126003, &#39;decay&#39;: [Sc]}, &#39;V&#39;: {&#39;string&#39;: &#39;13211312&#39;, &#39;abundance&#39;: 1.5807182, &#39;decay&#39;: [Ti]}, &#39;Cr&#39;: {&#39;string&#39;: &#39;31132&#39;, &#39;abundance&#39;: 2.0605883, &#39;decay&#39;: [V]}, &#39;Mn&#39;: {&#39;string&#39;: &#39;111311222112&#39;, &#39;abundance&#39;: 2.686136, &#39;decay&#39;: [Cr, Si]}, &#39;Fe&#39;: {&#39;string&#39;: &#39;13122112&#39;, &#39;abundance&#39;: 3.5015859, &#39;decay&#39;: [Mn]}, &#39;Co&#39;: {&#39;string&#39;: &#39;32112&#39;, &#39;abundance&#39;: 4.5645877, &#39;decay&#39;: [Fe]}, &#39;Ni&#39;: {&#39;string&#39;: &#39;11133112&#39;, &#39;abundance&#39;: 1.3871124, &#39;decay&#39;: [Zn, Co]}, &#39;Cu&#39;: {&#39;string&#39;: &#39;131112&#39;, &#39;abundance&#39;: 1.8082082, &#39;decay&#39;: [Ni]}, &#39;Zn&#39;: {&#39;string&#39;: &#39;312&#39;, &#39;abundance&#39;: 2.3571391, &#39;decay&#39;: [Cu]}, &#39;Ga&#39;: {&#39;string&#39;: &#39;13221133122211332&#39;, &#39;abundance&#39;: 0.1447891, &#39;decay&#39;: [Eu, Ca, Ac, H, Ca, Zn]}, &#39;Ge&#39;: {&#39;string&#39;: &#39;31131122211311122113222&#39;, &#39;abundance&#39;: 0.1887437, &#39;decay&#39;: [Ho, Ga]}, &#39;As&#39;: {&#39;string&#39;: &#39;11131221131211322113322112&#39;, &#39;abundance&#39;: 0.0027246, &#39;decay&#39;: [Ge, Na]}, &#39;Se&#39;: {&#39;string&#39;: &#39;13211321222113222112&#39;, &#39;abundance&#39;: 0.0035518, &#39;decay&#39;: [As]}, &#39;Br&#39;: {&#39;string&#39;: &#39;3113112211322112&#39;, &#39;abundance&#39;: 0.00463, &#39;decay&#39;: [Se]}, &#39;Kr&#39;: {&#39;string&#39;: &#39;11131221222112&#39;, &#39;abundance&#39;: 0.0060355, &#39;decay&#39;: [Br]}, &#39;Rb&#39;: {&#39;string&#39;: &#39;1321122112&#39;, &#39;abundance&#39;: 0.0078678, &#39;decay&#39;: [Kr]}, &#39;Sr&#39;: {&#39;string&#39;: &#39;3112112&#39;, &#39;abundance&#39;: 0.0102563, &#39;decay&#39;: [Rb]}, &#39;Y&#39;: {&#39;string&#39;: &#39;1112133&#39;, &#39;abundance&#39;: 0.0133699, &#39;decay&#39;: [Sr, U]}, &#39;Zr&#39;: {&#39;string&#39;: &#39;12322211331222113112211&#39;, &#39;abundance&#39;: 0.0174286, &#39;decay&#39;: [Y, H, Ca, Tc]}, &#39;Nb&#39;: {&#39;string&#39;: &#39;1113122113322113111221131221&#39;, &#39;abundance&#39;: 0.0227196, &#39;decay&#39;: [Er, Zr]}, &#39;Mo&#39;: {&#39;string&#39;: &#39;13211322211312113211&#39;, &#39;abundance&#39;: 0.0296167, &#39;decay&#39;: [Nb]}, &#39;Tc&#39;: {&#39;string&#39;: &#39;311322113212221&#39;, &#39;abundance&#39;: 0.0386077, &#39;decay&#39;: [Mo]}, &#39;Ru&#39;: {&#39;string&#39;: &#39;132211331222113112211&#39;, &#39;abundance&#39;: 0.0328995, &#39;decay&#39;: [Eu, Ca, Tc]}, &#39;Rh&#39;: {&#39;string&#39;: &#39;311311222113111221131221&#39;, &#39;abundance&#39;: 0.042887, &#39;decay&#39;: [Ho, Ru]}, &#39;Pd&#39;: {&#39;string&#39;: &#39;111312211312113211&#39;, &#39;abundance&#39;: 0.0559065, &#39;decay&#39;: [Rh]}, &#39;Ag&#39;: {&#39;string&#39;: &#39;132113212221&#39;, &#39;abundance&#39;: 0.0728785, &#39;decay&#39;: [Pd]}, &#39;Cd&#39;: {&#39;string&#39;: &#39;3113112211&#39;, &#39;abundance&#39;: 0.0950027, &#39;decay&#39;: [Ag]}, &#39;In&#39;: {&#39;string&#39;: &#39;11131221&#39;, &#39;abundance&#39;: 0.1238434, &#39;decay&#39;: [Cd]}, &#39;Sn&#39;: {&#39;string&#39;: &#39;13211&#39;, &#39;abundance&#39;: 0.1614395, &#39;decay&#39;: [In]}, &#39;Sb&#39;: {&#39;string&#39;: &#39;3112221&#39;, &#39;abundance&#39;: 0.2104488, &#39;decay&#39;: [Pm, Sn]}, &#39;Te&#39;: {&#39;string&#39;: &#39;1322113312211&#39;, &#39;abundance&#39;: 0.2743363, &#39;decay&#39;: [Eu, Ca, Sb]}, &#39;I&#39;: {&#39;string&#39;: &#39;311311222113111221&#39;, &#39;abundance&#39;: 0.3576186, &#39;decay&#39;: [Ho, Te]}, &#39;Xe&#39;: {&#39;string&#39;: &#39;11131221131211&#39;, &#39;abundance&#39;: 0.4661834, &#39;decay&#39;: [I]}, &#39;Cs&#39;: {&#39;string&#39;: &#39;13211321&#39;, &#39;abundance&#39;: 0.6077061, &#39;decay&#39;: [Xe]}, &#39;Ba&#39;: {&#39;string&#39;: &#39;311311&#39;, &#39;abundance&#39;: 0.7921919, &#39;decay&#39;: [Cs]}, &#39;La&#39;: {&#39;string&#39;: &#39;11131&#39;, &#39;abundance&#39;: 1.0326833, &#39;decay&#39;: [Ba]}, &#39;Ce&#39;: {&#39;string&#39;: &#39;1321133112&#39;, &#39;abundance&#39;: 1.3461825, &#39;decay&#39;: [La, H, Ca, Co]}, &#39;Pr&#39;: {&#39;string&#39;: &#39;31131112&#39;, &#39;abundance&#39;: 1.7548529, &#39;decay&#39;: [Ce]}, &#39;Nd&#39;: {&#39;string&#39;: &#39;111312&#39;, &#39;abundance&#39;: 2.2875864, &#39;decay&#39;: [Pr]}, &#39;Pm&#39;: {&#39;string&#39;: &#39;132&#39;, &#39;abundance&#39;: 2.9820456, &#39;decay&#39;: [Nd]}, &#39;Sm&#39;: {&#39;string&#39;: &#39;311332&#39;, &#39;abundance&#39;: 1.5408115, &#39;decay&#39;: [Pm, Ca, Zn]}, &#39;Eu&#39;: {&#39;string&#39;: &#39;1113222&#39;, &#39;abundance&#39;: 2.0085669, &#39;decay&#39;: [Sm]}, &#39;Gd&#39;: {&#39;string&#39;: &#39;13221133112&#39;, &#39;abundance&#39;: 2.1662973, &#39;decay&#39;: [Eu, Ca, Co]}, &#39;Tb&#39;: {&#39;string&#39;: &#39;3113112221131112&#39;, &#39;abundance&#39;: 2.8239359, &#39;decay&#39;: [Ho, Gd]}, &#39;Dy&#39;: {&#39;string&#39;: &#39;111312211312&#39;, &#39;abundance&#39;: 3.6812186, &#39;decay&#39;: [Tb]}, &#39;Ho&#39;: {&#39;string&#39;: &#39;1321132&#39;, &#39;abundance&#39;: 4.7987529, &#39;decay&#39;: [Dy]}, &#39;Er&#39;: {&#39;string&#39;: &#39;311311222&#39;, &#39;abundance&#39;: 0.1098596, &#39;decay&#39;: [Ho, Pm]}, &#39;Tm&#39;: {&#39;string&#39;: &#39;11131221133112&#39;, &#39;abundance&#39;: 0.1204908, &#39;decay&#39;: [Er, Ca, Co]}, &#39;Yb&#39;: {&#39;string&#39;: &#39;1321131112&#39;, &#39;abundance&#39;: 0.1570691, &#39;decay&#39;: [Tm]}, &#39;Lu&#39;: {&#39;string&#39;: &#39;311312&#39;, &#39;abundance&#39;: 0.2047517, &#39;decay&#39;: [Yb]}, &#39;Hf&#39;: {&#39;string&#39;: &#39;11132&#39;, &#39;abundance&#39;: 0.2669097, &#39;decay&#39;: [Lu]}, &#39;Ta&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322113&#39;, &#39;abundance&#39;: 0.0242077, &#39;decay&#39;: [Hf, Pa, H, Ca, W]}, &#39;W&#39;: {&#39;string&#39;: &#39;312211322212221121123222113&#39;, &#39;abundance&#39;: 0.0315567, &#39;decay&#39;: [Ta]}, &#39;Re&#39;: {&#39;string&#39;: &#39;111312211312113221133211322112211213322113&#39;, &#39;abundance&#39;: 0.0169288, &#39;decay&#39;: [Ge, Ca, W]}, &#39;Os&#39;: {&#39;string&#39;: &#39;1321132122211322212221121123222113&#39;, &#39;abundance&#39;: 0.022068, &#39;decay&#39;: [Re]}, &#39;Ir&#39;: {&#39;string&#39;: &#39;3113112211322112211213322113&#39;, &#39;abundance&#39;: 0.0287673, &#39;decay&#39;: [Os]}, &#39;Pt&#39;: {&#39;string&#39;: &#39;111312212221121123222113&#39;, &#39;abundance&#39;: 0.0375005, &#39;decay&#39;: [Ir]}, &#39;Au&#39;: {&#39;string&#39;: &#39;132112211213322113&#39;, &#39;abundance&#39;: 0.0488847, &#39;decay&#39;: [Pt]}, &#39;Hg&#39;: {&#39;string&#39;: &#39;31121123222113&#39;, &#39;abundance&#39;: 0.063725, &#39;decay&#39;: [Au]}, &#39;Tl&#39;: {&#39;string&#39;: &#39;111213322113&#39;, &#39;abundance&#39;: 0.0830705, &#39;decay&#39;: [Hg]}, &#39;Pb&#39;: {&#39;string&#39;: &#39;123222113&#39;, &#39;abundance&#39;: 0.1082888, &#39;decay&#39;: [Tl]}, &#39;Bi&#39;: {&#39;string&#39;: &#39;3113322113&#39;, &#39;abundance&#39;: 0.1411629, &#39;decay&#39;: [Pm, Pb]}, &#39;Po&#39;: {&#39;string&#39;: &#39;1113222113&#39;, &#39;abundance&#39;: 0.1840167, &#39;decay&#39;: [Bi]}, &#39;At&#39;: {&#39;string&#39;: &#39;1322113&#39;, &#39;abundance&#39;: 0.23988, &#39;decay&#39;: [Po]}, &#39;Rn&#39;: {&#39;string&#39;: &#39;311311222113&#39;, &#39;abundance&#39;: 0.3127021, &#39;decay&#39;: [Ho, At]}, &#39;Fr&#39;: {&#39;string&#39;: &#39;1113122113&#39;, &#39;abundance&#39;: 0.4076313, &#39;decay&#39;: [Rn]}, &#39;Ra&#39;: {&#39;string&#39;: &#39;132113&#39;, &#39;abundance&#39;: 0.5313789, &#39;decay&#39;: [Fr]}, &#39;Ac&#39;: {&#39;string&#39;: &#39;3113&#39;, &#39;abundance&#39;: 0.6926935, &#39;decay&#39;: [Ra]}, &#39;Th&#39;: {&#39;string&#39;: &#39;1113&#39;, &#39;abundance&#39;: 0.7581905, &#39;decay&#39;: [Ac]}, &#39;Pa&#39;: {&#39;string&#39;: &#39;13&#39;, &#39;abundance&#39;: 0.9883599, &#39;decay&#39;: [Th]}, &#39;U&#39;: {&#39;string&#39;: &#39;3&#39;, &#39;abundance&#39;: 0.0102563, &#39;decay&#39;: [Pa]}, &#39;Np4&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322114&#39;, &#39;abundance&#39;: 0.0, &#39;decay&#39;: [Hf, Pa, H, Ca, Pu4]}, &#39;Pu4&#39;: {&#39;string&#39;: &#39;312211322212221121123222114&#39;, &#39;abundance&#39;: 0.0, &#39;decay&#39;: [Np4]}}

        ```
        &#34;&#34;&#34;
        return {e.get_name() : {&#39;string&#39; : e.get_string(), 
                                &#39;abundance&#39; : self._get_abundances(dec_places, abundance_sum)[i],
                                &#39;decay&#39; : e.get_decay()}
                                for i, e in enumerate(self.get_elements())}

    def print_periodic_table(self, dec_places = 7, abundance_sum = 100):
        &#34;&#34;&#34;
        Prints the periodic table. Note the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The parameter ``dec_places`` refers to the accuracy of the abundances.
        &#34;&#34;&#34;
        pt = self.get_periodic_table(dec_places, abundance_sum)
        elt_width = 2 + max(len(&#39;element&#39;), max([len(e.get_name()) for e in self.get_elements()]))
        str_width = 2 + max(len(&#39;string&#39;), max([len(e.get_string()) for e in self.get_elements()]))
        ab_width  = 2 + max(len(&#39;abundance&#39;), max([len(str(prop[&#39;abundance&#39;])) for elt, prop in pt.items()]))
        print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(&#39;element&#39;, &#39;string&#39;, &#39;abundance&#39;, &#39;decay&#39;, elt_width=elt_width, str_width=str_width, ab_width=ab_width))
        for elt, prop in pt.items():
            print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(elt, prop[&#39;string&#39;], prop[&#39;abundance&#39;], str(prop[&#39;decay&#39;]), elt_width=elt_width, str_width=str_width, ab_width=ab_width))

    def order_elements(self, order_on, key = None, reverse = False, rename = True):
        &#34;&#34;&#34;
        Reorders the list of elements depending on the parameter ``order_on`` as follows:

        * ``order_on=&#39;abundance&#39;``: Orders elements from highest abundance to lowest.
        * ``order_on=&#39;string&#39;``: Orders elements according to the lexicographic order of their strings.
        * ``order_on=&#39;string length&#39;``: Orders elements according to the lengths of their strings from shortest to longest.
        * ``order_on=&#39;name&#39;``: Orders elements alphabetically according to their names.
        * ``order_on=&#39;key&#39;``: Orders elements according to the function specified by the parameter ``key``.

        You can reverse the ordering above by passing the extra parameter ``reverse = True``.
        
        By default this method will automatically rename the elements according to their new order.
        This will not happen if the elements are named via Conway or if the parameter ``rename = False`` is passed.
        &#34;&#34;&#34;
        assert order_on in [&#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, &#39;key&#39;], &#34;Invalid parameter passed to order_elements. Valid parameter are &#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, and &#39;key&#39;.&#34;
        pt = self.get_periodic_table()
        sorted_key = {
            &#39;abundance&#39;: lambda e : pt[e.get_name()][&#39;abundance&#39;],
            &#39;name&#39;: lambda e : e.get_name(),
            &#39;string&#39;: lambda e : e.get_string(),
            &#39;string length&#39;: lambda e : len(e.get_string()),
            &#39;key&#39;: key
        }
        self.elements = sorted(self.get_elements(), key = sorted_key[order_on])
        if order_on == &#39;abundance&#39;:
            self.elements.reverse()
        if reverse:
            self.elements.reverse()
        if not self.las._is_Conway and rename:
            self._name_elements()

class BinaryChemistry(Chemistry):
    &#34;&#34;&#34;
    A chemistry for binary look and say sequences that split as 1.0 
    (i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
    the say-what-you-see operation maps 
    \\(a^b\\) to \\([b]a\\) where \\([b]\\) is a binary
    string that always starts with a 1. For example, this chemistry is 
    valid for standard base two binary look and say sequences. 

    ## Example Session: Standard Binary

    ```python
    &gt;&gt;&gt; def binary_say(num):
    ...     return &#34;{0:b}&#34;.format(num)
    ... 
    &gt;&gt;&gt; binary_ls = LookAndSay(binary_say)
    &gt;&gt;&gt; binary_chem = BinaryChemistry(binary_ls)
    &gt;&gt;&gt; binary_chem.generate_elements(&#39;1&#39;)
    &gt;&gt;&gt; binary_chem.order_elements(&#39;abundance&#39;)
    &gt;&gt;&gt; binary_chem.print_periodic_table()
    element   string   abundance    decay
    E1        110      21.6756572   [E2, E1]
    E2        10       21.6756572   [E3]
    E3        1110     14.7899036   [E4]
    E4        11110    10.0915624   [E6, E1]
    E5        1100     10.0915624   [E2, E5]
    E6        100      10.0915624   [E7]
    E7        11100    6.8857536    [E8]
    E8        111100   4.6983411    [E6, E5]
    E9        11       0.0          [E2, E10]
    E10       1        0.0          [E9]
    &gt;&gt;&gt;
    &gt;&gt;&gt; print(binary_chem.get_max_eigenvalue())
    1.4655712318767664

    ```

    ## Example Session: Twindragon Binary
    The following chemistry corresponds to the binary number system using 
    the complex base \\(-1+i.\\) This binary number system is known as *twindragon binary*.

    ```python
    &gt;&gt;&gt; def twindragon_say(num):
    ...     assert num &lt; 8, &#34;This twindragon can only count to 7.&#34;
    ...     twindragon = {1:&#39;1&#39;, 2:&#39;1100&#39;, 3:&#39;1101&#39;, 4:&#39;111010000&#39;, 5:&#39;111010001&#39;, 6:&#39;111011100&#39;, 7:&#39;111011101&#39;}
    ...     return twindragon[num]
    ... 
    &gt;&gt;&gt; twindragon_ls = LookAndSay(twindragon_say)
    &gt;&gt;&gt; twindragon_chem = BinaryChemistry(twindragon_ls)
    &gt;&gt;&gt; twindragon_chem.generate_elements(&#39;1&#39;)
    &gt;&gt;&gt; twindragon_chem.print_periodic_table()
    element   string   abundance    decay
    E1        1        0.0          [E6]
    E2        10       6.746022     [E9]
    E3        1000     1.5358344    [E11, E2]
    E4        10000    2.8580442    [E12, E5]
    E5        100000   1.3339664    [E12, E3, E2]
    E6        11       0.0          [E8, E1]
    E7        110      28.3551578   [E8, E7]
    E8        1100     24.8181731   [E8, E10]
    E9        1110     14.6891551   [E7, E9]
    E10       111000   11.5836587   [E7, E11, E2]
    E11       11110    6.1234052    [E9, E4, E7]
    E12       111110   1.9565832    [E9, E3, E9]

    ```
    &#34;&#34;&#34;
    def __init__(self, las, elements = None):
        sff = SplitFuncFactory()
        sff.declare_split_before(&#39;1&#39;)
        binary_split = sff.get_split()
        super().__init__(las, binary_split, elements)

########### ELEMENT #######################

class Element():
    &#34;&#34;&#34;
    An element consists of a string (usually a chunk of digits) and 
    a name. For example, in Conway&#39;s chemistry there is an element
    named H (short for Hydrogen) consisting of the string &#39;22&#39;. 
    Each element decays into a list of other elements. 
    The only methods for this class are getters and a setter.
    &#34;&#34;&#34;
    def __init__(self, string, las, decay = []):
        super(Element, self).__init__()
        self.string = string
        self.las = las
        self.name = string
        self.decay = decay

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        if isinstance(other, Element):
                return self.string == other.string and self.las == other.las
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        return hash(tuple(sorted(self.__dict__.items())))

    def _set_decay(self, elements):
        self.decay = elements

    def get_decay(self):
        return self.decay

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def get_string(self):
        return self.string

########### SPLIT FUNCTION FACTORY #####################

class SplitFuncFactory():
    &#34;&#34;&#34;
    A class to help create a split function. The split function factory
    can produce a split function via any combination of the following:

    * Specifying specific chunks L and R such that LR splits as L.R.
    * Specifying specific characters or chunks to always split before or after.

    ## Example Session: Split after 0
    Many look and say sequences split after any run of 0&#39;s. 
    The following illustrates how the split function factory can 
    be used to create such a split function:
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;0&#39;)
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;1101230022200012301325023&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;110&#39;, &#39;12300&#39;, &#39;222000&#39;, &#39;1230&#39;, &#39;13250&#39;, &#39;23&#39;]

    ```


    ## Example Session: A combination of multiple methods.
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_before(&#39;111&#39;)
    &gt;&gt;&gt; sff.declare_split_after(&#39;2&#39;, &#39;30&#39;)
    &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;11&#39;, &#39;333&#39;))
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;1234411154211333234530411113333344&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;12&#39;, &#39;344&#39;, &#39;111542&#39;, &#39;11&#39;, &#39;3332&#39;, &#39;34530&#39;, &#39;4&#39;, &#39;1111&#39;, &#39;3333344&#39;]

    ```
    &#34;&#34;&#34;
    def __init__(self):
        self._splitting_pairs = []
        self._chunks_before_split = []
        self._chunks_after_split = []
        self._split_conditions = []

    def get_split(self):
        &#34;&#34;&#34;Returns the split function.&#34;&#34;&#34;
        return lambda string : self._split(string)

    def _split(self, string):
        chunks = []
        start = 0
        for i in range(1, len(string)):
            if self._is_split(string[start:i], string[i:]):
                chunks.append(string[start:i])
                start = i
        chunks.append(string[start:])
        return chunks

    def _is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
            return True
        if L[-1] == R[0]:
            return False
        for l in self._chunks_before_split:
            if len(l) &lt;= len(L) and l == L[-len(l):]:
                return True
        for r in self._chunks_after_split:
            if len(r) &lt;= len(R) and r == R[:len(r)]:
                return True
        for l, r in self._splitting_pairs:
            if len(l) &lt;= len(L) and len(r) &lt;= len(R) and l == L[-len(l):] and r == R[:len(r)]:
                return True
        for condition in self._split_conditions:
            if condition(L, R):
                return True
        return False

    def declare_splitting_pairs(self, *pairs):
        &#34;&#34;&#34;
        Specify pairs of chunks in the form (L, R) 
        such that LR always splits as L.R.

        ## Example Session:
        ```python
        &gt;&gt;&gt; sff = SplitFuncFactory()
        &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;311&#39;, &#39;223&#39;), (&#39;0&#39;, &#39;1&#39;))
        &gt;&gt;&gt; split = sff.get_split()
        &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
        &gt;&gt;&gt; print(split(string))
        [&#39;12311&#39;, &#39;2233231120&#39;, &#39;112000&#39;, &#39;11110234234&#39;]

        ```
        &#34;&#34;&#34;
        for pair in pairs:
            self._splitting_pairs.append(pair)

    def declare_split_after(self, *chunks):
        &#34;&#34;&#34;
        Specify chunks L such that LR splits for every possible R (assuming the last character of L and the first character of R are distinct).
        
        ## Example Session:
        ```python
        &gt;&gt;&gt; sff = SplitFuncFactory()
        &gt;&gt;&gt; sff.declare_split_after(&#39;1&#39;, &#39;20&#39;)
        &gt;&gt;&gt; split = sff.get_split()
        &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
        &gt;&gt;&gt; print(split(string))
        [&#39;1&#39;, &#39;2311&#39;, &#39;22332311&#39;, &#39;20&#39;, &#39;11&#39;, &#39;20001111&#39;, &#39;0234234&#39;]

        ```
        &#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_before_split.append(chunk)

    def declare_split_before(self, *chunks):
        &#34;&#34;&#34;Specify chunks R such that LR splits for every possible L (assuming the last character of L and the first character of R are distinct).

        ## Example Session:
        ```python
        &gt;&gt;&gt; sff = SplitFuncFactory()
        &gt;&gt;&gt; sff.declare_split_before(&#39;0&#39;, &#39;31&#39;)
        &gt;&gt;&gt; split = sff.get_split()
        &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
        &gt;&gt;&gt; print(split(string))
        [&#39;12&#39;, &#39;31122332&#39;, &#39;3112&#39;, &#39;0112&#39;, &#39;0001111&#39;, &#39;0234234&#39;]

        ```
        &#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_after_split.append(chunk)

########### COSMOLOGY #####################

class Cosmology():
    &#39;&#39;&#39;
    A class for proving Conway&#39;s Cosmological Theorem.
    Currently this will only prove The Cosmological Theorem 
    for the standard base ten look and say sequences where every term
    consists of strings of some of the digits 1 through 9. The default
    digits considered are the crucial ones: 1, 2, and 3.  
    &#39;&#39;&#39;
    def __init__(self, digits = &#39;123&#39;):
        self.look_and_say = LookAndSay()
        self.split = split_Conway
        self.digits = digits
        self._compendium_sets = []
        self.common_strings = {elt for elt in _CONWAY_ELEMENTS}
        # add transuranic elements to the list of common strings:
        for digit in self.digits:
            if digit not in &#39;123&#39;:
                self.common_strings.add(&#39;31221132221222112112322211&#39; + digit)
                self.common_strings.add(&#39;1311222113321132211221121332211&#39; + digit)

    def days_exotic(self, string):
        &#39;&#39;&#39;
        Returns the number of days until the string splits into a compound of common elements. 
        &#39;&#39;&#39;
        atoms = [atom for atom in self.split(string) if atom not in self.common_strings]
        days = 0
        while atoms != []:
            next_atoms = []
            for atom in atoms:
                new_atoms = self.split(self.look_and_say.say_what_you_see(atom))
                next_atoms += [a for a in new_atoms if a not in self.common_strings]
            atoms = next_atoms
            days += 1
        return days

    def proof(self, day = 9):
        &#39;&#39;&#39;
        Uses a backtracking algorithm to prove Conway&#39;s Cosmological Theorem. If we pass the parameter
        ``day = N`` the algorithm searches for all strings that might appear as chunks of an N-day
        old element. The search starts with strings of length 1 (i.e. the digits) and then 
        searches for strings of length 2, then length 3, etc. For each string found in the search, 
        the algorithm repeatedly applies the say-what-you-see operation until the result is a 
        compound of common elements. The algorithm terminates when for some positive integer L, 
        there are no strings of length L that can appear as chunks of an N-day old element, and 
        all strings of length less than L which might appear as a chunk of an N-day old element 
        are shown to eventually decay into a compound of common elements.

        Running the program prints a few details about the search. In particular, an upper bound
        for the age of an exotic (i.e. not common) element is displayed.  

        The default parameter is ``day = 9``, which results in a proof of the Cosmological Theorem
        that gives an upper bound of 27 for the age of an exotic element. 

        The proof is essentially the same as that of Zeilberger. 
        The implementation is similar to that of Litherland.
        &#39;&#39;&#39;
        chunks = self.digits # start with length 1 chunks
        max_days_exotic = 0

        print(f&#39;To prove the Cosmological Theorem we search for all strings\nwhich could appear as chunks of {day} day old elements.\nSearching...&#39;)
        length = 0
        while True:
            length += 1
            compendium = []
            #Gather all chunks that have a grandparent to the compendium
            for chunk in chunks:
                if self._has_grandparent(chunk, day):
                    compendium.append(chunk)

            if compendium == []:
                print(f&#39;There are no strings of length {length} that can appear as chunks\nof {day} day old elements. All strings of length less than {length}\nthat could appear after {day} days decay into compounds of common\nelements after an additional {max_days_exotic-day} days. This gives an upper\nbound of {max_days_exotic} days for the age of an exotic element.\nQ.E.D.&#39;)
                return max_days_exotic

            self._compendium_sets.append(set(compendium))

            #Compute an upper bound on the maximum longevity of an exotic element:
            for chunk in compendium:
                lifespan = day + self.days_exotic(chunk)
                if lifespan &gt; max_days_exotic:
                    max_days_exotic = lifespan

            chunks = []
            #For each found above, add all possible digits to the left and check if splits
            for digit in self.digits:
                chunks += [digit+chunk for chunk in compendium if len(self.split(digit+chunk)) == 1]

    def _parents(self, kid):
        &#39;&#39;&#39;
        We call a string a *parent* of the kid if applying the say-what-you-see operation
        results in a string which contains the kid as a substring. This function returns
        a list of all the minimal parents of kid (here minimal means that every parent of
        the kid will contain one of the elements of the list as a substring).
        &#39;&#39;&#39;
        parents = []
        if self._is_day_one_even(kid):
            parents += self._even_parents(kid)
        if self._is_day_one_odd(kid):
            parents += self._odd_parents(kid)
        return parents

    def _is_day_one_odd(self, string):
        if len(string) == 1:
            return False
        if len(string) % 2 == 0:
            i = 0
        else:
            i = 1
        while i &lt; len(string) - 2:
            if string[i] == string[i+2]:
                return False
            i += 2
        return True

    def _is_day_one_even(self, string):
        if len(string) == 1:
            return True
        if len(string) % 2 == 0:
            i = 1
        else:
            i = 0
        while i &lt; len(string) - 2:
            if string[i] == string[i+2]:
                return False
            i += 2
        return True

    def _even_parents(self, string):
        new_string = &#39;&#39;
        if len(string) % 2 == 0:
            start = 0
        else:
            start = 1
            new_string += string[0]
        while start &lt; len(string) - 1:
            new_string += int(string[start]) * string[start+1]
            start += 2
        return [new_string]

    def _odd_parents(self, string):
        new_string = &#39;&#39;
        if len(string) % 2 == 0:
            start = 1
            new_string += string[0]
        else:
            start = 0
        while start &lt; len(string) - 2:
            new_string += int(string[start]) * string[start+1]
            start += 2
        return [new_string + int(string[-1]) * digit for digit in self.digits if digit != string[-2]]


    def _has_grandparent(self, kid, day):
        &#39;&#39;&#39;
        Returns True if the string kid *might* be contained in the result of applying
        the say-what-you-see operation day-times to some string. Note that this method
        will only return False when kid cannot be part of a day-old descendant of 
        any string,
        but may return True even if kid is not contained in any day-old descendant.
        &#39;&#39;&#39;
        # To speed things up, we first check the compendium sets:
        # if the kid has a parent who is already in a compendium, we know it&#39;s parent
        # has (possibly) a day-old ancestor, so certainly the kid also (possibly) has one.
        for parent in self._parents(kid):
            if len(parent) &lt; len(self._compendium_sets) and parent in self._compendium_sets[len(parent)]:
                return True

        # Now apply the parents function day-times and see what we get:
        ancestors = [kid]
        for _ in range(day):
            next_ancestors = []
            for a in ancestors:
                next_ancestors += self._parents(a)
            ancestors = next_ancestors

        return len(ancestors) != 0

if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="look_and_say.split_Conway"><code class="name flex">
<span>def <span class="ident">split_Conway</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits a string into a list of substrings according to Conway's Splitting Theorem.
Assumes the string is not empty. </p>
<h2 id="example-session">Example Session:</h2>
<pre><code class="language-python">&gt;&gt;&gt; from look_and_say import split_Conway
&gt;&gt;&gt; string = '1211132213'
&gt;&gt;&gt; chunks = split_Conway(string)
&gt;&gt;&gt; print(chunks)
['12', '1113', '22', '13']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_Conway(string):
    &#34;&#34;&#34;
    Splits a string into a list of substrings according to Conway&#39;s Splitting Theorem.
    Assumes the string is not empty. 

    ## Example Session:
    ```python
    &gt;&gt;&gt; from look_and_say import split_Conway
    &gt;&gt;&gt; string = &#39;1211132213&#39;
    &gt;&gt;&gt; chunks = split_Conway(string)
    &gt;&gt;&gt; print(chunks)
    [&#39;12&#39;, &#39;1113&#39;, &#39;22&#39;, &#39;13&#39;]

    ```
    &#34;&#34;&#34;
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if _is_split_pair_Conway(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="look_and_say.BinaryChemistry"><code class="flex name class">
<span>class <span class="ident">BinaryChemistry</span></span>
<span>(</span><span>las, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A chemistry for binary look and say sequences that split as 1.0
(i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
the say-what-you-see operation maps
<span><span class="MathJax_Preview">a^b</span><script type="math/tex">a^b</script></span> to <span><span class="MathJax_Preview">[b]a</span><script type="math/tex">[b]a</script></span> where <span><span class="MathJax_Preview">[b]</span><script type="math/tex">[b]</script></span> is a binary
string that always starts with a 1. For example, this chemistry is
valid for standard base two binary look and say sequences. </p>
<h2 id="example-session-standard-binary">Example Session: Standard Binary</h2>
<pre><code class="language-python">&gt;&gt;&gt; def binary_say(num):
...     return &quot;{0:b}&quot;.format(num)
... 
&gt;&gt;&gt; binary_ls = LookAndSay(binary_say)
&gt;&gt;&gt; binary_chem = BinaryChemistry(binary_ls)
&gt;&gt;&gt; binary_chem.generate_elements('1')
&gt;&gt;&gt; binary_chem.order_elements('abundance')
&gt;&gt;&gt; binary_chem.print_periodic_table()
element   string   abundance    decay
E1        110      21.6756572   [E2, E1]
E2        10       21.6756572   [E3]
E3        1110     14.7899036   [E4]
E4        11110    10.0915624   [E6, E1]
E5        1100     10.0915624   [E2, E5]
E6        100      10.0915624   [E7]
E7        11100    6.8857536    [E8]
E8        111100   4.6983411    [E6, E5]
E9        11       0.0          [E2, E10]
E10       1        0.0          [E9]
&gt;&gt;&gt;
&gt;&gt;&gt; print(binary_chem.get_max_eigenvalue())
1.4655712318767664

</code></pre>
<h2 id="example-session-twindragon-binary">Example Session: Twindragon Binary</h2>
<p>The following chemistry corresponds to the binary number system using
the complex base <span><span class="MathJax_Preview">-1+i.</span><script type="math/tex">-1+i.</script></span> This binary number system is known as <em>twindragon binary</em>.</p>
<pre><code class="language-python">&gt;&gt;&gt; def twindragon_say(num):
...     assert num &lt; 8, &quot;This twindragon can only count to 7.&quot;
...     twindragon = {1:'1', 2:'1100', 3:'1101', 4:'111010000', 5:'111010001', 6:'111011100', 7:'111011101'}
...     return twindragon[num]
... 
&gt;&gt;&gt; twindragon_ls = LookAndSay(twindragon_say)
&gt;&gt;&gt; twindragon_chem = BinaryChemistry(twindragon_ls)
&gt;&gt;&gt; twindragon_chem.generate_elements('1')
&gt;&gt;&gt; twindragon_chem.print_periodic_table()
element   string   abundance    decay
E1        1        0.0          [E6]
E2        10       6.746022     [E9]
E3        1000     1.5358344    [E11, E2]
E4        10000    2.8580442    [E12, E5]
E5        100000   1.3339664    [E12, E3, E2]
E6        11       0.0          [E8, E1]
E7        110      28.3551578   [E8, E7]
E8        1100     24.8181731   [E8, E10]
E9        1110     14.6891551   [E7, E9]
E10       111000   11.5836587   [E7, E11, E2]
E11       11110    6.1234052    [E9, E4, E7]
E12       111110   1.9565832    [E9, E3, E9]

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryChemistry(Chemistry):
    &#34;&#34;&#34;
    A chemistry for binary look and say sequences that split as 1.0 
    (i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
    the say-what-you-see operation maps 
    \\(a^b\\) to \\([b]a\\) where \\([b]\\) is a binary
    string that always starts with a 1. For example, this chemistry is 
    valid for standard base two binary look and say sequences. 

    ## Example Session: Standard Binary

    ```python
    &gt;&gt;&gt; def binary_say(num):
    ...     return &#34;{0:b}&#34;.format(num)
    ... 
    &gt;&gt;&gt; binary_ls = LookAndSay(binary_say)
    &gt;&gt;&gt; binary_chem = BinaryChemistry(binary_ls)
    &gt;&gt;&gt; binary_chem.generate_elements(&#39;1&#39;)
    &gt;&gt;&gt; binary_chem.order_elements(&#39;abundance&#39;)
    &gt;&gt;&gt; binary_chem.print_periodic_table()
    element   string   abundance    decay
    E1        110      21.6756572   [E2, E1]
    E2        10       21.6756572   [E3]
    E3        1110     14.7899036   [E4]
    E4        11110    10.0915624   [E6, E1]
    E5        1100     10.0915624   [E2, E5]
    E6        100      10.0915624   [E7]
    E7        11100    6.8857536    [E8]
    E8        111100   4.6983411    [E6, E5]
    E9        11       0.0          [E2, E10]
    E10       1        0.0          [E9]
    &gt;&gt;&gt;
    &gt;&gt;&gt; print(binary_chem.get_max_eigenvalue())
    1.4655712318767664

    ```

    ## Example Session: Twindragon Binary
    The following chemistry corresponds to the binary number system using 
    the complex base \\(-1+i.\\) This binary number system is known as *twindragon binary*.

    ```python
    &gt;&gt;&gt; def twindragon_say(num):
    ...     assert num &lt; 8, &#34;This twindragon can only count to 7.&#34;
    ...     twindragon = {1:&#39;1&#39;, 2:&#39;1100&#39;, 3:&#39;1101&#39;, 4:&#39;111010000&#39;, 5:&#39;111010001&#39;, 6:&#39;111011100&#39;, 7:&#39;111011101&#39;}
    ...     return twindragon[num]
    ... 
    &gt;&gt;&gt; twindragon_ls = LookAndSay(twindragon_say)
    &gt;&gt;&gt; twindragon_chem = BinaryChemistry(twindragon_ls)
    &gt;&gt;&gt; twindragon_chem.generate_elements(&#39;1&#39;)
    &gt;&gt;&gt; twindragon_chem.print_periodic_table()
    element   string   abundance    decay
    E1        1        0.0          [E6]
    E2        10       6.746022     [E9]
    E3        1000     1.5358344    [E11, E2]
    E4        10000    2.8580442    [E12, E5]
    E5        100000   1.3339664    [E12, E3, E2]
    E6        11       0.0          [E8, E1]
    E7        110      28.3551578   [E8, E7]
    E8        1100     24.8181731   [E8, E10]
    E9        1110     14.6891551   [E7, E9]
    E10       111000   11.5836587   [E7, E11, E2]
    E11       11110    6.1234052    [E9, E4, E7]
    E12       111110   1.9565832    [E9, E3, E9]

    ```
    &#34;&#34;&#34;
    def __init__(self, las, elements = None):
        sff = SplitFuncFactory()
        sff.declare_split_before(&#39;1&#39;)
        binary_split = sff.get_split()
        super().__init__(las, binary_split, elements)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></b></code>:
<ul class="hlist">
<li><code><a title="look_and_say.Chemistry.clear_elements" href="#look_and_say.Chemistry.clear_elements">clear_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.generate_elements" href="#look_and_say.Chemistry.generate_elements">generate_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_char_poly" href="#look_and_say.Chemistry.get_char_poly">get_char_poly</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_decay_matrix" href="#look_and_say.Chemistry.get_decay_matrix">get_decay_matrix</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_elements" href="#look_and_say.Chemistry.get_elements">get_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_max_eigenvalue" href="#look_and_say.Chemistry.get_max_eigenvalue">get_max_eigenvalue</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_periodic_table" href="#look_and_say.Chemistry.get_periodic_table">get_periodic_table</a></code></li>
<li><code><a title="look_and_say.Chemistry.order_elements" href="#look_and_say.Chemistry.order_elements">order_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.print_periodic_table" href="#look_and_say.Chemistry.print_periodic_table">print_periodic_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="look_and_say.Chemistry"><code class="flex name class">
<span>class <span class="ident">Chemistry</span></span>
<span>(</span><span>las, split=&lt;function split_Conway&gt;, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class responsible for generating all the persistent elements
appearing in look and say sequences, along with
the chemical properties of those elements.</p>
<p>Parameters in the constructor are a LookAndSay object <code>las</code> and
a splitting function <code>split</code>. The user is responsible
for verifying that the provided splitting function is valid for the given
LookAndSay object. The default splitting function corresponds to
Conway's original Splitting Theorem.</p>
<h2 id="example-session-conways-constant-and-his-92-common-elements">Example Session: Conway's Constant and his 92 Common Elements</h2>
<pre><code class="language-python">&gt;&gt;&gt; ls = LookAndSay()
&gt;&gt;&gt; chem = Chemistry(ls)
&gt;&gt;&gt; chem.generate_elements('1')
&gt;&gt;&gt; chem.print_periodic_table() 
element   string                                       abundance   decay
H         22                                           9.1790383   [H]
He        13112221133211322112211213322112             0.3237297   [Hf, Pa, H, Ca, Li]
Li        312211322212221121123222112                  0.4220067   [He]
Be        111312211312113221133211322112211213322112   0.2263886   [Ge, Ca, Li]
B         1321132122211322212221121123222112           0.295115    [Be]
C         3113112211322112211213322112                 0.3847053   [B]
N         111312212221121123222112                     0.501493    [C]
O         132112211213322112                           0.6537349   [N]
F         31121123222112                               0.852194    [O]
Ne        111213322112                                 1.1109007   [F]
Na        123222112                                    1.4481449   [Ne]
Mg        3113322112                                   1.8850441   [Pm, Na]
Al        1113222112                                   2.4573007   [Mg]
Si        1322112                                      3.2032813   [Al]
P         311311222112                                 1.4895887   [Ho, Si]
S         1113122112                                   1.9417939   [P]
Cl        132112                                       2.5312784   [S]
Ar        3112                                         3.299717    [Cl]
K         1112                                         4.3014361   [Ar]
Ca        12                                           5.6072543   [K]
Sc        3113112221133112                             0.9302097   [Ho, Pa, H, Ca, Co]
Ti        11131221131112                               1.2126003   [Sc]
V         13211312                                     1.5807182   [Ti]
Cr        31132                                        2.0605883   [V]
Mn        111311222112                                 2.686136    [Cr, Si]
Fe        13122112                                     3.5015859   [Mn]
Co        32112                                        4.5645877   [Fe]
Ni        11133112                                     1.3871124   [Zn, Co]
Cu        131112                                       1.8082082   [Ni]
Zn        312                                          2.3571391   [Cu]
Ga        13221133122211332                            0.1447891   [Eu, Ca, Ac, H, Ca, Zn]
Ge        31131122211311122113222                      0.1887437   [Ho, Ga]
As        11131221131211322113322112                   0.0027246   [Ge, Na]
Se        13211321222113222112                         0.0035518   [As]
Br        3113112211322112                             0.00463     [Se]
Kr        11131221222112                               0.0060355   [Br]
Rb        1321122112                                   0.0078678   [Kr]
Sr        3112112                                      0.0102563   [Rb]
Y         1112133                                      0.0133699   [Sr, U]
Zr        12322211331222113112211                      0.0174286   [Y, H, Ca, Tc]
Nb        1113122113322113111221131221                 0.0227196   [Er, Zr]
Mo        13211322211312113211                         0.0296167   [Nb]
Tc        311322113212221                              0.0386077   [Mo]
Ru        132211331222113112211                        0.0328995   [Eu, Ca, Tc]
Rh        311311222113111221131221                     0.042887    [Ho, Ru]
Pd        111312211312113211                           0.0559065   [Rh]
Ag        132113212221                                 0.0728785   [Pd]
Cd        3113112211                                   0.0950027   [Ag]
In        11131221                                     0.1238434   [Cd]
Sn        13211                                        0.1614395   [In]
Sb        3112221                                      0.2104488   [Pm, Sn]
Te        1322113312211                                0.2743363   [Eu, Ca, Sb]
I         311311222113111221                           0.3576186   [Ho, Te]
Xe        11131221131211                               0.4661834   [I]
Cs        13211321                                     0.6077061   [Xe]
Ba        311311                                       0.7921919   [Cs]
La        11131                                        1.0326833   [Ba]
Ce        1321133112                                   1.3461825   [La, H, Ca, Co]
Pr        31131112                                     1.7548529   [Ce]
Nd        111312                                       2.2875864   [Pr]
Pm        132                                          2.9820456   [Nd]
Sm        311332                                       1.5408115   [Pm, Ca, Zn]
Eu        1113222                                      2.0085669   [Sm]
Gd        13221133112                                  2.1662973   [Eu, Ca, Co]
Tb        3113112221131112                             2.8239359   [Ho, Gd]
Dy        111312211312                                 3.6812186   [Tb]
Ho        1321132                                      4.7987529   [Dy]
Er        311311222                                    0.1098596   [Ho, Pm]
Tm        11131221133112                               0.1204908   [Er, Ca, Co]
Yb        1321131112                                   0.1570691   [Tm]
Lu        311312                                       0.2047517   [Yb]
Hf        11132                                        0.2669097   [Lu]
Ta        13112221133211322112211213322113             0.0242077   [Hf, Pa, H, Ca, W]
W         312211322212221121123222113                  0.0315567   [Ta]
Re        111312211312113221133211322112211213322113   0.0169288   [Ge, Ca, W]
Os        1321132122211322212221121123222113           0.022068    [Re]
Ir        3113112211322112211213322113                 0.0287673   [Os]
Pt        111312212221121123222113                     0.0375005   [Ir]
Au        132112211213322113                           0.0488847   [Pt]
Hg        31121123222113                               0.063725    [Au]
Tl        111213322113                                 0.0830705   [Hg]
Pb        123222113                                    0.1082888   [Tl]
Bi        3113322113                                   0.1411629   [Pm, Pb]
Po        1113222113                                   0.1840167   [Bi]
At        1322113                                      0.23988     [Po]
Rn        311311222113                                 0.3127021   [Ho, At]
Fr        1113122113                                   0.4076313   [Rn]
Ra        132113                                       0.5313789   [Fr]
Ac        3113                                         0.6926935   [Ra]
Th        1113                                         0.7581905   [Ac]
Pa        13                                           0.9883599   [Th]
U         3                                            0.0102563   [Pa]
&gt;&gt;&gt; 
&gt;&gt;&gt; print(chem.get_char_poly())
lambda**18*(lambda - 1)**2*(lambda + 1)*(lambda**71 - lambda**69 - 2*lambda**68 - lambda**67 + 2*lambda**66 + 2*lambda**65 + lambda**64 - lambda**63 - lambda**62 - lambda**61 - lambda**60 - lambda**59 + 2*lambda**58 + 5*lambda**57 + 3*lambda**56 - 2*lambda**55 - 10*lambda**54 - 3*lambda**53 - 2*lambda**52 + 6*lambda**51 + 6*lambda**50 + lambda**49 + 9*lambda**48 - 3*lambda**47 - 7*lambda**46 - 8*lambda**45 - 8*lambda**44 + 10*lambda**43 + 6*lambda**42 + 8*lambda**41 - 5*lambda**40 - 12*lambda**39 + 7*lambda**38 - 7*lambda**37 + 7*lambda**36 + lambda**35 - 3*lambda**34 + 10*lambda**33 + lambda**32 - 6*lambda**31 - 2*lambda**30 - 10*lambda**29 - 3*lambda**28 + 2*lambda**27 + 9*lambda**26 - 3*lambda**25 + 14*lambda**24 - 8*lambda**23 - 7*lambda**21 + 9*lambda**20 + 3*lambda**19 - 4*lambda**18 - 10*lambda**17 - 7*lambda**16 + 12*lambda**15 + 7*lambda**14 + 2*lambda**13 - 12*lambda**12 - 4*lambda**11 - 2*lambda**10 + 5*lambda**9 + lambda**7 - 7*lambda**6 + 7*lambda**5 - 4*lambda**4 + 12*lambda**3 - 6*lambda**2 + 3*lambda - 6)
&gt;&gt;&gt; 
&gt;&gt;&gt; print(chem.get_max_eigenvalue())
1.3035772690342984

</code></pre>
<h2 id="example-session-conways-chemistry-with-transuranic-elements">Example Session: Conway's Chemistry with Transuranic Elements</h2>
<p>In the following example, the seeds used to generate elements
guarantee that a few transuranic elements will appear. Also, we print the
periodic table using Conway's convention that abundances are given in
atoms per million.</p>
<pre><code class="language-python">&gt;&gt;&gt; ls = LookAndSay()
&gt;&gt;&gt; chem = Chemistry(ls)
&gt;&gt;&gt; chem.generate_elements('11111', '78')
&gt;&gt;&gt; chem.print_periodic_table(abundance_sum = 10**6)
element   string                                       abundance       decay
H         22                                           91790.383216    [H]
He        13112221133211322112211213322112             3237.2968587    [Hf, Pa, H, Ca, Li]
Li        312211322212221121123222112                  4220.0665982    [He]
Be        111312211312113221133211322112211213322112   2263.8860324    [Ge, Ca, Li]
B         1321132122211322212221121123222112           2951.1503716    [Be]
C         3113112211322112211213322112                 3847.0525419    [B]
N         111312212221121123222112                     5014.9302464    [C]
O         132112211213322112                           6537.349075     [N]
F         31121123222112                               8521.9396539    [O]
Ne        111213322112                                 11109.0068209   [F]
Na        123222112                                    14481.4487733   [Ne]
Mg        3113322112                                   18850.4412275   [Pm, Na]
Al        1113222112                                   24573.0066954   [Mg]
Si        1322112                                      32032.81296     [Al]
P         311311222112                                 14895.8866582   [Ho, Si]
S         1113122112                                   19417.9392497   [P]
Cl        132112                                       25312.7842174   [S]
Ar        3112                                         32997.1701218   [Cl]
K         1112                                         43014.3609132   [Ar]
Ca        12                                           56072.5431285   [K]
Sc        3113112221133112                             9302.0974443    [Ho, Pa, H, Ca, Co]
Ti        11131221131112                               12126.0027828   [Sc]
V         13211312                                     15807.1815919   [Ti]
Cr        31132                                        20605.8826107   [V]
Mn        111311222112                                 26861.3601797   [Cr, Si]
Fe        13122112                                     35015.8585455   [Mn]
Co        32112                                        45645.8772557   [Fe]
Ni        11133112                                     13871.1241997   [Zn, Co]
Cu        131112                                       18082.0822027   [Ni]
Zn        312                                          23571.3913363   [Cu]
Ga        13221133122211332                            1447.8905642    [Eu, Ca, Ac, H, Ca, Zn]
Ge        31131122211311122113222                      1887.4372276    [Ho, Ga]
As        11131221131211322113322112                   27.2462161      [Ge, Na]
Se        13211321222113222112                         35.5175479      [As]
Br        3113112211322112                             46.2998682      [Se]
Kr        11131221222112                               60.3554557      [Br]
Rb        1321122112                                   78.6780001      [Kr]
Sr        3112112                                      102.5628525     [Rb]
Y         1112133                                      133.6986032     [Sr, U]
Zr        12322211331222113112211                      174.28646       [Y, H, Ca, Tc]
Nb        1113122113322113111221131221                 227.1958675     [Er, Zr]
Mo        13211322211312113211                         296.1673685     [Nb]
Tc        311322113212221                              386.0770494     [Mo]
Ru        132211331222113112211                        328.9948058     [Eu, Ca, Tc]
Rh        311311222113111221131221                     428.8701504     [Ho, Ru]
Pd        111312211312113211                           559.0653795     [Rh]
Ag        132113212221                                 728.7849206     [Pd]
Cd        3113112211                                   950.0274565     [Ag]
In        11131221                                     1238.4341972    [Cd]
Sn        13211                                        1614.3946687    [In]
Sb        3112221                                      2104.4881933    [Pm, Sn]
Te        1322113312211                                2743.3629717    [Eu, Ca, Sb]
I         311311222113111221                           3576.1856107    [Ho, Te]
Xe        11131221131211                               4661.8342719    [I]
Cs        13211321                                     6077.0611889    [Xe]
Ba        311311                                       7921.9188284    [Cs]
La        11131                                        10326.8333118   [Ba]
Ce        1321133112                                   13461.8251664   [La, H, Ca, Co]
Pr        31131112                                     17548.5292866   [Ce]
Nd        111312                                       22875.863883    [Pr]
Pm        132                                          29820.4561674   [Nd]
Sm        311332                                       15408.1151815   [Pm, Ca, Zn]
Eu        1113222                                      20085.6687093   [Sm]
Gd        13221133112                                  21662.9728211   [Eu, Ca, Co]
Tb        3113112221131112                             28239.3589492   [Ho, Gd]
Dy        111312211312                                 36812.1864183   [Tb]
Ho        1321132                                      47987.5294384   [Dy]
Er        311311222                                    1098.5955997    [Ho, Pm]
Tm        11131221133112                               1204.9083841    [Er, Ca, Co]
Yb        1321131112                                   1570.6911808    [Tm]
Lu        311312                                       2047.51732      [Yb]
Hf        11132                                        2669.0970363    [Lu]
Ta        13112221133211322112211213322113             242.0773667     [Hf, Pa, H, Ca, W]
W         312211322212221121123222113                  315.5665525     [Ta]
Re        111312211312113221133211322112211213322113   169.2880181     [Ge, Ca, W]
Os        1321132122211322212221121123222113           220.6800123     [Re]
Ir        3113112211322112211213322113                 287.6734477     [Os]
Pt        111312212221121123222113                     375.0045674     [Ir]
Au        132112211213322113                           488.8474298     [Pt]
Hg        31121123222113                               637.2503975     [Au]
Tl        111213322113                                 830.7051329     [Hg]
Pb        123222113                                    1082.8883286    [Tl]
Bi        3113322113                                   1411.62861      [Pm, Pb]
Po        1113222113                                   1840.1669683    [Bi]
At        1322113                                      2398.7998311    [Po]
Rn        311311222113                                 3127.0209328    [Ho, At]
Fr        1113122113                                   4076.3134078    [Rn]
Ra        132113                                       5313.7894999    [Fr]
Ac        3113                                         6926.9352045    [Ra]
Th        1113                                         7581.9047124    [Ac]
Pa        13                                           9883.5986391    [Th]
U         3                                            102.5628525     [Pa]
Np5       13112221133211322112211213322115             0.0             [Hf, Pa, H, Ca, Pu5]
Np7       13112221133211322112211213322117             0.0             [Hf, Pa, H, Ca, Pu7]
Np8       13112221133211322112211213322118             0.0             [Hf, Pa, H, Ca, Pu8]
Pu5       312211322212221121123222115                  0.0             [Np5]
Pu7       312211322212221121123222117                  0.0             [Np7]
Pu8       312211322212221121123222118                  0.0             [Np8]

</code></pre>
<h2 id="example-session-standard-ternary">Example Session: Standard Ternary</h2>
<pre><code class="language-python">&gt;&gt;&gt; # Define the say function:
... def ternary(num):
...     if num &lt; 3:
...         return str(num)
...     return ternary(num // 3) + str(num % 3)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; # Use the Split Function Factory to create a split function:
... sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_after('0')
&gt;&gt;&gt; sff.declare_splitting_pairs(('2', '1110'), ('2', '10'))
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Instantiate the LookAndSay and Chemistry objects:
... ternary_ls = LookAndSay(ternary)
&gt;&gt;&gt; ternary_chem = Chemistry(ternary_ls, split)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Generate elements and order them according to relative abundances:
... ternary_chem.generate_elements('0', '1', '2')
&gt;&gt;&gt; ternary_chem.order_elements('abundance')
&gt;&gt;&gt; 
&gt;&gt;&gt; # Print chemical properties:
... ternary_chem.print_periodic_table()
element   string     abundance    decay
E1        10         18.5037375   [E4]
E2        22110      13.9680582   [E5]
E3        2110       13.9680582   [E6]
E4        1110       13.9680582   [E1, E7]
E5        222110     10.5441752   [E1, E2]
E6        122110     10.5441752   [E8]
E7        110        10.5441752   [E3]
E8        11222110   7.9595623    [E3, E2]
E9        222112     0.0          [E1, E10]
E10       22112      0.0          [E9]
E11       212221     0.0          [E16, E4, E13]
E12       2112       0.0          [E14]
E13       211        0.0          [E15]
E14       122112     0.0          [E17]
E15       1221       0.0          [E18]
E16       12         0.0          [E20]
E17       11222112   0.0          [E3, E10]
E18       112211     0.0          [E11]
E19       112        0.0          [E12]
E20       1112       0.0          [E1, E19]
&gt;&gt;&gt; 
&gt;&gt;&gt; print(ternary_chem.get_char_poly())
lambda**6*(lambda - 1)**2*(lambda + 1)**2*(lambda**2 + 1)*(lambda**3 - lambda - 1)*(lambda**5 - lambda**3 + 1)
&gt;&gt;&gt; 
&gt;&gt;&gt; print(ternary_chem.get_max_eigenvalue())
1.3247179572447458

</code></pre>
<h2 id="example-session-balanced-ternary">Example Session: Balanced Ternary</h2>
<p>In this example we find the chemical properties of a <a href="https://en.wikipedia.org/wiki/Balanced_ternary">balanced ternary</a>
look and say sequence. </p>
<pre><code class="language-python">&gt;&gt;&gt; # Define a (partial) say function to convert integers to balanced ternary:
... def bal_tern(num):
...     assert num &lt; 11, &quot;bal_tern will only convert integers from 1 to 10.&quot;
...     repn = {1:'1', 2:'1T', 3:'10', 4:'11', 5:'1TT', 6:'1T0', 7:'1T1', 8:'10T', 9:'100', 10:'101'}
...     return repn[num]
... 
&gt;&gt;&gt; # Use the split function factory to generate an appropriate split function: 
... sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_after('0', 'T')
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Instantiate the look and say and chemistry objects:
... bal_tern_ls = LookAndSay(bal_tern)
&gt;&gt;&gt; bal_tern_chem = Chemistry(bal_tern_ls, split)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Generate persistent elements from the seed '0', and order them according to their relative abundance:
... bal_tern_chem.generate_elements('0')
&gt;&gt;&gt; bal_tern_chem.order_elements('abundance')
&gt;&gt;&gt; 
&gt;&gt;&gt; # Print the chemical properties
... bal_tern_chem.print_periodic_table()
element   string   abundance    decay
E1        1T       23.6067977   [E3]
E2        11T      23.6067977   [E1, E2]
E3        111T     14.5898034   [E5, E2]
E4        110      14.5898034   [E1, E4]
E5        10       14.5898034   [E6]
E6        1110     9.0169944    [E5, E4]
&gt;&gt;&gt; 
&gt;&gt;&gt; print(bal_tern_chem.get_char_poly())
lambda**3*(lambda - 1)*(lambda**2 - lambda - 1)
&gt;&gt;&gt; 
&gt;&gt;&gt; print(bal_tern_chem.get_max_eigenvalue()) # golden!
1.6180339887498945

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chemistry():
    &#34;&#34;&#34;
    A class responsible for generating all the persistent elements 
    appearing in look and say sequences, along with 
    the chemical properties of those elements.

    Parameters in the constructor are a LookAndSay object ``las`` and
    a splitting function ``split``. The user is responsible
    for verifying that the provided splitting function is valid for the given
    LookAndSay object. The default splitting function corresponds to 
    Conway&#39;s original Splitting Theorem.

    ## Example Session: Conway&#39;s Constant and his 92 Common Elements

    ```python
    &gt;&gt;&gt; ls = LookAndSay()
    &gt;&gt;&gt; chem = Chemistry(ls)
    &gt;&gt;&gt; chem.generate_elements(&#39;1&#39;)
    &gt;&gt;&gt; chem.print_periodic_table() 
    element   string                                       abundance   decay
    H         22                                           9.1790383   [H]
    He        13112221133211322112211213322112             0.3237297   [Hf, Pa, H, Ca, Li]
    Li        312211322212221121123222112                  0.4220067   [He]
    Be        111312211312113221133211322112211213322112   0.2263886   [Ge, Ca, Li]
    B         1321132122211322212221121123222112           0.295115    [Be]
    C         3113112211322112211213322112                 0.3847053   [B]
    N         111312212221121123222112                     0.501493    [C]
    O         132112211213322112                           0.6537349   [N]
    F         31121123222112                               0.852194    [O]
    Ne        111213322112                                 1.1109007   [F]
    Na        123222112                                    1.4481449   [Ne]
    Mg        3113322112                                   1.8850441   [Pm, Na]
    Al        1113222112                                   2.4573007   [Mg]
    Si        1322112                                      3.2032813   [Al]
    P         311311222112                                 1.4895887   [Ho, Si]
    S         1113122112                                   1.9417939   [P]
    Cl        132112                                       2.5312784   [S]
    Ar        3112                                         3.299717    [Cl]
    K         1112                                         4.3014361   [Ar]
    Ca        12                                           5.6072543   [K]
    Sc        3113112221133112                             0.9302097   [Ho, Pa, H, Ca, Co]
    Ti        11131221131112                               1.2126003   [Sc]
    V         13211312                                     1.5807182   [Ti]
    Cr        31132                                        2.0605883   [V]
    Mn        111311222112                                 2.686136    [Cr, Si]
    Fe        13122112                                     3.5015859   [Mn]
    Co        32112                                        4.5645877   [Fe]
    Ni        11133112                                     1.3871124   [Zn, Co]
    Cu        131112                                       1.8082082   [Ni]
    Zn        312                                          2.3571391   [Cu]
    Ga        13221133122211332                            0.1447891   [Eu, Ca, Ac, H, Ca, Zn]
    Ge        31131122211311122113222                      0.1887437   [Ho, Ga]
    As        11131221131211322113322112                   0.0027246   [Ge, Na]
    Se        13211321222113222112                         0.0035518   [As]
    Br        3113112211322112                             0.00463     [Se]
    Kr        11131221222112                               0.0060355   [Br]
    Rb        1321122112                                   0.0078678   [Kr]
    Sr        3112112                                      0.0102563   [Rb]
    Y         1112133                                      0.0133699   [Sr, U]
    Zr        12322211331222113112211                      0.0174286   [Y, H, Ca, Tc]
    Nb        1113122113322113111221131221                 0.0227196   [Er, Zr]
    Mo        13211322211312113211                         0.0296167   [Nb]
    Tc        311322113212221                              0.0386077   [Mo]
    Ru        132211331222113112211                        0.0328995   [Eu, Ca, Tc]
    Rh        311311222113111221131221                     0.042887    [Ho, Ru]
    Pd        111312211312113211                           0.0559065   [Rh]
    Ag        132113212221                                 0.0728785   [Pd]
    Cd        3113112211                                   0.0950027   [Ag]
    In        11131221                                     0.1238434   [Cd]
    Sn        13211                                        0.1614395   [In]
    Sb        3112221                                      0.2104488   [Pm, Sn]
    Te        1322113312211                                0.2743363   [Eu, Ca, Sb]
    I         311311222113111221                           0.3576186   [Ho, Te]
    Xe        11131221131211                               0.4661834   [I]
    Cs        13211321                                     0.6077061   [Xe]
    Ba        311311                                       0.7921919   [Cs]
    La        11131                                        1.0326833   [Ba]
    Ce        1321133112                                   1.3461825   [La, H, Ca, Co]
    Pr        31131112                                     1.7548529   [Ce]
    Nd        111312                                       2.2875864   [Pr]
    Pm        132                                          2.9820456   [Nd]
    Sm        311332                                       1.5408115   [Pm, Ca, Zn]
    Eu        1113222                                      2.0085669   [Sm]
    Gd        13221133112                                  2.1662973   [Eu, Ca, Co]
    Tb        3113112221131112                             2.8239359   [Ho, Gd]
    Dy        111312211312                                 3.6812186   [Tb]
    Ho        1321132                                      4.7987529   [Dy]
    Er        311311222                                    0.1098596   [Ho, Pm]
    Tm        11131221133112                               0.1204908   [Er, Ca, Co]
    Yb        1321131112                                   0.1570691   [Tm]
    Lu        311312                                       0.2047517   [Yb]
    Hf        11132                                        0.2669097   [Lu]
    Ta        13112221133211322112211213322113             0.0242077   [Hf, Pa, H, Ca, W]
    W         312211322212221121123222113                  0.0315567   [Ta]
    Re        111312211312113221133211322112211213322113   0.0169288   [Ge, Ca, W]
    Os        1321132122211322212221121123222113           0.022068    [Re]
    Ir        3113112211322112211213322113                 0.0287673   [Os]
    Pt        111312212221121123222113                     0.0375005   [Ir]
    Au        132112211213322113                           0.0488847   [Pt]
    Hg        31121123222113                               0.063725    [Au]
    Tl        111213322113                                 0.0830705   [Hg]
    Pb        123222113                                    0.1082888   [Tl]
    Bi        3113322113                                   0.1411629   [Pm, Pb]
    Po        1113222113                                   0.1840167   [Bi]
    At        1322113                                      0.23988     [Po]
    Rn        311311222113                                 0.3127021   [Ho, At]
    Fr        1113122113                                   0.4076313   [Rn]
    Ra        132113                                       0.5313789   [Fr]
    Ac        3113                                         0.6926935   [Ra]
    Th        1113                                         0.7581905   [Ac]
    Pa        13                                           0.9883599   [Th]
    U         3                                            0.0102563   [Pa]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(chem.get_char_poly())
    lambda**18*(lambda - 1)**2*(lambda + 1)*(lambda**71 - lambda**69 - 2*lambda**68 - lambda**67 + 2*lambda**66 + 2*lambda**65 + lambda**64 - lambda**63 - lambda**62 - lambda**61 - lambda**60 - lambda**59 + 2*lambda**58 + 5*lambda**57 + 3*lambda**56 - 2*lambda**55 - 10*lambda**54 - 3*lambda**53 - 2*lambda**52 + 6*lambda**51 + 6*lambda**50 + lambda**49 + 9*lambda**48 - 3*lambda**47 - 7*lambda**46 - 8*lambda**45 - 8*lambda**44 + 10*lambda**43 + 6*lambda**42 + 8*lambda**41 - 5*lambda**40 - 12*lambda**39 + 7*lambda**38 - 7*lambda**37 + 7*lambda**36 + lambda**35 - 3*lambda**34 + 10*lambda**33 + lambda**32 - 6*lambda**31 - 2*lambda**30 - 10*lambda**29 - 3*lambda**28 + 2*lambda**27 + 9*lambda**26 - 3*lambda**25 + 14*lambda**24 - 8*lambda**23 - 7*lambda**21 + 9*lambda**20 + 3*lambda**19 - 4*lambda**18 - 10*lambda**17 - 7*lambda**16 + 12*lambda**15 + 7*lambda**14 + 2*lambda**13 - 12*lambda**12 - 4*lambda**11 - 2*lambda**10 + 5*lambda**9 + lambda**7 - 7*lambda**6 + 7*lambda**5 - 4*lambda**4 + 12*lambda**3 - 6*lambda**2 + 3*lambda - 6)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(chem.get_max_eigenvalue())
    1.3035772690342984
   
    ```

    ## Example Session: Conway&#39;s Chemistry with Transuranic Elements
    In the following example, the seeds used to generate elements 
    guarantee that a few transuranic elements will appear. Also, we print the 
    periodic table using Conway&#39;s convention that abundances are given in 
    atoms per million.

    ```python
    &gt;&gt;&gt; ls = LookAndSay()
    &gt;&gt;&gt; chem = Chemistry(ls)
    &gt;&gt;&gt; chem.generate_elements(&#39;11111&#39;, &#39;78&#39;)
    &gt;&gt;&gt; chem.print_periodic_table(abundance_sum = 10**6)
    element   string                                       abundance       decay
    H         22                                           91790.383216    [H]
    He        13112221133211322112211213322112             3237.2968587    [Hf, Pa, H, Ca, Li]
    Li        312211322212221121123222112                  4220.0665982    [He]
    Be        111312211312113221133211322112211213322112   2263.8860324    [Ge, Ca, Li]
    B         1321132122211322212221121123222112           2951.1503716    [Be]
    C         3113112211322112211213322112                 3847.0525419    [B]
    N         111312212221121123222112                     5014.9302464    [C]
    O         132112211213322112                           6537.349075     [N]
    F         31121123222112                               8521.9396539    [O]
    Ne        111213322112                                 11109.0068209   [F]
    Na        123222112                                    14481.4487733   [Ne]
    Mg        3113322112                                   18850.4412275   [Pm, Na]
    Al        1113222112                                   24573.0066954   [Mg]
    Si        1322112                                      32032.81296     [Al]
    P         311311222112                                 14895.8866582   [Ho, Si]
    S         1113122112                                   19417.9392497   [P]
    Cl        132112                                       25312.7842174   [S]
    Ar        3112                                         32997.1701218   [Cl]
    K         1112                                         43014.3609132   [Ar]
    Ca        12                                           56072.5431285   [K]
    Sc        3113112221133112                             9302.0974443    [Ho, Pa, H, Ca, Co]
    Ti        11131221131112                               12126.0027828   [Sc]
    V         13211312                                     15807.1815919   [Ti]
    Cr        31132                                        20605.8826107   [V]
    Mn        111311222112                                 26861.3601797   [Cr, Si]
    Fe        13122112                                     35015.8585455   [Mn]
    Co        32112                                        45645.8772557   [Fe]
    Ni        11133112                                     13871.1241997   [Zn, Co]
    Cu        131112                                       18082.0822027   [Ni]
    Zn        312                                          23571.3913363   [Cu]
    Ga        13221133122211332                            1447.8905642    [Eu, Ca, Ac, H, Ca, Zn]
    Ge        31131122211311122113222                      1887.4372276    [Ho, Ga]
    As        11131221131211322113322112                   27.2462161      [Ge, Na]
    Se        13211321222113222112                         35.5175479      [As]
    Br        3113112211322112                             46.2998682      [Se]
    Kr        11131221222112                               60.3554557      [Br]
    Rb        1321122112                                   78.6780001      [Kr]
    Sr        3112112                                      102.5628525     [Rb]
    Y         1112133                                      133.6986032     [Sr, U]
    Zr        12322211331222113112211                      174.28646       [Y, H, Ca, Tc]
    Nb        1113122113322113111221131221                 227.1958675     [Er, Zr]
    Mo        13211322211312113211                         296.1673685     [Nb]
    Tc        311322113212221                              386.0770494     [Mo]
    Ru        132211331222113112211                        328.9948058     [Eu, Ca, Tc]
    Rh        311311222113111221131221                     428.8701504     [Ho, Ru]
    Pd        111312211312113211                           559.0653795     [Rh]
    Ag        132113212221                                 728.7849206     [Pd]
    Cd        3113112211                                   950.0274565     [Ag]
    In        11131221                                     1238.4341972    [Cd]
    Sn        13211                                        1614.3946687    [In]
    Sb        3112221                                      2104.4881933    [Pm, Sn]
    Te        1322113312211                                2743.3629717    [Eu, Ca, Sb]
    I         311311222113111221                           3576.1856107    [Ho, Te]
    Xe        11131221131211                               4661.8342719    [I]
    Cs        13211321                                     6077.0611889    [Xe]
    Ba        311311                                       7921.9188284    [Cs]
    La        11131                                        10326.8333118   [Ba]
    Ce        1321133112                                   13461.8251664   [La, H, Ca, Co]
    Pr        31131112                                     17548.5292866   [Ce]
    Nd        111312                                       22875.863883    [Pr]
    Pm        132                                          29820.4561674   [Nd]
    Sm        311332                                       15408.1151815   [Pm, Ca, Zn]
    Eu        1113222                                      20085.6687093   [Sm]
    Gd        13221133112                                  21662.9728211   [Eu, Ca, Co]
    Tb        3113112221131112                             28239.3589492   [Ho, Gd]
    Dy        111312211312                                 36812.1864183   [Tb]
    Ho        1321132                                      47987.5294384   [Dy]
    Er        311311222                                    1098.5955997    [Ho, Pm]
    Tm        11131221133112                               1204.9083841    [Er, Ca, Co]
    Yb        1321131112                                   1570.6911808    [Tm]
    Lu        311312                                       2047.51732      [Yb]
    Hf        11132                                        2669.0970363    [Lu]
    Ta        13112221133211322112211213322113             242.0773667     [Hf, Pa, H, Ca, W]
    W         312211322212221121123222113                  315.5665525     [Ta]
    Re        111312211312113221133211322112211213322113   169.2880181     [Ge, Ca, W]
    Os        1321132122211322212221121123222113           220.6800123     [Re]
    Ir        3113112211322112211213322113                 287.6734477     [Os]
    Pt        111312212221121123222113                     375.0045674     [Ir]
    Au        132112211213322113                           488.8474298     [Pt]
    Hg        31121123222113                               637.2503975     [Au]
    Tl        111213322113                                 830.7051329     [Hg]
    Pb        123222113                                    1082.8883286    [Tl]
    Bi        3113322113                                   1411.62861      [Pm, Pb]
    Po        1113222113                                   1840.1669683    [Bi]
    At        1322113                                      2398.7998311    [Po]
    Rn        311311222113                                 3127.0209328    [Ho, At]
    Fr        1113122113                                   4076.3134078    [Rn]
    Ra        132113                                       5313.7894999    [Fr]
    Ac        3113                                         6926.9352045    [Ra]
    Th        1113                                         7581.9047124    [Ac]
    Pa        13                                           9883.5986391    [Th]
    U         3                                            102.5628525     [Pa]
    Np5       13112221133211322112211213322115             0.0             [Hf, Pa, H, Ca, Pu5]
    Np7       13112221133211322112211213322117             0.0             [Hf, Pa, H, Ca, Pu7]
    Np8       13112221133211322112211213322118             0.0             [Hf, Pa, H, Ca, Pu8]
    Pu5       312211322212221121123222115                  0.0             [Np5]
    Pu7       312211322212221121123222117                  0.0             [Np7]
    Pu8       312211322212221121123222118                  0.0             [Np8]
 
    ```

    ## Example Session: Standard Ternary

    ```python
    &gt;&gt;&gt; # Define the say function:
    ... def ternary(num):
    ...     if num &lt; 3:
    ...         return str(num)
    ...     return ternary(num // 3) + str(num % 3)
    ... 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Use the Split Function Factory to create a split function:
    ... sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;0&#39;)
    &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;2&#39;, &#39;1110&#39;), (&#39;2&#39;, &#39;10&#39;))
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Instantiate the LookAndSay and Chemistry objects:
    ... ternary_ls = LookAndSay(ternary)
    &gt;&gt;&gt; ternary_chem = Chemistry(ternary_ls, split)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Generate elements and order them according to relative abundances:
    ... ternary_chem.generate_elements(&#39;0&#39;, &#39;1&#39;, &#39;2&#39;)
    &gt;&gt;&gt; ternary_chem.order_elements(&#39;abundance&#39;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Print chemical properties:
    ... ternary_chem.print_periodic_table()
    element   string     abundance    decay
    E1        10         18.5037375   [E4]
    E2        22110      13.9680582   [E5]
    E3        2110       13.9680582   [E6]
    E4        1110       13.9680582   [E1, E7]
    E5        222110     10.5441752   [E1, E2]
    E6        122110     10.5441752   [E8]
    E7        110        10.5441752   [E3]
    E8        11222110   7.9595623    [E3, E2]
    E9        222112     0.0          [E1, E10]
    E10       22112      0.0          [E9]
    E11       212221     0.0          [E16, E4, E13]
    E12       2112       0.0          [E14]
    E13       211        0.0          [E15]
    E14       122112     0.0          [E17]
    E15       1221       0.0          [E18]
    E16       12         0.0          [E20]
    E17       11222112   0.0          [E3, E10]
    E18       112211     0.0          [E11]
    E19       112        0.0          [E12]
    E20       1112       0.0          [E1, E19]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(ternary_chem.get_char_poly())
    lambda**6*(lambda - 1)**2*(lambda + 1)**2*(lambda**2 + 1)*(lambda**3 - lambda - 1)*(lambda**5 - lambda**3 + 1)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(ternary_chem.get_max_eigenvalue())
    1.3247179572447458

    ```

    
    ## Example Session: Balanced Ternary
    In this example we find the chemical properties of a [balanced ternary](https://en.wikipedia.org/wiki/Balanced_ternary)
    look and say sequence. 

    ```python
    &gt;&gt;&gt; # Define a (partial) say function to convert integers to balanced ternary:
    ... def bal_tern(num):
    ...     assert num &lt; 11, &#34;bal_tern will only convert integers from 1 to 10.&#34;
    ...     repn = {1:&#39;1&#39;, 2:&#39;1T&#39;, 3:&#39;10&#39;, 4:&#39;11&#39;, 5:&#39;1TT&#39;, 6:&#39;1T0&#39;, 7:&#39;1T1&#39;, 8:&#39;10T&#39;, 9:&#39;100&#39;, 10:&#39;101&#39;}
    ...     return repn[num]
    ... 
    &gt;&gt;&gt; # Use the split function factory to generate an appropriate split function: 
    ... sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;0&#39;, &#39;T&#39;)
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Instantiate the look and say and chemistry objects:
    ... bal_tern_ls = LookAndSay(bal_tern)
    &gt;&gt;&gt; bal_tern_chem = Chemistry(bal_tern_ls, split)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Generate persistent elements from the seed &#39;0&#39;, and order them according to their relative abundance:
    ... bal_tern_chem.generate_elements(&#39;0&#39;)
    &gt;&gt;&gt; bal_tern_chem.order_elements(&#39;abundance&#39;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Print the chemical properties
    ... bal_tern_chem.print_periodic_table()
    element   string   abundance    decay
    E1        1T       23.6067977   [E3]
    E2        11T      23.6067977   [E1, E2]
    E3        111T     14.5898034   [E5, E2]
    E4        110      14.5898034   [E1, E4]
    E5        10       14.5898034   [E6]
    E6        1110     9.0169944    [E5, E4]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(bal_tern_chem.get_char_poly())
    lambda**3*(lambda - 1)*(lambda**2 - lambda - 1)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(bal_tern_chem.get_max_eigenvalue()) # golden!
    1.6180339887498945

    ```
    &#34;&#34;&#34;
    def __init__(self, las, split = split_Conway, elements = None):
        super(Chemistry, self).__init__()
        self.las = las
        self.split = split
        if elements == None:
            elements = []
        self.elements = elements

    def get_elements(self):
        &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
        return self.elements

    def clear_elements(self):
        &#34;&#34;&#34;Resets the list of elements back to the empty list.&#34;&#34;&#34;
        self.elements = []

    def _split_to_elements(self, string): 
        return [Element(chunk, self.las) for chunk in self.split(string)]

    def _generate_all_elements(self, strings):
        for string in strings:
            for elt in self._split_to_elements(string):
                if elt not in self.elements:
                    # add elt to the chemistry:
                    self.elements.append(elt)
                    # recursively set the decay for elt:
                    decay_elts = self._split_to_elements(self.las.say_what_you_see(elt.get_string()))
                    self._generate_all_elements(map(lambda e : e.get_string(), decay_elts))
                    elt._set_decay(decay_elts)
        # clean up decay for all elements:
        for elt in self.elements:
            dec = []
            for d in elt.get_decay():
                dec += [e for e in self.elements if e == d]
            elt._set_decay(dec)

    def _remove_intermittent_elements(self): 
        while True:
            common_elements = []
            for elt in self.elements:
                for d in elt.get_decay():
                    if d not in common_elements:
                        common_elements.append(d)
            if len(common_elements) &lt; len(self.elements):
                self.elements = list(common_elements)
            else: 
                break

    def generate_elements(self, *seeds, reset = True):
        &#34;&#34;&#34;
        Collects all the persistent elements from all the look and
        say sequences generated by the given seeds. The string(s) entered as the 
        parameter(s) will be used as the seed(s) for generating the elements. 
        By default, this method will clear any elements in the chemistry that exist 
        before this method is called (i.e. prior to collecting from the new seeds). 
        Use ``reset = False``  to keep the old elements. 
        &#34;&#34;&#34;
        if reset:
            self.clear_elements()
        strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
        self._generate_all_elements(strings)
        self._remove_intermittent_elements()
        self.order_elements(&#39;string&#39;)
        self._name_elements()

    def _name_elements(self):
        if self.las._is_Conway:
            for e in self.get_elements():
                e.set_name(_conway_name(e))
            self.elements = sorted(self.get_elements(), key = _conway_number)
        else:
            for i, e in enumerate(self.get_elements()):
                e.set_name(&#39;E&#39; + str(i + 1))

    def get_decay_matrix(self):
        &#34;&#34;&#34;
        Returns the decay matrix as a nested list of integers 
        (i.e. a list of the rows).
        The order of the columns and rows correspond to the order
        in the list of elements.
        &#34;&#34;&#34;
        mat = []
        e = self.elements
        for i in range(len(e)):
            row = []
            for j in range(len(e)):
                row.append(e[j].get_decay().count(e[i]))
            mat.append(row)
        return mat

    def get_max_eigenvalue(self):
        &#34;&#34;&#34;
        Returns the maximal real eigenvalue of the decay matrix.
        In the standard case, this will give Conway&#39;s constant. 
        In general, this will give the growth rate of the look and say sequence. 
        This method assumes the existence of a real eigenvalue which
        is larger than (the absolute value) of every other eigenvalue.
        This assumption is usually guaranteed by the Perron-Frobenius Theorem.
        &#34;&#34;&#34;
        assert len(self.elements) &gt; 0, &#34;The get_max_eigenvalue method requires a nonempty list of elements.\n\tTo fix: Use the generate_elements method prior to calling get_max_eigenvalue.&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        return max(eigenvalues).real

    def get_char_poly(self, factor = True, latex = False):
        &#34;&#34;&#34;
        Returns the characteristic polynomial of the decay matrix using sympy.
        By default the returned polynomial will be factored. 
        Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
        Use ``latex = True`` to return the polynomial formatted in latex.
        &#34;&#34;&#34;
        chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
        if factor:
            chi = sympy.factor(chi.as_expr())
        else:
            chi = chi.as_expr()
        if latex:
            return sympy.latex(chi)
        else:
            return chi

    def _get_abundances(self, dec_places = 7, abundance_sum = 100):
        &#34;&#34;&#34;
        Returns a list of relative abundances of each element.
        By default the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The abundances can be renormalized by setting the parameter ``abundance_sum``.
        The order of the list corresponds to the order of the list of elements.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        eigenvectors = eigenstuff[1]
        index = numpy.where(eigenvalues == max(eigenvalues))
        limiting_eigenvector_nparray = eigenvectors[:,index].real
        # The next two lines are converting the numpy array to a list
        limiting_eigenvector = limiting_eigenvector_nparray.tolist()
        limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
        abundance = [abs(round(abundance_sum * num / sum(limiting_eigenvector), dec_places)) for num in limiting_eigenvector]
        return abundance

    def get_periodic_table(self, dec_places = 7, abundance_sum = 100):
        &#34;&#34;&#34;
        Creates a periodic table including each element&#39;s name, string, relative abundance, and decay.
        Returns the periodic table as a nested dictionary.

        ## Example Session:
        ```python
        &gt;&gt;&gt; ls = LookAndSay()
        &gt;&gt;&gt; chem = Chemistry(ls)
        &gt;&gt;&gt; chem.generate_elements(&#39;4&#39;)
        &gt;&gt;&gt; print(chem.get_periodic_table())
        {&#39;H&#39;: {&#39;string&#39;: &#39;22&#39;, &#39;abundance&#39;: 9.1790383, &#39;decay&#39;: [H]}, &#39;He&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322112&#39;, &#39;abundance&#39;: 0.3237297, &#39;decay&#39;: [Hf, Pa, H, Ca, Li]}, &#39;Li&#39;: {&#39;string&#39;: &#39;312211322212221121123222112&#39;, &#39;abundance&#39;: 0.4220067, &#39;decay&#39;: [He]}, &#39;Be&#39;: {&#39;string&#39;: &#39;111312211312113221133211322112211213322112&#39;, &#39;abundance&#39;: 0.2263886, &#39;decay&#39;: [Ge, Ca, Li]}, &#39;B&#39;: {&#39;string&#39;: &#39;1321132122211322212221121123222112&#39;, &#39;abundance&#39;: 0.295115, &#39;decay&#39;: [Be]}, &#39;C&#39;: {&#39;string&#39;: &#39;3113112211322112211213322112&#39;, &#39;abundance&#39;: 0.3847053, &#39;decay&#39;: [B]}, &#39;N&#39;: {&#39;string&#39;: &#39;111312212221121123222112&#39;, &#39;abundance&#39;: 0.501493, &#39;decay&#39;: [C]}, &#39;O&#39;: {&#39;string&#39;: &#39;132112211213322112&#39;, &#39;abundance&#39;: 0.6537349, &#39;decay&#39;: [N]}, &#39;F&#39;: {&#39;string&#39;: &#39;31121123222112&#39;, &#39;abundance&#39;: 0.852194, &#39;decay&#39;: [O]}, &#39;Ne&#39;: {&#39;string&#39;: &#39;111213322112&#39;, &#39;abundance&#39;: 1.1109007, &#39;decay&#39;: [F]}, &#39;Na&#39;: {&#39;string&#39;: &#39;123222112&#39;, &#39;abundance&#39;: 1.4481449, &#39;decay&#39;: [Ne]}, &#39;Mg&#39;: {&#39;string&#39;: &#39;3113322112&#39;, &#39;abundance&#39;: 1.8850441, &#39;decay&#39;: [Pm, Na]}, &#39;Al&#39;: {&#39;string&#39;: &#39;1113222112&#39;, &#39;abundance&#39;: 2.4573007, &#39;decay&#39;: [Mg]}, &#39;Si&#39;: {&#39;string&#39;: &#39;1322112&#39;, &#39;abundance&#39;: 3.2032813, &#39;decay&#39;: [Al]}, &#39;P&#39;: {&#39;string&#39;: &#39;311311222112&#39;, &#39;abundance&#39;: 1.4895887, &#39;decay&#39;: [Ho, Si]}, &#39;S&#39;: {&#39;string&#39;: &#39;1113122112&#39;, &#39;abundance&#39;: 1.9417939, &#39;decay&#39;: [P]}, &#39;Cl&#39;: {&#39;string&#39;: &#39;132112&#39;, &#39;abundance&#39;: 2.5312784, &#39;decay&#39;: [S]}, &#39;Ar&#39;: {&#39;string&#39;: &#39;3112&#39;, &#39;abundance&#39;: 3.299717, &#39;decay&#39;: [Cl]}, &#39;K&#39;: {&#39;string&#39;: &#39;1112&#39;, &#39;abundance&#39;: 4.3014361, &#39;decay&#39;: [Ar]}, &#39;Ca&#39;: {&#39;string&#39;: &#39;12&#39;, &#39;abundance&#39;: 5.6072543, &#39;decay&#39;: [K]}, &#39;Sc&#39;: {&#39;string&#39;: &#39;3113112221133112&#39;, &#39;abundance&#39;: 0.9302097, &#39;decay&#39;: [Ho, Pa, H, Ca, Co]}, &#39;Ti&#39;: {&#39;string&#39;: &#39;11131221131112&#39;, &#39;abundance&#39;: 1.2126003, &#39;decay&#39;: [Sc]}, &#39;V&#39;: {&#39;string&#39;: &#39;13211312&#39;, &#39;abundance&#39;: 1.5807182, &#39;decay&#39;: [Ti]}, &#39;Cr&#39;: {&#39;string&#39;: &#39;31132&#39;, &#39;abundance&#39;: 2.0605883, &#39;decay&#39;: [V]}, &#39;Mn&#39;: {&#39;string&#39;: &#39;111311222112&#39;, &#39;abundance&#39;: 2.686136, &#39;decay&#39;: [Cr, Si]}, &#39;Fe&#39;: {&#39;string&#39;: &#39;13122112&#39;, &#39;abundance&#39;: 3.5015859, &#39;decay&#39;: [Mn]}, &#39;Co&#39;: {&#39;string&#39;: &#39;32112&#39;, &#39;abundance&#39;: 4.5645877, &#39;decay&#39;: [Fe]}, &#39;Ni&#39;: {&#39;string&#39;: &#39;11133112&#39;, &#39;abundance&#39;: 1.3871124, &#39;decay&#39;: [Zn, Co]}, &#39;Cu&#39;: {&#39;string&#39;: &#39;131112&#39;, &#39;abundance&#39;: 1.8082082, &#39;decay&#39;: [Ni]}, &#39;Zn&#39;: {&#39;string&#39;: &#39;312&#39;, &#39;abundance&#39;: 2.3571391, &#39;decay&#39;: [Cu]}, &#39;Ga&#39;: {&#39;string&#39;: &#39;13221133122211332&#39;, &#39;abundance&#39;: 0.1447891, &#39;decay&#39;: [Eu, Ca, Ac, H, Ca, Zn]}, &#39;Ge&#39;: {&#39;string&#39;: &#39;31131122211311122113222&#39;, &#39;abundance&#39;: 0.1887437, &#39;decay&#39;: [Ho, Ga]}, &#39;As&#39;: {&#39;string&#39;: &#39;11131221131211322113322112&#39;, &#39;abundance&#39;: 0.0027246, &#39;decay&#39;: [Ge, Na]}, &#39;Se&#39;: {&#39;string&#39;: &#39;13211321222113222112&#39;, &#39;abundance&#39;: 0.0035518, &#39;decay&#39;: [As]}, &#39;Br&#39;: {&#39;string&#39;: &#39;3113112211322112&#39;, &#39;abundance&#39;: 0.00463, &#39;decay&#39;: [Se]}, &#39;Kr&#39;: {&#39;string&#39;: &#39;11131221222112&#39;, &#39;abundance&#39;: 0.0060355, &#39;decay&#39;: [Br]}, &#39;Rb&#39;: {&#39;string&#39;: &#39;1321122112&#39;, &#39;abundance&#39;: 0.0078678, &#39;decay&#39;: [Kr]}, &#39;Sr&#39;: {&#39;string&#39;: &#39;3112112&#39;, &#39;abundance&#39;: 0.0102563, &#39;decay&#39;: [Rb]}, &#39;Y&#39;: {&#39;string&#39;: &#39;1112133&#39;, &#39;abundance&#39;: 0.0133699, &#39;decay&#39;: [Sr, U]}, &#39;Zr&#39;: {&#39;string&#39;: &#39;12322211331222113112211&#39;, &#39;abundance&#39;: 0.0174286, &#39;decay&#39;: [Y, H, Ca, Tc]}, &#39;Nb&#39;: {&#39;string&#39;: &#39;1113122113322113111221131221&#39;, &#39;abundance&#39;: 0.0227196, &#39;decay&#39;: [Er, Zr]}, &#39;Mo&#39;: {&#39;string&#39;: &#39;13211322211312113211&#39;, &#39;abundance&#39;: 0.0296167, &#39;decay&#39;: [Nb]}, &#39;Tc&#39;: {&#39;string&#39;: &#39;311322113212221&#39;, &#39;abundance&#39;: 0.0386077, &#39;decay&#39;: [Mo]}, &#39;Ru&#39;: {&#39;string&#39;: &#39;132211331222113112211&#39;, &#39;abundance&#39;: 0.0328995, &#39;decay&#39;: [Eu, Ca, Tc]}, &#39;Rh&#39;: {&#39;string&#39;: &#39;311311222113111221131221&#39;, &#39;abundance&#39;: 0.042887, &#39;decay&#39;: [Ho, Ru]}, &#39;Pd&#39;: {&#39;string&#39;: &#39;111312211312113211&#39;, &#39;abundance&#39;: 0.0559065, &#39;decay&#39;: [Rh]}, &#39;Ag&#39;: {&#39;string&#39;: &#39;132113212221&#39;, &#39;abundance&#39;: 0.0728785, &#39;decay&#39;: [Pd]}, &#39;Cd&#39;: {&#39;string&#39;: &#39;3113112211&#39;, &#39;abundance&#39;: 0.0950027, &#39;decay&#39;: [Ag]}, &#39;In&#39;: {&#39;string&#39;: &#39;11131221&#39;, &#39;abundance&#39;: 0.1238434, &#39;decay&#39;: [Cd]}, &#39;Sn&#39;: {&#39;string&#39;: &#39;13211&#39;, &#39;abundance&#39;: 0.1614395, &#39;decay&#39;: [In]}, &#39;Sb&#39;: {&#39;string&#39;: &#39;3112221&#39;, &#39;abundance&#39;: 0.2104488, &#39;decay&#39;: [Pm, Sn]}, &#39;Te&#39;: {&#39;string&#39;: &#39;1322113312211&#39;, &#39;abundance&#39;: 0.2743363, &#39;decay&#39;: [Eu, Ca, Sb]}, &#39;I&#39;: {&#39;string&#39;: &#39;311311222113111221&#39;, &#39;abundance&#39;: 0.3576186, &#39;decay&#39;: [Ho, Te]}, &#39;Xe&#39;: {&#39;string&#39;: &#39;11131221131211&#39;, &#39;abundance&#39;: 0.4661834, &#39;decay&#39;: [I]}, &#39;Cs&#39;: {&#39;string&#39;: &#39;13211321&#39;, &#39;abundance&#39;: 0.6077061, &#39;decay&#39;: [Xe]}, &#39;Ba&#39;: {&#39;string&#39;: &#39;311311&#39;, &#39;abundance&#39;: 0.7921919, &#39;decay&#39;: [Cs]}, &#39;La&#39;: {&#39;string&#39;: &#39;11131&#39;, &#39;abundance&#39;: 1.0326833, &#39;decay&#39;: [Ba]}, &#39;Ce&#39;: {&#39;string&#39;: &#39;1321133112&#39;, &#39;abundance&#39;: 1.3461825, &#39;decay&#39;: [La, H, Ca, Co]}, &#39;Pr&#39;: {&#39;string&#39;: &#39;31131112&#39;, &#39;abundance&#39;: 1.7548529, &#39;decay&#39;: [Ce]}, &#39;Nd&#39;: {&#39;string&#39;: &#39;111312&#39;, &#39;abundance&#39;: 2.2875864, &#39;decay&#39;: [Pr]}, &#39;Pm&#39;: {&#39;string&#39;: &#39;132&#39;, &#39;abundance&#39;: 2.9820456, &#39;decay&#39;: [Nd]}, &#39;Sm&#39;: {&#39;string&#39;: &#39;311332&#39;, &#39;abundance&#39;: 1.5408115, &#39;decay&#39;: [Pm, Ca, Zn]}, &#39;Eu&#39;: {&#39;string&#39;: &#39;1113222&#39;, &#39;abundance&#39;: 2.0085669, &#39;decay&#39;: [Sm]}, &#39;Gd&#39;: {&#39;string&#39;: &#39;13221133112&#39;, &#39;abundance&#39;: 2.1662973, &#39;decay&#39;: [Eu, Ca, Co]}, &#39;Tb&#39;: {&#39;string&#39;: &#39;3113112221131112&#39;, &#39;abundance&#39;: 2.8239359, &#39;decay&#39;: [Ho, Gd]}, &#39;Dy&#39;: {&#39;string&#39;: &#39;111312211312&#39;, &#39;abundance&#39;: 3.6812186, &#39;decay&#39;: [Tb]}, &#39;Ho&#39;: {&#39;string&#39;: &#39;1321132&#39;, &#39;abundance&#39;: 4.7987529, &#39;decay&#39;: [Dy]}, &#39;Er&#39;: {&#39;string&#39;: &#39;311311222&#39;, &#39;abundance&#39;: 0.1098596, &#39;decay&#39;: [Ho, Pm]}, &#39;Tm&#39;: {&#39;string&#39;: &#39;11131221133112&#39;, &#39;abundance&#39;: 0.1204908, &#39;decay&#39;: [Er, Ca, Co]}, &#39;Yb&#39;: {&#39;string&#39;: &#39;1321131112&#39;, &#39;abundance&#39;: 0.1570691, &#39;decay&#39;: [Tm]}, &#39;Lu&#39;: {&#39;string&#39;: &#39;311312&#39;, &#39;abundance&#39;: 0.2047517, &#39;decay&#39;: [Yb]}, &#39;Hf&#39;: {&#39;string&#39;: &#39;11132&#39;, &#39;abundance&#39;: 0.2669097, &#39;decay&#39;: [Lu]}, &#39;Ta&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322113&#39;, &#39;abundance&#39;: 0.0242077, &#39;decay&#39;: [Hf, Pa, H, Ca, W]}, &#39;W&#39;: {&#39;string&#39;: &#39;312211322212221121123222113&#39;, &#39;abundance&#39;: 0.0315567, &#39;decay&#39;: [Ta]}, &#39;Re&#39;: {&#39;string&#39;: &#39;111312211312113221133211322112211213322113&#39;, &#39;abundance&#39;: 0.0169288, &#39;decay&#39;: [Ge, Ca, W]}, &#39;Os&#39;: {&#39;string&#39;: &#39;1321132122211322212221121123222113&#39;, &#39;abundance&#39;: 0.022068, &#39;decay&#39;: [Re]}, &#39;Ir&#39;: {&#39;string&#39;: &#39;3113112211322112211213322113&#39;, &#39;abundance&#39;: 0.0287673, &#39;decay&#39;: [Os]}, &#39;Pt&#39;: {&#39;string&#39;: &#39;111312212221121123222113&#39;, &#39;abundance&#39;: 0.0375005, &#39;decay&#39;: [Ir]}, &#39;Au&#39;: {&#39;string&#39;: &#39;132112211213322113&#39;, &#39;abundance&#39;: 0.0488847, &#39;decay&#39;: [Pt]}, &#39;Hg&#39;: {&#39;string&#39;: &#39;31121123222113&#39;, &#39;abundance&#39;: 0.063725, &#39;decay&#39;: [Au]}, &#39;Tl&#39;: {&#39;string&#39;: &#39;111213322113&#39;, &#39;abundance&#39;: 0.0830705, &#39;decay&#39;: [Hg]}, &#39;Pb&#39;: {&#39;string&#39;: &#39;123222113&#39;, &#39;abundance&#39;: 0.1082888, &#39;decay&#39;: [Tl]}, &#39;Bi&#39;: {&#39;string&#39;: &#39;3113322113&#39;, &#39;abundance&#39;: 0.1411629, &#39;decay&#39;: [Pm, Pb]}, &#39;Po&#39;: {&#39;string&#39;: &#39;1113222113&#39;, &#39;abundance&#39;: 0.1840167, &#39;decay&#39;: [Bi]}, &#39;At&#39;: {&#39;string&#39;: &#39;1322113&#39;, &#39;abundance&#39;: 0.23988, &#39;decay&#39;: [Po]}, &#39;Rn&#39;: {&#39;string&#39;: &#39;311311222113&#39;, &#39;abundance&#39;: 0.3127021, &#39;decay&#39;: [Ho, At]}, &#39;Fr&#39;: {&#39;string&#39;: &#39;1113122113&#39;, &#39;abundance&#39;: 0.4076313, &#39;decay&#39;: [Rn]}, &#39;Ra&#39;: {&#39;string&#39;: &#39;132113&#39;, &#39;abundance&#39;: 0.5313789, &#39;decay&#39;: [Fr]}, &#39;Ac&#39;: {&#39;string&#39;: &#39;3113&#39;, &#39;abundance&#39;: 0.6926935, &#39;decay&#39;: [Ra]}, &#39;Th&#39;: {&#39;string&#39;: &#39;1113&#39;, &#39;abundance&#39;: 0.7581905, &#39;decay&#39;: [Ac]}, &#39;Pa&#39;: {&#39;string&#39;: &#39;13&#39;, &#39;abundance&#39;: 0.9883599, &#39;decay&#39;: [Th]}, &#39;U&#39;: {&#39;string&#39;: &#39;3&#39;, &#39;abundance&#39;: 0.0102563, &#39;decay&#39;: [Pa]}, &#39;Np4&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322114&#39;, &#39;abundance&#39;: 0.0, &#39;decay&#39;: [Hf, Pa, H, Ca, Pu4]}, &#39;Pu4&#39;: {&#39;string&#39;: &#39;312211322212221121123222114&#39;, &#39;abundance&#39;: 0.0, &#39;decay&#39;: [Np4]}}

        ```
        &#34;&#34;&#34;
        return {e.get_name() : {&#39;string&#39; : e.get_string(), 
                                &#39;abundance&#39; : self._get_abundances(dec_places, abundance_sum)[i],
                                &#39;decay&#39; : e.get_decay()}
                                for i, e in enumerate(self.get_elements())}

    def print_periodic_table(self, dec_places = 7, abundance_sum = 100):
        &#34;&#34;&#34;
        Prints the periodic table. Note the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The parameter ``dec_places`` refers to the accuracy of the abundances.
        &#34;&#34;&#34;
        pt = self.get_periodic_table(dec_places, abundance_sum)
        elt_width = 2 + max(len(&#39;element&#39;), max([len(e.get_name()) for e in self.get_elements()]))
        str_width = 2 + max(len(&#39;string&#39;), max([len(e.get_string()) for e in self.get_elements()]))
        ab_width  = 2 + max(len(&#39;abundance&#39;), max([len(str(prop[&#39;abundance&#39;])) for elt, prop in pt.items()]))
        print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(&#39;element&#39;, &#39;string&#39;, &#39;abundance&#39;, &#39;decay&#39;, elt_width=elt_width, str_width=str_width, ab_width=ab_width))
        for elt, prop in pt.items():
            print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(elt, prop[&#39;string&#39;], prop[&#39;abundance&#39;], str(prop[&#39;decay&#39;]), elt_width=elt_width, str_width=str_width, ab_width=ab_width))

    def order_elements(self, order_on, key = None, reverse = False, rename = True):
        &#34;&#34;&#34;
        Reorders the list of elements depending on the parameter ``order_on`` as follows:

        * ``order_on=&#39;abundance&#39;``: Orders elements from highest abundance to lowest.
        * ``order_on=&#39;string&#39;``: Orders elements according to the lexicographic order of their strings.
        * ``order_on=&#39;string length&#39;``: Orders elements according to the lengths of their strings from shortest to longest.
        * ``order_on=&#39;name&#39;``: Orders elements alphabetically according to their names.
        * ``order_on=&#39;key&#39;``: Orders elements according to the function specified by the parameter ``key``.

        You can reverse the ordering above by passing the extra parameter ``reverse = True``.
        
        By default this method will automatically rename the elements according to their new order.
        This will not happen if the elements are named via Conway or if the parameter ``rename = False`` is passed.
        &#34;&#34;&#34;
        assert order_on in [&#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, &#39;key&#39;], &#34;Invalid parameter passed to order_elements. Valid parameter are &#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, and &#39;key&#39;.&#34;
        pt = self.get_periodic_table()
        sorted_key = {
            &#39;abundance&#39;: lambda e : pt[e.get_name()][&#39;abundance&#39;],
            &#39;name&#39;: lambda e : e.get_name(),
            &#39;string&#39;: lambda e : e.get_string(),
            &#39;string length&#39;: lambda e : len(e.get_string()),
            &#39;key&#39;: key
        }
        self.elements = sorted(self.get_elements(), key = sorted_key[order_on])
        if order_on == &#39;abundance&#39;:
            self.elements.reverse()
        if reverse:
            self.elements.reverse()
        if not self.las._is_Conway and rename:
            self._name_elements()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="look_and_say.BinaryChemistry" href="#look_and_say.BinaryChemistry">BinaryChemistry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Chemistry.clear_elements"><code class="name flex">
<span>def <span class="ident">clear_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the list of elements back to the empty list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_elements(self):
    &#34;&#34;&#34;Resets the list of elements back to the empty list.&#34;&#34;&#34;
    self.elements = []</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.generate_elements"><code class="name flex">
<span>def <span class="ident">generate_elements</span></span>(<span>self, *seeds, reset=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects all the persistent elements from all the look and
say sequences generated by the given seeds. The string(s) entered as the
parameter(s) will be used as the seed(s) for generating the elements.
By default, this method will clear any elements in the chemistry that exist
before this method is called (i.e. prior to collecting from the new seeds).
Use <code>reset = False</code>
to keep the old elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_elements(self, *seeds, reset = True):
    &#34;&#34;&#34;
    Collects all the persistent elements from all the look and
    say sequences generated by the given seeds. The string(s) entered as the 
    parameter(s) will be used as the seed(s) for generating the elements. 
    By default, this method will clear any elements in the chemistry that exist 
    before this method is called (i.e. prior to collecting from the new seeds). 
    Use ``reset = False``  to keep the old elements. 
    &#34;&#34;&#34;
    if reset:
        self.clear_elements()
    strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
    self._generate_all_elements(strings)
    self._remove_intermittent_elements()
    self.order_elements(&#39;string&#39;)
    self._name_elements()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_char_poly"><code class="name flex">
<span>def <span class="ident">get_char_poly</span></span>(<span>self, factor=True, latex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the characteristic polynomial of the decay matrix using sympy.
By default the returned polynomial will be factored.
Use <code>factor = False</code> to get the expanded (i.e. unfactored) polynomial.
Use <code>latex = True</code> to return the polynomial formatted in latex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_char_poly(self, factor = True, latex = False):
    &#34;&#34;&#34;
    Returns the characteristic polynomial of the decay matrix using sympy.
    By default the returned polynomial will be factored. 
    Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
    Use ``latex = True`` to return the polynomial formatted in latex.
    &#34;&#34;&#34;
    chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
    if factor:
        chi = sympy.factor(chi.as_expr())
    else:
        chi = chi.as_expr()
    if latex:
        return sympy.latex(chi)
    else:
        return chi</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_decay_matrix"><code class="name flex">
<span>def <span class="ident">get_decay_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the decay matrix as a nested list of integers
(i.e. a list of the rows).
The order of the columns and rows correspond to the order
in the list of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decay_matrix(self):
    &#34;&#34;&#34;
    Returns the decay matrix as a nested list of integers 
    (i.e. a list of the rows).
    The order of the columns and rows correspond to the order
    in the list of elements.
    &#34;&#34;&#34;
    mat = []
    e = self.elements
    for i in range(len(e)):
        row = []
        for j in range(len(e)):
            row.append(e[j].get_decay().count(e[i]))
        mat.append(row)
    return mat</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_elements"><code class="name flex">
<span>def <span class="ident">get_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the elements as a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements(self):
    &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
    return self.elements</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_max_eigenvalue"><code class="name flex">
<span>def <span class="ident">get_max_eigenvalue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximal real eigenvalue of the decay matrix.
In the standard case, this will give Conway's constant.
In general, this will give the growth rate of the look and say sequence.
This method assumes the existence of a real eigenvalue which
is larger than (the absolute value) of every other eigenvalue.
This assumption is usually guaranteed by the Perron-Frobenius Theorem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_eigenvalue(self):
    &#34;&#34;&#34;
    Returns the maximal real eigenvalue of the decay matrix.
    In the standard case, this will give Conway&#39;s constant. 
    In general, this will give the growth rate of the look and say sequence. 
    This method assumes the existence of a real eigenvalue which
    is larger than (the absolute value) of every other eigenvalue.
    This assumption is usually guaranteed by the Perron-Frobenius Theorem.
    &#34;&#34;&#34;
    assert len(self.elements) &gt; 0, &#34;The get_max_eigenvalue method requires a nonempty list of elements.\n\tTo fix: Use the generate_elements method prior to calling get_max_eigenvalue.&#34;
    eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
    eigenvalues = eigenstuff[0]
    return max(eigenvalues).real</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_periodic_table"><code class="name flex">
<span>def <span class="ident">get_periodic_table</span></span>(<span>self, dec_places=7, abundance_sum=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a periodic table including each element's name, string, relative abundance, and decay.
Returns the periodic table as a nested dictionary.</p>
<h2 id="example-session">Example Session:</h2>
<pre><code class="language-python">&gt;&gt;&gt; ls = LookAndSay()
&gt;&gt;&gt; chem = Chemistry(ls)
&gt;&gt;&gt; chem.generate_elements('4')
&gt;&gt;&gt; print(chem.get_periodic_table())
{'H': {'string': '22', 'abundance': 9.1790383, 'decay': [H]}, 'He': {'string': '13112221133211322112211213322112', 'abundance': 0.3237297, 'decay': [Hf, Pa, H, Ca, Li]}, 'Li': {'string': '312211322212221121123222112', 'abundance': 0.4220067, 'decay': [He]}, 'Be': {'string': '111312211312113221133211322112211213322112', 'abundance': 0.2263886, 'decay': [Ge, Ca, Li]}, 'B': {'string': '1321132122211322212221121123222112', 'abundance': 0.295115, 'decay': [Be]}, 'C': {'string': '3113112211322112211213322112', 'abundance': 0.3847053, 'decay': [B]}, 'N': {'string': '111312212221121123222112', 'abundance': 0.501493, 'decay': [C]}, 'O': {'string': '132112211213322112', 'abundance': 0.6537349, 'decay': [N]}, 'F': {'string': '31121123222112', 'abundance': 0.852194, 'decay': [O]}, 'Ne': {'string': '111213322112', 'abundance': 1.1109007, 'decay': [F]}, 'Na': {'string': '123222112', 'abundance': 1.4481449, 'decay': [Ne]}, 'Mg': {'string': '3113322112', 'abundance': 1.8850441, 'decay': [Pm, Na]}, 'Al': {'string': '1113222112', 'abundance': 2.4573007, 'decay': [Mg]}, 'Si': {'string': '1322112', 'abundance': 3.2032813, 'decay': [Al]}, 'P': {'string': '311311222112', 'abundance': 1.4895887, 'decay': [Ho, Si]}, 'S': {'string': '1113122112', 'abundance': 1.9417939, 'decay': [P]}, 'Cl': {'string': '132112', 'abundance': 2.5312784, 'decay': [S]}, 'Ar': {'string': '3112', 'abundance': 3.299717, 'decay': [Cl]}, 'K': {'string': '1112', 'abundance': 4.3014361, 'decay': [Ar]}, 'Ca': {'string': '12', 'abundance': 5.6072543, 'decay': [K]}, 'Sc': {'string': '3113112221133112', 'abundance': 0.9302097, 'decay': [Ho, Pa, H, Ca, Co]}, 'Ti': {'string': '11131221131112', 'abundance': 1.2126003, 'decay': [Sc]}, 'V': {'string': '13211312', 'abundance': 1.5807182, 'decay': [Ti]}, 'Cr': {'string': '31132', 'abundance': 2.0605883, 'decay': [V]}, 'Mn': {'string': '111311222112', 'abundance': 2.686136, 'decay': [Cr, Si]}, 'Fe': {'string': '13122112', 'abundance': 3.5015859, 'decay': [Mn]}, 'Co': {'string': '32112', 'abundance': 4.5645877, 'decay': [Fe]}, 'Ni': {'string': '11133112', 'abundance': 1.3871124, 'decay': [Zn, Co]}, 'Cu': {'string': '131112', 'abundance': 1.8082082, 'decay': [Ni]}, 'Zn': {'string': '312', 'abundance': 2.3571391, 'decay': [Cu]}, 'Ga': {'string': '13221133122211332', 'abundance': 0.1447891, 'decay': [Eu, Ca, Ac, H, Ca, Zn]}, 'Ge': {'string': '31131122211311122113222', 'abundance': 0.1887437, 'decay': [Ho, Ga]}, 'As': {'string': '11131221131211322113322112', 'abundance': 0.0027246, 'decay': [Ge, Na]}, 'Se': {'string': '13211321222113222112', 'abundance': 0.0035518, 'decay': [As]}, 'Br': {'string': '3113112211322112', 'abundance': 0.00463, 'decay': [Se]}, 'Kr': {'string': '11131221222112', 'abundance': 0.0060355, 'decay': [Br]}, 'Rb': {'string': '1321122112', 'abundance': 0.0078678, 'decay': [Kr]}, 'Sr': {'string': '3112112', 'abundance': 0.0102563, 'decay': [Rb]}, 'Y': {'string': '1112133', 'abundance': 0.0133699, 'decay': [Sr, U]}, 'Zr': {'string': '12322211331222113112211', 'abundance': 0.0174286, 'decay': [Y, H, Ca, Tc]}, 'Nb': {'string': '1113122113322113111221131221', 'abundance': 0.0227196, 'decay': [Er, Zr]}, 'Mo': {'string': '13211322211312113211', 'abundance': 0.0296167, 'decay': [Nb]}, 'Tc': {'string': '311322113212221', 'abundance': 0.0386077, 'decay': [Mo]}, 'Ru': {'string': '132211331222113112211', 'abundance': 0.0328995, 'decay': [Eu, Ca, Tc]}, 'Rh': {'string': '311311222113111221131221', 'abundance': 0.042887, 'decay': [Ho, Ru]}, 'Pd': {'string': '111312211312113211', 'abundance': 0.0559065, 'decay': [Rh]}, 'Ag': {'string': '132113212221', 'abundance': 0.0728785, 'decay': [Pd]}, 'Cd': {'string': '3113112211', 'abundance': 0.0950027, 'decay': [Ag]}, 'In': {'string': '11131221', 'abundance': 0.1238434, 'decay': [Cd]}, 'Sn': {'string': '13211', 'abundance': 0.1614395, 'decay': [In]}, 'Sb': {'string': '3112221', 'abundance': 0.2104488, 'decay': [Pm, Sn]}, 'Te': {'string': '1322113312211', 'abundance': 0.2743363, 'decay': [Eu, Ca, Sb]}, 'I': {'string': '311311222113111221', 'abundance': 0.3576186, 'decay': [Ho, Te]}, 'Xe': {'string': '11131221131211', 'abundance': 0.4661834, 'decay': [I]}, 'Cs': {'string': '13211321', 'abundance': 0.6077061, 'decay': [Xe]}, 'Ba': {'string': '311311', 'abundance': 0.7921919, 'decay': [Cs]}, 'La': {'string': '11131', 'abundance': 1.0326833, 'decay': [Ba]}, 'Ce': {'string': '1321133112', 'abundance': 1.3461825, 'decay': [La, H, Ca, Co]}, 'Pr': {'string': '31131112', 'abundance': 1.7548529, 'decay': [Ce]}, 'Nd': {'string': '111312', 'abundance': 2.2875864, 'decay': [Pr]}, 'Pm': {'string': '132', 'abundance': 2.9820456, 'decay': [Nd]}, 'Sm': {'string': '311332', 'abundance': 1.5408115, 'decay': [Pm, Ca, Zn]}, 'Eu': {'string': '1113222', 'abundance': 2.0085669, 'decay': [Sm]}, 'Gd': {'string': '13221133112', 'abundance': 2.1662973, 'decay': [Eu, Ca, Co]}, 'Tb': {'string': '3113112221131112', 'abundance': 2.8239359, 'decay': [Ho, Gd]}, 'Dy': {'string': '111312211312', 'abundance': 3.6812186, 'decay': [Tb]}, 'Ho': {'string': '1321132', 'abundance': 4.7987529, 'decay': [Dy]}, 'Er': {'string': '311311222', 'abundance': 0.1098596, 'decay': [Ho, Pm]}, 'Tm': {'string': '11131221133112', 'abundance': 0.1204908, 'decay': [Er, Ca, Co]}, 'Yb': {'string': '1321131112', 'abundance': 0.1570691, 'decay': [Tm]}, 'Lu': {'string': '311312', 'abundance': 0.2047517, 'decay': [Yb]}, 'Hf': {'string': '11132', 'abundance': 0.2669097, 'decay': [Lu]}, 'Ta': {'string': '13112221133211322112211213322113', 'abundance': 0.0242077, 'decay': [Hf, Pa, H, Ca, W]}, 'W': {'string': '312211322212221121123222113', 'abundance': 0.0315567, 'decay': [Ta]}, 'Re': {'string': '111312211312113221133211322112211213322113', 'abundance': 0.0169288, 'decay': [Ge, Ca, W]}, 'Os': {'string': '1321132122211322212221121123222113', 'abundance': 0.022068, 'decay': [Re]}, 'Ir': {'string': '3113112211322112211213322113', 'abundance': 0.0287673, 'decay': [Os]}, 'Pt': {'string': '111312212221121123222113', 'abundance': 0.0375005, 'decay': [Ir]}, 'Au': {'string': '132112211213322113', 'abundance': 0.0488847, 'decay': [Pt]}, 'Hg': {'string': '31121123222113', 'abundance': 0.063725, 'decay': [Au]}, 'Tl': {'string': '111213322113', 'abundance': 0.0830705, 'decay': [Hg]}, 'Pb': {'string': '123222113', 'abundance': 0.1082888, 'decay': [Tl]}, 'Bi': {'string': '3113322113', 'abundance': 0.1411629, 'decay': [Pm, Pb]}, 'Po': {'string': '1113222113', 'abundance': 0.1840167, 'decay': [Bi]}, 'At': {'string': '1322113', 'abundance': 0.23988, 'decay': [Po]}, 'Rn': {'string': '311311222113', 'abundance': 0.3127021, 'decay': [Ho, At]}, 'Fr': {'string': '1113122113', 'abundance': 0.4076313, 'decay': [Rn]}, 'Ra': {'string': '132113', 'abundance': 0.5313789, 'decay': [Fr]}, 'Ac': {'string': '3113', 'abundance': 0.6926935, 'decay': [Ra]}, 'Th': {'string': '1113', 'abundance': 0.7581905, 'decay': [Ac]}, 'Pa': {'string': '13', 'abundance': 0.9883599, 'decay': [Th]}, 'U': {'string': '3', 'abundance': 0.0102563, 'decay': [Pa]}, 'Np4': {'string': '13112221133211322112211213322114', 'abundance': 0.0, 'decay': [Hf, Pa, H, Ca, Pu4]}, 'Pu4': {'string': '312211322212221121123222114', 'abundance': 0.0, 'decay': [Np4]}}

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_periodic_table(self, dec_places = 7, abundance_sum = 100):
    &#34;&#34;&#34;
    Creates a periodic table including each element&#39;s name, string, relative abundance, and decay.
    Returns the periodic table as a nested dictionary.

    ## Example Session:
    ```python
    &gt;&gt;&gt; ls = LookAndSay()
    &gt;&gt;&gt; chem = Chemistry(ls)
    &gt;&gt;&gt; chem.generate_elements(&#39;4&#39;)
    &gt;&gt;&gt; print(chem.get_periodic_table())
    {&#39;H&#39;: {&#39;string&#39;: &#39;22&#39;, &#39;abundance&#39;: 9.1790383, &#39;decay&#39;: [H]}, &#39;He&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322112&#39;, &#39;abundance&#39;: 0.3237297, &#39;decay&#39;: [Hf, Pa, H, Ca, Li]}, &#39;Li&#39;: {&#39;string&#39;: &#39;312211322212221121123222112&#39;, &#39;abundance&#39;: 0.4220067, &#39;decay&#39;: [He]}, &#39;Be&#39;: {&#39;string&#39;: &#39;111312211312113221133211322112211213322112&#39;, &#39;abundance&#39;: 0.2263886, &#39;decay&#39;: [Ge, Ca, Li]}, &#39;B&#39;: {&#39;string&#39;: &#39;1321132122211322212221121123222112&#39;, &#39;abundance&#39;: 0.295115, &#39;decay&#39;: [Be]}, &#39;C&#39;: {&#39;string&#39;: &#39;3113112211322112211213322112&#39;, &#39;abundance&#39;: 0.3847053, &#39;decay&#39;: [B]}, &#39;N&#39;: {&#39;string&#39;: &#39;111312212221121123222112&#39;, &#39;abundance&#39;: 0.501493, &#39;decay&#39;: [C]}, &#39;O&#39;: {&#39;string&#39;: &#39;132112211213322112&#39;, &#39;abundance&#39;: 0.6537349, &#39;decay&#39;: [N]}, &#39;F&#39;: {&#39;string&#39;: &#39;31121123222112&#39;, &#39;abundance&#39;: 0.852194, &#39;decay&#39;: [O]}, &#39;Ne&#39;: {&#39;string&#39;: &#39;111213322112&#39;, &#39;abundance&#39;: 1.1109007, &#39;decay&#39;: [F]}, &#39;Na&#39;: {&#39;string&#39;: &#39;123222112&#39;, &#39;abundance&#39;: 1.4481449, &#39;decay&#39;: [Ne]}, &#39;Mg&#39;: {&#39;string&#39;: &#39;3113322112&#39;, &#39;abundance&#39;: 1.8850441, &#39;decay&#39;: [Pm, Na]}, &#39;Al&#39;: {&#39;string&#39;: &#39;1113222112&#39;, &#39;abundance&#39;: 2.4573007, &#39;decay&#39;: [Mg]}, &#39;Si&#39;: {&#39;string&#39;: &#39;1322112&#39;, &#39;abundance&#39;: 3.2032813, &#39;decay&#39;: [Al]}, &#39;P&#39;: {&#39;string&#39;: &#39;311311222112&#39;, &#39;abundance&#39;: 1.4895887, &#39;decay&#39;: [Ho, Si]}, &#39;S&#39;: {&#39;string&#39;: &#39;1113122112&#39;, &#39;abundance&#39;: 1.9417939, &#39;decay&#39;: [P]}, &#39;Cl&#39;: {&#39;string&#39;: &#39;132112&#39;, &#39;abundance&#39;: 2.5312784, &#39;decay&#39;: [S]}, &#39;Ar&#39;: {&#39;string&#39;: &#39;3112&#39;, &#39;abundance&#39;: 3.299717, &#39;decay&#39;: [Cl]}, &#39;K&#39;: {&#39;string&#39;: &#39;1112&#39;, &#39;abundance&#39;: 4.3014361, &#39;decay&#39;: [Ar]}, &#39;Ca&#39;: {&#39;string&#39;: &#39;12&#39;, &#39;abundance&#39;: 5.6072543, &#39;decay&#39;: [K]}, &#39;Sc&#39;: {&#39;string&#39;: &#39;3113112221133112&#39;, &#39;abundance&#39;: 0.9302097, &#39;decay&#39;: [Ho, Pa, H, Ca, Co]}, &#39;Ti&#39;: {&#39;string&#39;: &#39;11131221131112&#39;, &#39;abundance&#39;: 1.2126003, &#39;decay&#39;: [Sc]}, &#39;V&#39;: {&#39;string&#39;: &#39;13211312&#39;, &#39;abundance&#39;: 1.5807182, &#39;decay&#39;: [Ti]}, &#39;Cr&#39;: {&#39;string&#39;: &#39;31132&#39;, &#39;abundance&#39;: 2.0605883, &#39;decay&#39;: [V]}, &#39;Mn&#39;: {&#39;string&#39;: &#39;111311222112&#39;, &#39;abundance&#39;: 2.686136, &#39;decay&#39;: [Cr, Si]}, &#39;Fe&#39;: {&#39;string&#39;: &#39;13122112&#39;, &#39;abundance&#39;: 3.5015859, &#39;decay&#39;: [Mn]}, &#39;Co&#39;: {&#39;string&#39;: &#39;32112&#39;, &#39;abundance&#39;: 4.5645877, &#39;decay&#39;: [Fe]}, &#39;Ni&#39;: {&#39;string&#39;: &#39;11133112&#39;, &#39;abundance&#39;: 1.3871124, &#39;decay&#39;: [Zn, Co]}, &#39;Cu&#39;: {&#39;string&#39;: &#39;131112&#39;, &#39;abundance&#39;: 1.8082082, &#39;decay&#39;: [Ni]}, &#39;Zn&#39;: {&#39;string&#39;: &#39;312&#39;, &#39;abundance&#39;: 2.3571391, &#39;decay&#39;: [Cu]}, &#39;Ga&#39;: {&#39;string&#39;: &#39;13221133122211332&#39;, &#39;abundance&#39;: 0.1447891, &#39;decay&#39;: [Eu, Ca, Ac, H, Ca, Zn]}, &#39;Ge&#39;: {&#39;string&#39;: &#39;31131122211311122113222&#39;, &#39;abundance&#39;: 0.1887437, &#39;decay&#39;: [Ho, Ga]}, &#39;As&#39;: {&#39;string&#39;: &#39;11131221131211322113322112&#39;, &#39;abundance&#39;: 0.0027246, &#39;decay&#39;: [Ge, Na]}, &#39;Se&#39;: {&#39;string&#39;: &#39;13211321222113222112&#39;, &#39;abundance&#39;: 0.0035518, &#39;decay&#39;: [As]}, &#39;Br&#39;: {&#39;string&#39;: &#39;3113112211322112&#39;, &#39;abundance&#39;: 0.00463, &#39;decay&#39;: [Se]}, &#39;Kr&#39;: {&#39;string&#39;: &#39;11131221222112&#39;, &#39;abundance&#39;: 0.0060355, &#39;decay&#39;: [Br]}, &#39;Rb&#39;: {&#39;string&#39;: &#39;1321122112&#39;, &#39;abundance&#39;: 0.0078678, &#39;decay&#39;: [Kr]}, &#39;Sr&#39;: {&#39;string&#39;: &#39;3112112&#39;, &#39;abundance&#39;: 0.0102563, &#39;decay&#39;: [Rb]}, &#39;Y&#39;: {&#39;string&#39;: &#39;1112133&#39;, &#39;abundance&#39;: 0.0133699, &#39;decay&#39;: [Sr, U]}, &#39;Zr&#39;: {&#39;string&#39;: &#39;12322211331222113112211&#39;, &#39;abundance&#39;: 0.0174286, &#39;decay&#39;: [Y, H, Ca, Tc]}, &#39;Nb&#39;: {&#39;string&#39;: &#39;1113122113322113111221131221&#39;, &#39;abundance&#39;: 0.0227196, &#39;decay&#39;: [Er, Zr]}, &#39;Mo&#39;: {&#39;string&#39;: &#39;13211322211312113211&#39;, &#39;abundance&#39;: 0.0296167, &#39;decay&#39;: [Nb]}, &#39;Tc&#39;: {&#39;string&#39;: &#39;311322113212221&#39;, &#39;abundance&#39;: 0.0386077, &#39;decay&#39;: [Mo]}, &#39;Ru&#39;: {&#39;string&#39;: &#39;132211331222113112211&#39;, &#39;abundance&#39;: 0.0328995, &#39;decay&#39;: [Eu, Ca, Tc]}, &#39;Rh&#39;: {&#39;string&#39;: &#39;311311222113111221131221&#39;, &#39;abundance&#39;: 0.042887, &#39;decay&#39;: [Ho, Ru]}, &#39;Pd&#39;: {&#39;string&#39;: &#39;111312211312113211&#39;, &#39;abundance&#39;: 0.0559065, &#39;decay&#39;: [Rh]}, &#39;Ag&#39;: {&#39;string&#39;: &#39;132113212221&#39;, &#39;abundance&#39;: 0.0728785, &#39;decay&#39;: [Pd]}, &#39;Cd&#39;: {&#39;string&#39;: &#39;3113112211&#39;, &#39;abundance&#39;: 0.0950027, &#39;decay&#39;: [Ag]}, &#39;In&#39;: {&#39;string&#39;: &#39;11131221&#39;, &#39;abundance&#39;: 0.1238434, &#39;decay&#39;: [Cd]}, &#39;Sn&#39;: {&#39;string&#39;: &#39;13211&#39;, &#39;abundance&#39;: 0.1614395, &#39;decay&#39;: [In]}, &#39;Sb&#39;: {&#39;string&#39;: &#39;3112221&#39;, &#39;abundance&#39;: 0.2104488, &#39;decay&#39;: [Pm, Sn]}, &#39;Te&#39;: {&#39;string&#39;: &#39;1322113312211&#39;, &#39;abundance&#39;: 0.2743363, &#39;decay&#39;: [Eu, Ca, Sb]}, &#39;I&#39;: {&#39;string&#39;: &#39;311311222113111221&#39;, &#39;abundance&#39;: 0.3576186, &#39;decay&#39;: [Ho, Te]}, &#39;Xe&#39;: {&#39;string&#39;: &#39;11131221131211&#39;, &#39;abundance&#39;: 0.4661834, &#39;decay&#39;: [I]}, &#39;Cs&#39;: {&#39;string&#39;: &#39;13211321&#39;, &#39;abundance&#39;: 0.6077061, &#39;decay&#39;: [Xe]}, &#39;Ba&#39;: {&#39;string&#39;: &#39;311311&#39;, &#39;abundance&#39;: 0.7921919, &#39;decay&#39;: [Cs]}, &#39;La&#39;: {&#39;string&#39;: &#39;11131&#39;, &#39;abundance&#39;: 1.0326833, &#39;decay&#39;: [Ba]}, &#39;Ce&#39;: {&#39;string&#39;: &#39;1321133112&#39;, &#39;abundance&#39;: 1.3461825, &#39;decay&#39;: [La, H, Ca, Co]}, &#39;Pr&#39;: {&#39;string&#39;: &#39;31131112&#39;, &#39;abundance&#39;: 1.7548529, &#39;decay&#39;: [Ce]}, &#39;Nd&#39;: {&#39;string&#39;: &#39;111312&#39;, &#39;abundance&#39;: 2.2875864, &#39;decay&#39;: [Pr]}, &#39;Pm&#39;: {&#39;string&#39;: &#39;132&#39;, &#39;abundance&#39;: 2.9820456, &#39;decay&#39;: [Nd]}, &#39;Sm&#39;: {&#39;string&#39;: &#39;311332&#39;, &#39;abundance&#39;: 1.5408115, &#39;decay&#39;: [Pm, Ca, Zn]}, &#39;Eu&#39;: {&#39;string&#39;: &#39;1113222&#39;, &#39;abundance&#39;: 2.0085669, &#39;decay&#39;: [Sm]}, &#39;Gd&#39;: {&#39;string&#39;: &#39;13221133112&#39;, &#39;abundance&#39;: 2.1662973, &#39;decay&#39;: [Eu, Ca, Co]}, &#39;Tb&#39;: {&#39;string&#39;: &#39;3113112221131112&#39;, &#39;abundance&#39;: 2.8239359, &#39;decay&#39;: [Ho, Gd]}, &#39;Dy&#39;: {&#39;string&#39;: &#39;111312211312&#39;, &#39;abundance&#39;: 3.6812186, &#39;decay&#39;: [Tb]}, &#39;Ho&#39;: {&#39;string&#39;: &#39;1321132&#39;, &#39;abundance&#39;: 4.7987529, &#39;decay&#39;: [Dy]}, &#39;Er&#39;: {&#39;string&#39;: &#39;311311222&#39;, &#39;abundance&#39;: 0.1098596, &#39;decay&#39;: [Ho, Pm]}, &#39;Tm&#39;: {&#39;string&#39;: &#39;11131221133112&#39;, &#39;abundance&#39;: 0.1204908, &#39;decay&#39;: [Er, Ca, Co]}, &#39;Yb&#39;: {&#39;string&#39;: &#39;1321131112&#39;, &#39;abundance&#39;: 0.1570691, &#39;decay&#39;: [Tm]}, &#39;Lu&#39;: {&#39;string&#39;: &#39;311312&#39;, &#39;abundance&#39;: 0.2047517, &#39;decay&#39;: [Yb]}, &#39;Hf&#39;: {&#39;string&#39;: &#39;11132&#39;, &#39;abundance&#39;: 0.2669097, &#39;decay&#39;: [Lu]}, &#39;Ta&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322113&#39;, &#39;abundance&#39;: 0.0242077, &#39;decay&#39;: [Hf, Pa, H, Ca, W]}, &#39;W&#39;: {&#39;string&#39;: &#39;312211322212221121123222113&#39;, &#39;abundance&#39;: 0.0315567, &#39;decay&#39;: [Ta]}, &#39;Re&#39;: {&#39;string&#39;: &#39;111312211312113221133211322112211213322113&#39;, &#39;abundance&#39;: 0.0169288, &#39;decay&#39;: [Ge, Ca, W]}, &#39;Os&#39;: {&#39;string&#39;: &#39;1321132122211322212221121123222113&#39;, &#39;abundance&#39;: 0.022068, &#39;decay&#39;: [Re]}, &#39;Ir&#39;: {&#39;string&#39;: &#39;3113112211322112211213322113&#39;, &#39;abundance&#39;: 0.0287673, &#39;decay&#39;: [Os]}, &#39;Pt&#39;: {&#39;string&#39;: &#39;111312212221121123222113&#39;, &#39;abundance&#39;: 0.0375005, &#39;decay&#39;: [Ir]}, &#39;Au&#39;: {&#39;string&#39;: &#39;132112211213322113&#39;, &#39;abundance&#39;: 0.0488847, &#39;decay&#39;: [Pt]}, &#39;Hg&#39;: {&#39;string&#39;: &#39;31121123222113&#39;, &#39;abundance&#39;: 0.063725, &#39;decay&#39;: [Au]}, &#39;Tl&#39;: {&#39;string&#39;: &#39;111213322113&#39;, &#39;abundance&#39;: 0.0830705, &#39;decay&#39;: [Hg]}, &#39;Pb&#39;: {&#39;string&#39;: &#39;123222113&#39;, &#39;abundance&#39;: 0.1082888, &#39;decay&#39;: [Tl]}, &#39;Bi&#39;: {&#39;string&#39;: &#39;3113322113&#39;, &#39;abundance&#39;: 0.1411629, &#39;decay&#39;: [Pm, Pb]}, &#39;Po&#39;: {&#39;string&#39;: &#39;1113222113&#39;, &#39;abundance&#39;: 0.1840167, &#39;decay&#39;: [Bi]}, &#39;At&#39;: {&#39;string&#39;: &#39;1322113&#39;, &#39;abundance&#39;: 0.23988, &#39;decay&#39;: [Po]}, &#39;Rn&#39;: {&#39;string&#39;: &#39;311311222113&#39;, &#39;abundance&#39;: 0.3127021, &#39;decay&#39;: [Ho, At]}, &#39;Fr&#39;: {&#39;string&#39;: &#39;1113122113&#39;, &#39;abundance&#39;: 0.4076313, &#39;decay&#39;: [Rn]}, &#39;Ra&#39;: {&#39;string&#39;: &#39;132113&#39;, &#39;abundance&#39;: 0.5313789, &#39;decay&#39;: [Fr]}, &#39;Ac&#39;: {&#39;string&#39;: &#39;3113&#39;, &#39;abundance&#39;: 0.6926935, &#39;decay&#39;: [Ra]}, &#39;Th&#39;: {&#39;string&#39;: &#39;1113&#39;, &#39;abundance&#39;: 0.7581905, &#39;decay&#39;: [Ac]}, &#39;Pa&#39;: {&#39;string&#39;: &#39;13&#39;, &#39;abundance&#39;: 0.9883599, &#39;decay&#39;: [Th]}, &#39;U&#39;: {&#39;string&#39;: &#39;3&#39;, &#39;abundance&#39;: 0.0102563, &#39;decay&#39;: [Pa]}, &#39;Np4&#39;: {&#39;string&#39;: &#39;13112221133211322112211213322114&#39;, &#39;abundance&#39;: 0.0, &#39;decay&#39;: [Hf, Pa, H, Ca, Pu4]}, &#39;Pu4&#39;: {&#39;string&#39;: &#39;312211322212221121123222114&#39;, &#39;abundance&#39;: 0.0, &#39;decay&#39;: [Np4]}}

    ```
    &#34;&#34;&#34;
    return {e.get_name() : {&#39;string&#39; : e.get_string(), 
                            &#39;abundance&#39; : self._get_abundances(dec_places, abundance_sum)[i],
                            &#39;decay&#39; : e.get_decay()}
                            for i, e in enumerate(self.get_elements())}</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.order_elements"><code class="name flex">
<span>def <span class="ident">order_elements</span></span>(<span>self, order_on, key=None, reverse=False, rename=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorders the list of elements depending on the parameter <code>order_on</code> as follows:</p>
<ul>
<li><code>order_on='abundance'</code>: Orders elements from highest abundance to lowest.</li>
<li><code>order_on='string'</code>: Orders elements according to the lexicographic order of their strings.</li>
<li><code>order_on='string length'</code>: Orders elements according to the lengths of their strings from shortest to longest.</li>
<li><code>order_on='name'</code>: Orders elements alphabetically according to their names.</li>
<li><code>order_on='key'</code>: Orders elements according to the function specified by the parameter <code>key</code>.</li>
</ul>
<p>You can reverse the ordering above by passing the extra parameter <code>reverse = True</code>.</p>
<p>By default this method will automatically rename the elements according to their new order.
This will not happen if the elements are named via Conway or if the parameter <code>rename = False</code> is passed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_elements(self, order_on, key = None, reverse = False, rename = True):
    &#34;&#34;&#34;
    Reorders the list of elements depending on the parameter ``order_on`` as follows:

    * ``order_on=&#39;abundance&#39;``: Orders elements from highest abundance to lowest.
    * ``order_on=&#39;string&#39;``: Orders elements according to the lexicographic order of their strings.
    * ``order_on=&#39;string length&#39;``: Orders elements according to the lengths of their strings from shortest to longest.
    * ``order_on=&#39;name&#39;``: Orders elements alphabetically according to their names.
    * ``order_on=&#39;key&#39;``: Orders elements according to the function specified by the parameter ``key``.

    You can reverse the ordering above by passing the extra parameter ``reverse = True``.
    
    By default this method will automatically rename the elements according to their new order.
    This will not happen if the elements are named via Conway or if the parameter ``rename = False`` is passed.
    &#34;&#34;&#34;
    assert order_on in [&#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, &#39;key&#39;], &#34;Invalid parameter passed to order_elements. Valid parameter are &#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, and &#39;key&#39;.&#34;
    pt = self.get_periodic_table()
    sorted_key = {
        &#39;abundance&#39;: lambda e : pt[e.get_name()][&#39;abundance&#39;],
        &#39;name&#39;: lambda e : e.get_name(),
        &#39;string&#39;: lambda e : e.get_string(),
        &#39;string length&#39;: lambda e : len(e.get_string()),
        &#39;key&#39;: key
    }
    self.elements = sorted(self.get_elements(), key = sorted_key[order_on])
    if order_on == &#39;abundance&#39;:
        self.elements.reverse()
    if reverse:
        self.elements.reverse()
    if not self.las._is_Conway and rename:
        self._name_elements()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.print_periodic_table"><code class="name flex">
<span>def <span class="ident">print_periodic_table</span></span>(<span>self, dec_places=7, abundance_sum=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the periodic table. Note the abundances are given as percentages,
so they will differ from Conway's abundances by a factor of <span><span class="MathJax_Preview">10^4</span><script type="math/tex">10^4</script></span>.
The parameter <code>dec_places</code> refers to the accuracy of the abundances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_periodic_table(self, dec_places = 7, abundance_sum = 100):
    &#34;&#34;&#34;
    Prints the periodic table. Note the abundances are given as percentages, 
    so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
    The parameter ``dec_places`` refers to the accuracy of the abundances.
    &#34;&#34;&#34;
    pt = self.get_periodic_table(dec_places, abundance_sum)
    elt_width = 2 + max(len(&#39;element&#39;), max([len(e.get_name()) for e in self.get_elements()]))
    str_width = 2 + max(len(&#39;string&#39;), max([len(e.get_string()) for e in self.get_elements()]))
    ab_width  = 2 + max(len(&#39;abundance&#39;), max([len(str(prop[&#39;abundance&#39;])) for elt, prop in pt.items()]))
    print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(&#39;element&#39;, &#39;string&#39;, &#39;abundance&#39;, &#39;decay&#39;, elt_width=elt_width, str_width=str_width, ab_width=ab_width))
    for elt, prop in pt.items():
        print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(elt, prop[&#39;string&#39;], prop[&#39;abundance&#39;], str(prop[&#39;decay&#39;]), elt_width=elt_width, str_width=str_width, ab_width=ab_width))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.Cosmology"><code class="flex name class">
<span>class <span class="ident">Cosmology</span></span>
<span>(</span><span>digits='123')</span>
</code></dt>
<dd>
<div class="desc"><p>A class for proving Conway's Cosmological Theorem.
Currently this will only prove The Cosmological Theorem
for the standard base ten look and say sequences where every term
consists of strings of some of the digits 1 through 9. The default
digits considered are the crucial ones: 1, 2, and 3.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cosmology():
    &#39;&#39;&#39;
    A class for proving Conway&#39;s Cosmological Theorem.
    Currently this will only prove The Cosmological Theorem 
    for the standard base ten look and say sequences where every term
    consists of strings of some of the digits 1 through 9. The default
    digits considered are the crucial ones: 1, 2, and 3.  
    &#39;&#39;&#39;
    def __init__(self, digits = &#39;123&#39;):
        self.look_and_say = LookAndSay()
        self.split = split_Conway
        self.digits = digits
        self._compendium_sets = []
        self.common_strings = {elt for elt in _CONWAY_ELEMENTS}
        # add transuranic elements to the list of common strings:
        for digit in self.digits:
            if digit not in &#39;123&#39;:
                self.common_strings.add(&#39;31221132221222112112322211&#39; + digit)
                self.common_strings.add(&#39;1311222113321132211221121332211&#39; + digit)

    def days_exotic(self, string):
        &#39;&#39;&#39;
        Returns the number of days until the string splits into a compound of common elements. 
        &#39;&#39;&#39;
        atoms = [atom for atom in self.split(string) if atom not in self.common_strings]
        days = 0
        while atoms != []:
            next_atoms = []
            for atom in atoms:
                new_atoms = self.split(self.look_and_say.say_what_you_see(atom))
                next_atoms += [a for a in new_atoms if a not in self.common_strings]
            atoms = next_atoms
            days += 1
        return days

    def proof(self, day = 9):
        &#39;&#39;&#39;
        Uses a backtracking algorithm to prove Conway&#39;s Cosmological Theorem. If we pass the parameter
        ``day = N`` the algorithm searches for all strings that might appear as chunks of an N-day
        old element. The search starts with strings of length 1 (i.e. the digits) and then 
        searches for strings of length 2, then length 3, etc. For each string found in the search, 
        the algorithm repeatedly applies the say-what-you-see operation until the result is a 
        compound of common elements. The algorithm terminates when for some positive integer L, 
        there are no strings of length L that can appear as chunks of an N-day old element, and 
        all strings of length less than L which might appear as a chunk of an N-day old element 
        are shown to eventually decay into a compound of common elements.

        Running the program prints a few details about the search. In particular, an upper bound
        for the age of an exotic (i.e. not common) element is displayed.  

        The default parameter is ``day = 9``, which results in a proof of the Cosmological Theorem
        that gives an upper bound of 27 for the age of an exotic element. 

        The proof is essentially the same as that of Zeilberger. 
        The implementation is similar to that of Litherland.
        &#39;&#39;&#39;
        chunks = self.digits # start with length 1 chunks
        max_days_exotic = 0

        print(f&#39;To prove the Cosmological Theorem we search for all strings\nwhich could appear as chunks of {day} day old elements.\nSearching...&#39;)
        length = 0
        while True:
            length += 1
            compendium = []
            #Gather all chunks that have a grandparent to the compendium
            for chunk in chunks:
                if self._has_grandparent(chunk, day):
                    compendium.append(chunk)

            if compendium == []:
                print(f&#39;There are no strings of length {length} that can appear as chunks\nof {day} day old elements. All strings of length less than {length}\nthat could appear after {day} days decay into compounds of common\nelements after an additional {max_days_exotic-day} days. This gives an upper\nbound of {max_days_exotic} days for the age of an exotic element.\nQ.E.D.&#39;)
                return max_days_exotic

            self._compendium_sets.append(set(compendium))

            #Compute an upper bound on the maximum longevity of an exotic element:
            for chunk in compendium:
                lifespan = day + self.days_exotic(chunk)
                if lifespan &gt; max_days_exotic:
                    max_days_exotic = lifespan

            chunks = []
            #For each found above, add all possible digits to the left and check if splits
            for digit in self.digits:
                chunks += [digit+chunk for chunk in compendium if len(self.split(digit+chunk)) == 1]

    def _parents(self, kid):
        &#39;&#39;&#39;
        We call a string a *parent* of the kid if applying the say-what-you-see operation
        results in a string which contains the kid as a substring. This function returns
        a list of all the minimal parents of kid (here minimal means that every parent of
        the kid will contain one of the elements of the list as a substring).
        &#39;&#39;&#39;
        parents = []
        if self._is_day_one_even(kid):
            parents += self._even_parents(kid)
        if self._is_day_one_odd(kid):
            parents += self._odd_parents(kid)
        return parents

    def _is_day_one_odd(self, string):
        if len(string) == 1:
            return False
        if len(string) % 2 == 0:
            i = 0
        else:
            i = 1
        while i &lt; len(string) - 2:
            if string[i] == string[i+2]:
                return False
            i += 2
        return True

    def _is_day_one_even(self, string):
        if len(string) == 1:
            return True
        if len(string) % 2 == 0:
            i = 1
        else:
            i = 0
        while i &lt; len(string) - 2:
            if string[i] == string[i+2]:
                return False
            i += 2
        return True

    def _even_parents(self, string):
        new_string = &#39;&#39;
        if len(string) % 2 == 0:
            start = 0
        else:
            start = 1
            new_string += string[0]
        while start &lt; len(string) - 1:
            new_string += int(string[start]) * string[start+1]
            start += 2
        return [new_string]

    def _odd_parents(self, string):
        new_string = &#39;&#39;
        if len(string) % 2 == 0:
            start = 1
            new_string += string[0]
        else:
            start = 0
        while start &lt; len(string) - 2:
            new_string += int(string[start]) * string[start+1]
            start += 2
        return [new_string + int(string[-1]) * digit for digit in self.digits if digit != string[-2]]


    def _has_grandparent(self, kid, day):
        &#39;&#39;&#39;
        Returns True if the string kid *might* be contained in the result of applying
        the say-what-you-see operation day-times to some string. Note that this method
        will only return False when kid cannot be part of a day-old descendant of 
        any string,
        but may return True even if kid is not contained in any day-old descendant.
        &#39;&#39;&#39;
        # To speed things up, we first check the compendium sets:
        # if the kid has a parent who is already in a compendium, we know it&#39;s parent
        # has (possibly) a day-old ancestor, so certainly the kid also (possibly) has one.
        for parent in self._parents(kid):
            if len(parent) &lt; len(self._compendium_sets) and parent in self._compendium_sets[len(parent)]:
                return True

        # Now apply the parents function day-times and see what we get:
        ancestors = [kid]
        for _ in range(day):
            next_ancestors = []
            for a in ancestors:
                next_ancestors += self._parents(a)
            ancestors = next_ancestors

        return len(ancestors) != 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Cosmology.days_exotic"><code class="name flex">
<span>def <span class="ident">days_exotic</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of days until the string splits into a compound of common elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def days_exotic(self, string):
    &#39;&#39;&#39;
    Returns the number of days until the string splits into a compound of common elements. 
    &#39;&#39;&#39;
    atoms = [atom for atom in self.split(string) if atom not in self.common_strings]
    days = 0
    while atoms != []:
        next_atoms = []
        for atom in atoms:
            new_atoms = self.split(self.look_and_say.say_what_you_see(atom))
            next_atoms += [a for a in new_atoms if a not in self.common_strings]
        atoms = next_atoms
        days += 1
    return days</code></pre>
</details>
</dd>
<dt id="look_and_say.Cosmology.proof"><code class="name flex">
<span>def <span class="ident">proof</span></span>(<span>self, day=9)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses a backtracking algorithm to prove Conway's Cosmological Theorem. If we pass the parameter
<code>day = N</code> the algorithm searches for all strings that might appear as chunks of an N-day
old element. The search starts with strings of length 1 (i.e. the digits) and then
searches for strings of length 2, then length 3, etc. For each string found in the search,
the algorithm repeatedly applies the say-what-you-see operation until the result is a
compound of common elements. The algorithm terminates when for some positive integer L,
there are no strings of length L that can appear as chunks of an N-day old element, and
all strings of length less than L which might appear as a chunk of an N-day old element
are shown to eventually decay into a compound of common elements.</p>
<p>Running the program prints a few details about the search. In particular, an upper bound
for the age of an exotic (i.e. not common) element is displayed.
</p>
<p>The default parameter is <code>day = 9</code>, which results in a proof of the Cosmological Theorem
that gives an upper bound of 27 for the age of an exotic element. </p>
<p>The proof is essentially the same as that of Zeilberger.
The implementation is similar to that of Litherland.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proof(self, day = 9):
    &#39;&#39;&#39;
    Uses a backtracking algorithm to prove Conway&#39;s Cosmological Theorem. If we pass the parameter
    ``day = N`` the algorithm searches for all strings that might appear as chunks of an N-day
    old element. The search starts with strings of length 1 (i.e. the digits) and then 
    searches for strings of length 2, then length 3, etc. For each string found in the search, 
    the algorithm repeatedly applies the say-what-you-see operation until the result is a 
    compound of common elements. The algorithm terminates when for some positive integer L, 
    there are no strings of length L that can appear as chunks of an N-day old element, and 
    all strings of length less than L which might appear as a chunk of an N-day old element 
    are shown to eventually decay into a compound of common elements.

    Running the program prints a few details about the search. In particular, an upper bound
    for the age of an exotic (i.e. not common) element is displayed.  

    The default parameter is ``day = 9``, which results in a proof of the Cosmological Theorem
    that gives an upper bound of 27 for the age of an exotic element. 

    The proof is essentially the same as that of Zeilberger. 
    The implementation is similar to that of Litherland.
    &#39;&#39;&#39;
    chunks = self.digits # start with length 1 chunks
    max_days_exotic = 0

    print(f&#39;To prove the Cosmological Theorem we search for all strings\nwhich could appear as chunks of {day} day old elements.\nSearching...&#39;)
    length = 0
    while True:
        length += 1
        compendium = []
        #Gather all chunks that have a grandparent to the compendium
        for chunk in chunks:
            if self._has_grandparent(chunk, day):
                compendium.append(chunk)

        if compendium == []:
            print(f&#39;There are no strings of length {length} that can appear as chunks\nof {day} day old elements. All strings of length less than {length}\nthat could appear after {day} days decay into compounds of common\nelements after an additional {max_days_exotic-day} days. This gives an upper\nbound of {max_days_exotic} days for the age of an exotic element.\nQ.E.D.&#39;)
            return max_days_exotic

        self._compendium_sets.append(set(compendium))

        #Compute an upper bound on the maximum longevity of an exotic element:
        for chunk in compendium:
            lifespan = day + self.days_exotic(chunk)
            if lifespan &gt; max_days_exotic:
                max_days_exotic = lifespan

        chunks = []
        #For each found above, add all possible digits to the left and check if splits
        for digit in self.digits:
            chunks += [digit+chunk for chunk in compendium if len(self.split(digit+chunk)) == 1]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>string, las, decay=[])</span>
</code></dt>
<dd>
<div class="desc"><p>An element consists of a string (usually a chunk of digits) and
a name. For example, in Conway's chemistry there is an element
named H (short for Hydrogen) consisting of the string '22'.
Each element decays into a list of other elements.
The only methods for this class are getters and a setter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element():
    &#34;&#34;&#34;
    An element consists of a string (usually a chunk of digits) and 
    a name. For example, in Conway&#39;s chemistry there is an element
    named H (short for Hydrogen) consisting of the string &#39;22&#39;. 
    Each element decays into a list of other elements. 
    The only methods for this class are getters and a setter.
    &#34;&#34;&#34;
    def __init__(self, string, las, decay = []):
        super(Element, self).__init__()
        self.string = string
        self.las = las
        self.name = string
        self.decay = decay

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        if isinstance(other, Element):
                return self.string == other.string and self.las == other.las
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        return hash(tuple(sorted(self.__dict__.items())))

    def _set_decay(self, elements):
        self.decay = elements

    def get_decay(self):
        return self.decay

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def get_string(self):
        return self.string</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Element.get_decay"><code class="name flex">
<span>def <span class="ident">get_decay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decay(self):
    return self.decay</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    return self.name</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.get_string"><code class="name flex">
<span>def <span class="ident">get_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string(self):
    return self.string</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    self.name = name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.LookAndSay"><code class="flex name class">
<span>class <span class="ident">LookAndSay</span></span>
<span>(</span><span>say=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class responsible for the fundamental say-what-you-see operation
that generates a look and say sequence. The parameter <code>say</code> in the
constructor is a function that determines the decay of a chunk of the form
<span><span class="MathJax_Preview">a^b</span><script type="math/tex">a^b</script></span>. The say function can have one or two parameters:</p>
<ul>
<li>If the say function accepts one parameter, the LookAndSay object will correspond to the decay <span><span class="MathJax_Preview">a^b\to say(b)a</span><script type="math/tex">a^b\to say(b)a</script></span>.</li>
<li>If the say function accepts two parameters, the LookAndSay object will correspond to the decay <span><span class="MathJax_Preview">a^b\to say(b, a)</span><script type="math/tex">a^b\to say(b, a)</script></span>.</li>
</ul>
<p>When no parameter is passed to the constructor, the LookAndSay
object will correspond to standard base ten look and say sequences.</p>
<h2 id="example-session-default-constructor">Example Session: Default Constructor.</h2>
<p>The following example uses the default (standard) look and say sequences.
Note that the ratios of lengths are approaching Conway's constant.</p>
<pre><code class="language-python">&gt;&gt;&gt; ls = LookAndSay()  
&gt;&gt;&gt; ls.generate_sequence('55555', 35)
&gt;&gt;&gt; sequence = ls.get_sequence()
&gt;&gt;&gt; first_terms = sequence[:10]
&gt;&gt;&gt; 
&gt;&gt;&gt; print('Sequence:', first_terms)
Sequence: ['55555', '55', '25', '1215', '11121115', '31123115', '132112132115', '11131221121113122115', '311311222112311311222115', '1321132132211213211321322115']
&gt;&gt;&gt; 
&gt;&gt;&gt; print('Ratios of lengths:', ls.get_length_ratios())
Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331]
&gt;&gt;&gt; 
&gt;&gt;&gt; print('Just the last ratio:', ls.get_last_length_ratio())
Just the last ratio: 1.312784588441331

</code></pre>
<h2 id="example-sessions-one-parameter-say-functions">Example Sessions: One parameter say functions</h2>
<p>Here is an implementation of a Roman look and say:</p>
<pre><code class="language-python">&gt;&gt;&gt; def roman_say(num):
...     assert num &lt; 10, &quot;This Roman can only count to 9.&quot;
...     roman = {1:'I', 2:'II', 3:'III', 4:'IV', 5:'V', 6:'VI', 7:'VII', 8:'VIII', 9:'IX'}
...     return roman[num]
... 
&gt;&gt;&gt; roman_ls = LookAndSay(roman_say)
&gt;&gt;&gt; 
&gt;&gt;&gt; roman_ls.generate_sequence('I', 10)
&gt;&gt;&gt; print(roman_ls.get_sequence())
['I', 'II', 'III', 'IIII', 'IVI', 'IIIVII', 'IIIIIVIII', 'VIIVIIII', 'IVIIIIVIVI', 'IIIVIVIIVIIIVII', 'IIIIIVIIIVIIIIVIIIIIVIII']
&gt;&gt;&gt; 
&gt;&gt;&gt; roman_ls.generate_sequence('V', 10)
&gt;&gt;&gt; print(roman_ls.get_sequence())
['V', 'IV', 'IIIV', 'IIIIIV', 'VIIV', 'IVIIIIV', 'IIIVIVIIV', 'IIIIIVIIIVIIIIV', 'VIIVIIIIIVIVIIV', 'IVIIIIVVIIVIIIVIIIIV', 'IIIVIVIIIVIIIIVIIIIIVIVIIV']

</code></pre>
<p>Here is a standard binary look and say:</p>
<pre><code class="language-python">&gt;&gt;&gt; def binary_say(num):
...     return &quot;{0:b}&quot;.format(num)
... 
&gt;&gt;&gt; binary_ls = LookAndSay(binary_say)
&gt;&gt;&gt; 
&gt;&gt;&gt; binary_ls.generate_sequence('0', 9)
&gt;&gt;&gt; print(binary_ls.get_sequence())
['0', '10', '1110', '11110', '100110', '1110010110', '111100111010110', '100110011110111010110', '1110010110010011011110111010110', '1111001110101100111001011010011011110111010110']
&gt;&gt;&gt; 
&gt;&gt;&gt; binary_ls.generate_sequence('1', 9)
&gt;&gt;&gt; print(binary_ls.get_sequence())
['1', '11', '101', '111011', '11110101', '100110111011', '111001011011110101', '111100111010110100110111011', '100110011110111010110111001011011110101', '1110010110010011011110111010110111100111010110100110111011']

</code></pre>
<h2 id="example-sessions-two-parameter-say-functions">Example Sessions: Two parameter say functions</h2>
<p>Here is a <em>look-and-say-again</em> from the paper <a href="https://arxiv.org/abs/2006.06837"><em>Stuttering Conway Sequences Are Still Conway Sequences</em> by Brier et al</a>.
The say function for this example corresponds to the decay <span><span class="MathJax_Preview">a^b\to bbaa</span><script type="math/tex">a^b\to bbaa</script></span>.</p>
<pre><code class="language-python">&gt;&gt;&gt; def say_again(char_count, char):
...     return 2 * str(char_count) + 2 * char
... 
&gt;&gt;&gt; look_and_say_again = LookAndSay(say_again)
&gt;&gt;&gt; 
&gt;&gt;&gt; look_and_say_again.generate_sequence('1', 10)
&gt;&gt;&gt; print(look_and_say_again.get_sequence())
['1', '1111', '4411', '22442211', '2222224422222211', '6622224466222211', '226644222244226644222211', '2222226622444422224422222266224444222211', '662222662222444444222244662222662222444444222211', '22664422226644226644442222442266442222664422664444222211', '2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211']
&gt;&gt;&gt; 
&gt;&gt;&gt; look_and_say_again.generate_sequence('2', 10)
&gt;&gt;&gt; print(look_and_say_again.get_sequence())
['2', '1122', '22112222', '222222114422', '6622221122442222', '226644222211222222444422', '22222266224444222211662244442222', '6622226622224444442222112266222244444422', '226644222266442266444422221122222266442266442222', '222222662244442222662244222222664444442222116622226622442222226622444422', '66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222']

</code></pre>
<p>Here is <a href="https://www.cambridge.org/core/journals/bulletin-of-the-australian-mathematical-society/article/abs/look-knave/BFC51822DED97095C96ABD2255AEDC2A">Morrill's <em>Look Knave</em></a>:</p>
<pre><code class="language-python">&gt;&gt;&gt; def knave_say(bit_count, bit):
...     flip = {'0':'1', '1':'0'}
...     return &quot;{0:b}&quot;.format(bit_count) + flip[bit]
... 
&gt;&gt;&gt; look_knave = LookAndSay(knave_say)
&gt;&gt;&gt; 
&gt;&gt;&gt; look_knave.generate_sequence('0', 12)
&gt;&gt;&gt; print(look_knave.get_sequence())
['0', '11', '100', '10101', '1011101110', '10111101111011', '1011100011100011100', '1011110111110111110101', '1011100011101011101011101110', '10111101111101110111101110111101111011', '10111000111010111101110001111011100011100011100', '1011110111110111011100011110111100011110111110111110101', '1011100011101011110111101111000111000111100011101011101011101110']
&gt;&gt;&gt; 
&gt;&gt;&gt; look_knave.generate_sequence('1', 12)
&gt;&gt;&gt; print(look_knave.get_sequence())
['1', '10', '1011', '1011100', '1011110101', '1011100011101110', '10111101111101111011', '1011100011101011100011100', '1011110111110111011110111110101', '101110001110101111011100011101011101110', '10111101111101110111000111101111101110111101111011', '10111000111010111101111011110001110101111011100011100011100', '10111101111101110111000111000111000111110111011100011110111110111110101']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LookAndSay():
    &#34;&#34;&#34;
    A class responsible for the fundamental say-what-you-see operation
    that generates a look and say sequence. The parameter ``say`` in the
    constructor is a function that determines the decay of a chunk of the form
    \\(a^b\\). The say function can have one or two parameters:

    * If the say function accepts one parameter, the LookAndSay object will correspond to the decay \\(a^b\\to say(b)a\\).
    * If the say function accepts two parameters, the LookAndSay object will correspond to the decay \\(a^b\\to say(b, a)\\).

    When no parameter is passed to the constructor, the LookAndSay
    object will correspond to standard base ten look and say sequences.

    
    ## Example Session: Default Constructor. 
    The following example uses the default (standard) look and say sequences.
    Note that the ratios of lengths are approaching Conway&#39;s constant.
    ```python 
    &gt;&gt;&gt; ls = LookAndSay()  
    &gt;&gt;&gt; ls.generate_sequence(&#39;55555&#39;, 35)
    &gt;&gt;&gt; sequence = ls.get_sequence()
    &gt;&gt;&gt; first_terms = sequence[:10]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(&#39;Sequence:&#39;, first_terms)
    Sequence: [&#39;55555&#39;, &#39;55&#39;, &#39;25&#39;, &#39;1215&#39;, &#39;11121115&#39;, &#39;31123115&#39;, &#39;132112132115&#39;, &#39;11131221121113122115&#39;, &#39;311311222112311311222115&#39;, &#39;1321132132211213211321322115&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(&#39;Ratios of lengths:&#39;, ls.get_length_ratios())
    Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; print(&#39;Just the last ratio:&#39;, ls.get_last_length_ratio())
    Just the last ratio: 1.312784588441331

    ```

    ## Example Sessions: One parameter say functions

    Here is an implementation of a Roman look and say:
    ```python
    &gt;&gt;&gt; def roman_say(num):
    ...     assert num &lt; 10, &#34;This Roman can only count to 9.&#34;
    ...     roman = {1:&#39;I&#39;, 2:&#39;II&#39;, 3:&#39;III&#39;, 4:&#39;IV&#39;, 5:&#39;V&#39;, 6:&#39;VI&#39;, 7:&#39;VII&#39;, 8:&#39;VIII&#39;, 9:&#39;IX&#39;}
    ...     return roman[num]
    ... 
    &gt;&gt;&gt; roman_ls = LookAndSay(roman_say)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; roman_ls.generate_sequence(&#39;I&#39;, 10)
    &gt;&gt;&gt; print(roman_ls.get_sequence())
    [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IIII&#39;, &#39;IVI&#39;, &#39;IIIVII&#39;, &#39;IIIIIVIII&#39;, &#39;VIIVIIII&#39;, &#39;IVIIIIVIVI&#39;, &#39;IIIVIVIIVIIIVII&#39;, &#39;IIIIIVIIIVIIIIVIIIIIVIII&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; roman_ls.generate_sequence(&#39;V&#39;, 10)
    &gt;&gt;&gt; print(roman_ls.get_sequence())
    [&#39;V&#39;, &#39;IV&#39;, &#39;IIIV&#39;, &#39;IIIIIV&#39;, &#39;VIIV&#39;, &#39;IVIIIIV&#39;, &#39;IIIVIVIIV&#39;, &#39;IIIIIVIIIVIIIIV&#39;, &#39;VIIVIIIIIVIVIIV&#39;, &#39;IVIIIIVVIIVIIIVIIIIV&#39;, &#39;IIIVIVIIIVIIIIVIIIIIVIVIIV&#39;]

    ```

    Here is a standard binary look and say:
    ```python
    &gt;&gt;&gt; def binary_say(num):
    ...     return &#34;{0:b}&#34;.format(num)
    ... 
    &gt;&gt;&gt; binary_ls = LookAndSay(binary_say)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; binary_ls.generate_sequence(&#39;0&#39;, 9)
    &gt;&gt;&gt; print(binary_ls.get_sequence())
    [&#39;0&#39;, &#39;10&#39;, &#39;1110&#39;, &#39;11110&#39;, &#39;100110&#39;, &#39;1110010110&#39;, &#39;111100111010110&#39;, &#39;100110011110111010110&#39;, &#39;1110010110010011011110111010110&#39;, &#39;1111001110101100111001011010011011110111010110&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; binary_ls.generate_sequence(&#39;1&#39;, 9)
    &gt;&gt;&gt; print(binary_ls.get_sequence())
    [&#39;1&#39;, &#39;11&#39;, &#39;101&#39;, &#39;111011&#39;, &#39;11110101&#39;, &#39;100110111011&#39;, &#39;111001011011110101&#39;, &#39;111100111010110100110111011&#39;, &#39;100110011110111010110111001011011110101&#39;, &#39;1110010110010011011110111010110111100111010110100110111011&#39;]

    ```
    
    ## Example Sessions: Two parameter say functions

    Here is a *look-and-say-again* from the paper [*Stuttering Conway Sequences Are Still Conway Sequences* by Brier et al](https://arxiv.org/abs/2006.06837).
    The say function for this example corresponds to the decay \\(a^b\\to bbaa\\).
    ```python
    &gt;&gt;&gt; def say_again(char_count, char):
    ...     return 2 * str(char_count) + 2 * char
    ... 
    &gt;&gt;&gt; look_and_say_again = LookAndSay(say_again)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_and_say_again.generate_sequence(&#39;1&#39;, 10)
    &gt;&gt;&gt; print(look_and_say_again.get_sequence())
    [&#39;1&#39;, &#39;1111&#39;, &#39;4411&#39;, &#39;22442211&#39;, &#39;2222224422222211&#39;, &#39;6622224466222211&#39;, &#39;226644222244226644222211&#39;, &#39;2222226622444422224422222266224444222211&#39;, &#39;662222662222444444222244662222662222444444222211&#39;, &#39;22664422226644226644442222442266442222664422664444222211&#39;, &#39;2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_and_say_again.generate_sequence(&#39;2&#39;, 10)
    &gt;&gt;&gt; print(look_and_say_again.get_sequence())
    [&#39;2&#39;, &#39;1122&#39;, &#39;22112222&#39;, &#39;222222114422&#39;, &#39;6622221122442222&#39;, &#39;226644222211222222444422&#39;, &#39;22222266224444222211662244442222&#39;, &#39;6622226622224444442222112266222244444422&#39;, &#39;226644222266442266444422221122222266442266442222&#39;, &#39;222222662244442222662244222222664444442222116622226622442222226622444422&#39;, &#39;66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222&#39;]

    ```

    Here is [Morrill&#39;s *Look Knave*](https://www.cambridge.org/core/journals/bulletin-of-the-australian-mathematical-society/article/abs/look-knave/BFC51822DED97095C96ABD2255AEDC2A):
    ```python
    &gt;&gt;&gt; def knave_say(bit_count, bit):
    ...     flip = {&#39;0&#39;:&#39;1&#39;, &#39;1&#39;:&#39;0&#39;}
    ...     return &#34;{0:b}&#34;.format(bit_count) + flip[bit]
    ... 
    &gt;&gt;&gt; look_knave = LookAndSay(knave_say)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_knave.generate_sequence(&#39;0&#39;, 12)
    &gt;&gt;&gt; print(look_knave.get_sequence())
    [&#39;0&#39;, &#39;11&#39;, &#39;100&#39;, &#39;10101&#39;, &#39;1011101110&#39;, &#39;10111101111011&#39;, &#39;1011100011100011100&#39;, &#39;1011110111110111110101&#39;, &#39;1011100011101011101011101110&#39;, &#39;10111101111101110111101110111101111011&#39;, &#39;10111000111010111101110001111011100011100011100&#39;, &#39;1011110111110111011100011110111100011110111110111110101&#39;, &#39;1011100011101011110111101111000111000111100011101011101011101110&#39;]
    &gt;&gt;&gt; 
    &gt;&gt;&gt; look_knave.generate_sequence(&#39;1&#39;, 12)
    &gt;&gt;&gt; print(look_knave.get_sequence())
    [&#39;1&#39;, &#39;10&#39;, &#39;1011&#39;, &#39;1011100&#39;, &#39;1011110101&#39;, &#39;1011100011101110&#39;, &#39;10111101111101111011&#39;, &#39;1011100011101011100011100&#39;, &#39;1011110111110111011110111110101&#39;, &#39;101110001110101111011100011101011101110&#39;, &#39;10111101111101110111000111101111101110111101111011&#39;, &#39;10111000111010111101111011110001110101111011100011100011100&#39;, &#39;10111101111101110111000111000111000111110111011100011110111110111110101&#39;]

    ```
    &#34;&#34;&#34;
    def __init__(self, say = None):
        super(LookAndSay, self).__init__()
        self._is_Conway = False
        if say == None:
            say = (lambda n : str(n))
            self._is_Conway = True
        self.say = say
        self.sequence = []

    def _chunk_op(self, char_count, char):
        &#34;&#34;&#34;
        Conversion of the say function to a two parameter function 
        if the say function takes only one parameter; 
        just a copy of the say function otherwise.
        &#34;&#34;&#34;
        try:
            return self.say(char_count, char)
        except:
            return self.say(char_count) + char

    def get_sequence(self):
        &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
        return self.sequence

    def say_what_you_see(self, string):
        &#34;&#34;&#34;
        The fundamental look and say operation that generates each 
        term of a look and say sequence from its predecessor. For example, 
        using the standard (default) LookAndSay object, 
        ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
        &#34;&#34;&#34;
        if not string: return None # handles empty string, which is falsy
        letter = string[0]
        result = &#39;&#39;
        count = 0
        for ch in string:
            if ch == letter: 
                count += 1
            else:
                result += self._chunk_op(count, letter)
                count = 1
                letter = ch 
        result += self._chunk_op(count, letter)
        return result
     
    def generate_sequence(self, seed, num_iterations):
        &#34;&#34;&#34;
        Generates the look and say sequence. The parameter ``seed`` is 
        the initial term in the sequence, and ``num_iterations`` is the 
        number of terms generated.
        &#34;&#34;&#34;
        if not seed: return None # handles empty seed, which is falsy
        result = [seed]
        for _ in range(num_iterations):
            result.append(self.say_what_you_see(result[-1]))
        self.sequence = result

    def get_length_ratios(self):
        &#34;&#34;&#34;
        Returns a list of the ratios of lengths of 
        successive terms in the look and say sequence.
        &#34;&#34;&#34;
        num_iterations = len(self.sequence)
        assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
        return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]

    def get_last_length_ratio(self):
        &#34;&#34;&#34;
        Returns the ratio of the lengths of the last 
        two terms of the look and say sequence
        &#34;&#34;&#34;
        return self.get_length_ratios()[-1]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.LookAndSay.generate_sequence"><code class="name flex">
<span>def <span class="ident">generate_sequence</span></span>(<span>self, seed, num_iterations)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the look and say sequence. The parameter <code>seed</code> is
the initial term in the sequence, and <code>num_iterations</code> is the
number of terms generated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_sequence(self, seed, num_iterations):
    &#34;&#34;&#34;
    Generates the look and say sequence. The parameter ``seed`` is 
    the initial term in the sequence, and ``num_iterations`` is the 
    number of terms generated.
    &#34;&#34;&#34;
    if not seed: return None # handles empty seed, which is falsy
    result = [seed]
    for _ in range(num_iterations):
        result.append(self.say_what_you_see(result[-1]))
    self.sequence = result</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_last_length_ratio"><code class="name flex">
<span>def <span class="ident">get_last_length_ratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ratio of the lengths of the last
two terms of the look and say sequence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_length_ratio(self):
    &#34;&#34;&#34;
    Returns the ratio of the lengths of the last 
    two terms of the look and say sequence
    &#34;&#34;&#34;
    return self.get_length_ratios()[-1]</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_length_ratios"><code class="name flex">
<span>def <span class="ident">get_length_ratios</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the ratios of lengths of
successive terms in the look and say sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length_ratios(self):
    &#34;&#34;&#34;
    Returns a list of the ratios of lengths of 
    successive terms in the look and say sequence.
    &#34;&#34;&#34;
    num_iterations = len(self.sequence)
    assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
    return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_sequence"><code class="name flex">
<span>def <span class="ident">get_sequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the look and say sequence as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequence(self):
    &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
    return self.sequence</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.say_what_you_see"><code class="name flex">
<span>def <span class="ident">say_what_you_see</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>The fundamental look and say operation that generates each
term of a look and say sequence from its predecessor. For example,
using the standard (default) LookAndSay object,
<code>say_what_you_see('1112222333')</code> returns <code>'314233'</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def say_what_you_see(self, string):
    &#34;&#34;&#34;
    The fundamental look and say operation that generates each 
    term of a look and say sequence from its predecessor. For example, 
    using the standard (default) LookAndSay object, 
    ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
    &#34;&#34;&#34;
    if not string: return None # handles empty string, which is falsy
    letter = string[0]
    result = &#39;&#39;
    count = 0
    for ch in string:
        if ch == letter: 
            count += 1
        else:
            result += self._chunk_op(count, letter)
            count = 1
            letter = ch 
    result += self._chunk_op(count, letter)
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.SplitFuncFactory"><code class="flex name class">
<span>class <span class="ident">SplitFuncFactory</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to help create a split function. The split function factory
can produce a split function via any combination of the following:</p>
<ul>
<li>Specifying specific chunks L and R such that LR splits as L.R.</li>
<li>Specifying specific characters or chunks to always split before or after.</li>
</ul>
<h2 id="example-session-split-after-0">Example Session: Split after 0</h2>
<p>Many look and say sequences split after any run of 0's.
The following illustrates how the split function factory can
be used to create such a split function:</p>
<pre><code class="language-python">&gt;&gt;&gt; sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_after('0')
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; string = '1101230022200012301325023'
&gt;&gt;&gt; print(split(string))
['110', '12300', '222000', '1230', '13250', '23']

</code></pre>
<h2 id="example-session-a-combination-of-multiple-methods">Example Session: A combination of multiple methods.</h2>
<pre><code class="language-python">&gt;&gt;&gt; sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_before('111')
&gt;&gt;&gt; sff.declare_split_after('2', '30')
&gt;&gt;&gt; sff.declare_splitting_pairs(('11', '333'))
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; string = '1234411154211333234530411113333344'
&gt;&gt;&gt; print(split(string))
['12', '344', '111542', '11', '3332', '34530', '4', '1111', '3333344']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SplitFuncFactory():
    &#34;&#34;&#34;
    A class to help create a split function. The split function factory
    can produce a split function via any combination of the following:

    * Specifying specific chunks L and R such that LR splits as L.R.
    * Specifying specific characters or chunks to always split before or after.

    ## Example Session: Split after 0
    Many look and say sequences split after any run of 0&#39;s. 
    The following illustrates how the split function factory can 
    be used to create such a split function:
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;0&#39;)
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;1101230022200012301325023&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;110&#39;, &#39;12300&#39;, &#39;222000&#39;, &#39;1230&#39;, &#39;13250&#39;, &#39;23&#39;]

    ```


    ## Example Session: A combination of multiple methods.
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_before(&#39;111&#39;)
    &gt;&gt;&gt; sff.declare_split_after(&#39;2&#39;, &#39;30&#39;)
    &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;11&#39;, &#39;333&#39;))
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;1234411154211333234530411113333344&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;12&#39;, &#39;344&#39;, &#39;111542&#39;, &#39;11&#39;, &#39;3332&#39;, &#39;34530&#39;, &#39;4&#39;, &#39;1111&#39;, &#39;3333344&#39;]

    ```
    &#34;&#34;&#34;
    def __init__(self):
        self._splitting_pairs = []
        self._chunks_before_split = []
        self._chunks_after_split = []
        self._split_conditions = []

    def get_split(self):
        &#34;&#34;&#34;Returns the split function.&#34;&#34;&#34;
        return lambda string : self._split(string)

    def _split(self, string):
        chunks = []
        start = 0
        for i in range(1, len(string)):
            if self._is_split(string[start:i], string[i:]):
                chunks.append(string[start:i])
                start = i
        chunks.append(string[start:])
        return chunks

    def _is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
            return True
        if L[-1] == R[0]:
            return False
        for l in self._chunks_before_split:
            if len(l) &lt;= len(L) and l == L[-len(l):]:
                return True
        for r in self._chunks_after_split:
            if len(r) &lt;= len(R) and r == R[:len(r)]:
                return True
        for l, r in self._splitting_pairs:
            if len(l) &lt;= len(L) and len(r) &lt;= len(R) and l == L[-len(l):] and r == R[:len(r)]:
                return True
        for condition in self._split_conditions:
            if condition(L, R):
                return True
        return False

    def declare_splitting_pairs(self, *pairs):
        &#34;&#34;&#34;
        Specify pairs of chunks in the form (L, R) 
        such that LR always splits as L.R.

        ## Example Session:
        ```python
        &gt;&gt;&gt; sff = SplitFuncFactory()
        &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;311&#39;, &#39;223&#39;), (&#39;0&#39;, &#39;1&#39;))
        &gt;&gt;&gt; split = sff.get_split()
        &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
        &gt;&gt;&gt; print(split(string))
        [&#39;12311&#39;, &#39;2233231120&#39;, &#39;112000&#39;, &#39;11110234234&#39;]

        ```
        &#34;&#34;&#34;
        for pair in pairs:
            self._splitting_pairs.append(pair)

    def declare_split_after(self, *chunks):
        &#34;&#34;&#34;
        Specify chunks L such that LR splits for every possible R (assuming the last character of L and the first character of R are distinct).
        
        ## Example Session:
        ```python
        &gt;&gt;&gt; sff = SplitFuncFactory()
        &gt;&gt;&gt; sff.declare_split_after(&#39;1&#39;, &#39;20&#39;)
        &gt;&gt;&gt; split = sff.get_split()
        &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
        &gt;&gt;&gt; print(split(string))
        [&#39;1&#39;, &#39;2311&#39;, &#39;22332311&#39;, &#39;20&#39;, &#39;11&#39;, &#39;20001111&#39;, &#39;0234234&#39;]

        ```
        &#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_before_split.append(chunk)

    def declare_split_before(self, *chunks):
        &#34;&#34;&#34;Specify chunks R such that LR splits for every possible L (assuming the last character of L and the first character of R are distinct).

        ## Example Session:
        ```python
        &gt;&gt;&gt; sff = SplitFuncFactory()
        &gt;&gt;&gt; sff.declare_split_before(&#39;0&#39;, &#39;31&#39;)
        &gt;&gt;&gt; split = sff.get_split()
        &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
        &gt;&gt;&gt; print(split(string))
        [&#39;12&#39;, &#39;31122332&#39;, &#39;3112&#39;, &#39;0112&#39;, &#39;0001111&#39;, &#39;0234234&#39;]

        ```
        &#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_after_split.append(chunk)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.SplitFuncFactory.declare_split_after"><code class="name flex">
<span>def <span class="ident">declare_split_after</span></span>(<span>self, *chunks)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify chunks L such that LR splits for every possible R (assuming the last character of L and the first character of R are distinct).</p>
<h2 id="example-session">Example Session:</h2>
<pre><code class="language-python">&gt;&gt;&gt; sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_after('1', '20')
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; string = '12311223323112011200011110234234'
&gt;&gt;&gt; print(split(string))
['1', '2311', '22332311', '20', '11', '20001111', '0234234']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_split_after(self, *chunks):
    &#34;&#34;&#34;
    Specify chunks L such that LR splits for every possible R (assuming the last character of L and the first character of R are distinct).
    
    ## Example Session:
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_after(&#39;1&#39;, &#39;20&#39;)
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;1&#39;, &#39;2311&#39;, &#39;22332311&#39;, &#39;20&#39;, &#39;11&#39;, &#39;20001111&#39;, &#39;0234234&#39;]

    ```
    &#34;&#34;&#34;
    for chunk in chunks:
        self._chunks_before_split.append(chunk)</code></pre>
</details>
</dd>
<dt id="look_and_say.SplitFuncFactory.declare_split_before"><code class="name flex">
<span>def <span class="ident">declare_split_before</span></span>(<span>self, *chunks)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify chunks R such that LR splits for every possible L (assuming the last character of L and the first character of R are distinct).</p>
<h2 id="example-session">Example Session:</h2>
<pre><code class="language-python">&gt;&gt;&gt; sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_split_before('0', '31')
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; string = '12311223323112011200011110234234'
&gt;&gt;&gt; print(split(string))
['12', '31122332', '3112', '0112', '0001111', '0234234']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_split_before(self, *chunks):
    &#34;&#34;&#34;Specify chunks R such that LR splits for every possible L (assuming the last character of L and the first character of R are distinct).

    ## Example Session:
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_split_before(&#39;0&#39;, &#39;31&#39;)
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;12&#39;, &#39;31122332&#39;, &#39;3112&#39;, &#39;0112&#39;, &#39;0001111&#39;, &#39;0234234&#39;]

    ```
    &#34;&#34;&#34;
    for chunk in chunks:
        self._chunks_after_split.append(chunk)</code></pre>
</details>
</dd>
<dt id="look_and_say.SplitFuncFactory.declare_splitting_pairs"><code class="name flex">
<span>def <span class="ident">declare_splitting_pairs</span></span>(<span>self, *pairs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify pairs of chunks in the form (L, R)
such that LR always splits as L.R.</p>
<h2 id="example-session">Example Session:</h2>
<pre><code class="language-python">&gt;&gt;&gt; sff = SplitFuncFactory()
&gt;&gt;&gt; sff.declare_splitting_pairs(('311', '223'), ('0', '1'))
&gt;&gt;&gt; split = sff.get_split()
&gt;&gt;&gt; string = '12311223323112011200011110234234'
&gt;&gt;&gt; print(split(string))
['12311', '2233231120', '112000', '11110234234']

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_splitting_pairs(self, *pairs):
    &#34;&#34;&#34;
    Specify pairs of chunks in the form (L, R) 
    such that LR always splits as L.R.

    ## Example Session:
    ```python
    &gt;&gt;&gt; sff = SplitFuncFactory()
    &gt;&gt;&gt; sff.declare_splitting_pairs((&#39;311&#39;, &#39;223&#39;), (&#39;0&#39;, &#39;1&#39;))
    &gt;&gt;&gt; split = sff.get_split()
    &gt;&gt;&gt; string = &#39;12311223323112011200011110234234&#39;
    &gt;&gt;&gt; print(split(string))
    [&#39;12311&#39;, &#39;2233231120&#39;, &#39;112000&#39;, &#39;11110234234&#39;]

    ```
    &#34;&#34;&#34;
    for pair in pairs:
        self._splitting_pairs.append(pair)</code></pre>
</details>
</dd>
<dt id="look_and_say.SplitFuncFactory.get_split"><code class="name flex">
<span>def <span class="ident">get_split</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the split function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_split(self):
    &#34;&#34;&#34;Returns the split function.&#34;&#34;&#34;
    return lambda string : self._split(string)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#example-sessions">Example Sessions</a><ul>
<li><a href="#standard-decimal">Standard decimal</a></li>
<li><a href="#gray-code">Gray code</a></li>
<li><a href="#standard-ternary">Standard ternary</a></li>
</ul>
</li>
<li><a href="#projects-that-used-the-look_and_say-module">Projects that used the look_and_say module</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="look_and_say.split_Conway" href="#look_and_say.split_Conway">split_Conway</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="look_and_say.BinaryChemistry" href="#look_and_say.BinaryChemistry">BinaryChemistry</a></code></h4>
</li>
<li>
<h4><code><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Chemistry.clear_elements" href="#look_and_say.Chemistry.clear_elements">clear_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.generate_elements" href="#look_and_say.Chemistry.generate_elements">generate_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_char_poly" href="#look_and_say.Chemistry.get_char_poly">get_char_poly</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_decay_matrix" href="#look_and_say.Chemistry.get_decay_matrix">get_decay_matrix</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_elements" href="#look_and_say.Chemistry.get_elements">get_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_max_eigenvalue" href="#look_and_say.Chemistry.get_max_eigenvalue">get_max_eigenvalue</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_periodic_table" href="#look_and_say.Chemistry.get_periodic_table">get_periodic_table</a></code></li>
<li><code><a title="look_and_say.Chemistry.order_elements" href="#look_and_say.Chemistry.order_elements">order_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.print_periodic_table" href="#look_and_say.Chemistry.print_periodic_table">print_periodic_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.Cosmology" href="#look_and_say.Cosmology">Cosmology</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Cosmology.days_exotic" href="#look_and_say.Cosmology.days_exotic">days_exotic</a></code></li>
<li><code><a title="look_and_say.Cosmology.proof" href="#look_and_say.Cosmology.proof">proof</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.Element" href="#look_and_say.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Element.get_decay" href="#look_and_say.Element.get_decay">get_decay</a></code></li>
<li><code><a title="look_and_say.Element.get_name" href="#look_and_say.Element.get_name">get_name</a></code></li>
<li><code><a title="look_and_say.Element.get_string" href="#look_and_say.Element.get_string">get_string</a></code></li>
<li><code><a title="look_and_say.Element.set_name" href="#look_and_say.Element.set_name">set_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.LookAndSay" href="#look_and_say.LookAndSay">LookAndSay</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.LookAndSay.generate_sequence" href="#look_and_say.LookAndSay.generate_sequence">generate_sequence</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_last_length_ratio" href="#look_and_say.LookAndSay.get_last_length_ratio">get_last_length_ratio</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_length_ratios" href="#look_and_say.LookAndSay.get_length_ratios">get_length_ratios</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_sequence" href="#look_and_say.LookAndSay.get_sequence">get_sequence</a></code></li>
<li><code><a title="look_and_say.LookAndSay.say_what_you_see" href="#look_and_say.LookAndSay.say_what_you_see">say_what_you_see</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.SplitFuncFactory" href="#look_and_say.SplitFuncFactory">SplitFuncFactory</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.SplitFuncFactory.declare_split_after" href="#look_and_say.SplitFuncFactory.declare_split_after">declare_split_after</a></code></li>
<li><code><a title="look_and_say.SplitFuncFactory.declare_split_before" href="#look_and_say.SplitFuncFactory.declare_split_before">declare_split_before</a></code></li>
<li><code><a title="look_and_say.SplitFuncFactory.declare_splitting_pairs" href="#look_and_say.SplitFuncFactory.declare_splitting_pairs">declare_splitting_pairs</a></code></li>
<li><code><a title="look_and_say.SplitFuncFactory.get_split" href="#look_and_say.SplitFuncFactory.get_split">get_split</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>