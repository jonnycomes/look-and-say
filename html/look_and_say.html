<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>look_and_say API documentation</title>
<meta name="description" content="A module for playing with look and say sequences in the spirit of John Conway." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>look_and_say</code></h1>
</header>
<section id="section-intro">
<p>A module for playing with look and say sequences in the spirit of John Conway.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    A module for playing with look and say sequences in the spirit of John Conway.
&#34;&#34;&#34;

import numpy
import sympy

################## Conway&#39;s Conventions ############################

def split_Conway(string):
    &#34;&#34;&#34;
    Splits a string into a list of substrings according to Conway&#39;s Splitting Theorem.
    Assumes the string is not empty. 

    ## Example Session:
    ```python
    string = &#39;1211132213&#39;
    chunks = split_Conway(string)
    print(chunks)
    ```
    ### Output:

    ```sh
    [&#39;12&#39;, &#39;1113&#39;, &#39;22&#39;, &#39;13&#39;]
    ```
    &#34;&#34;&#34;
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if _is_split_pair_Conway(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks

def _is_split_pair_Conway(L, R):
    &#34;&#34;&#34;Implementation of Conway&#39;s Splitting Theorem&#34;&#34;&#34;
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    if L[-1] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and R[0] in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]: # n] and [m
            return True
    if L[-1] == &#39;2&#39;: # 2]
            if len(R) &gt; 1 and R[0] == &#39;1&#39; and R[1] != &#39;1&#39; and (len(R) == 2 or R[2] != R[1]): #[1^1X^1
                    return True
            if len(R) &gt; 2 and R[0] == &#39;1&#39; and R[1] == &#39;1&#39; and R[2] == &#39;1&#39; and (len(R) == 3 or R[3] != &#39;1&#39;): #[1^3
                    return True
            if R[0] == &#39;3&#39; and (len(R) == 1 or (R[1] != &#39;3&#39; and (len(R) &lt; 4 or R[2] != R[1] or R[3] != R[1]))): #[3^1X^\not=3
                    return True
            if R[0] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 1 or R[1] != R[0]): #[n^1
                    return True
    if L[-1] != &#39;2&#39; and len(R) &gt; 1 and R[0] == &#39;2&#39; and R[1] == &#39;2&#39;: # \not=2]
            if len(R) &gt; 3 and R[2] == &#39;1&#39; and R[3] != &#39;1&#39; and (len(R) == 4 or R[4] != R[3]): #[2^21^1X^1
                    return True
            if len(R) &gt; 4 and R[2] == &#39;1&#39; and R[3] == &#39;1&#39; and R[4] == &#39;1&#39; and (len(R) == 5 or R[5] != &#39;1&#39;): #[2^21^3
                    return True
            if len(R) &gt; 2 and R[2] == &#39;3&#39; and (len(R) == 3 or (R[3] != &#39;3&#39; and (len(R) &lt; 6 or R[4] != R[3] or R[5] != R[3]))): #[2^23^1X^\not=3
                    return True 
            if len(R) == 2 or (len(R) &gt; 2 and R[2] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 3 or R[3] != R[2])): #[2^2n^(0 or 1)
                    return True
    return False

_CONWAY_ELEMENTS = {&#39;3&#39;: {&#39;name&#39;: &#39;U&#39;, &#39;number&#39;: 92}, &#39;13&#39;: {&#39;name&#39;: &#39;Pa&#39;, &#39;number&#39;: 91}, &#39;1113&#39;: {&#39;name&#39;: &#39;Th&#39;, &#39;number&#39;: 90}, &#39;3113&#39;: {&#39;name&#39;: &#39;Ac&#39;, &#39;number&#39;: 89}, &#39;132113&#39;: {&#39;name&#39;: &#39;Ra&#39;, &#39;number&#39;: 88}, &#39;1113122113&#39;: {&#39;name&#39;: &#39;Fr&#39;, &#39;number&#39;: 87}, &#39;311311222113&#39;: {&#39;name&#39;: &#39;Rn&#39;, &#39;number&#39;: 86}, &#39;1322113&#39;: {&#39;name&#39;: &#39;At&#39;, &#39;number&#39;: 85}, &#39;1113222113&#39;: {&#39;name&#39;: &#39;Po&#39;, &#39;number&#39;: 84}, &#39;3113322113&#39;: {&#39;name&#39;: &#39;Bi&#39;, &#39;number&#39;: 83}, &#39;123222113&#39;: {&#39;name&#39;: &#39;Pb&#39;, &#39;number&#39;: 82}, &#39;111213322113&#39;: {&#39;name&#39;: &#39;Tl&#39;, &#39;number&#39;: 81}, &#39;31121123222113&#39;: {&#39;name&#39;: &#39;Hg&#39;, &#39;number&#39;: 80}, &#39;132112211213322113&#39;: {&#39;name&#39;: &#39;Au&#39;, &#39;number&#39;: 79}, &#39;111312212221121123222113&#39;: {&#39;name&#39;: &#39;Pt&#39;, &#39;number&#39;: 78}, &#39;3113112211322112211213322113&#39;: {&#39;name&#39;: &#39;Ir&#39;, &#39;number&#39;: 77}, &#39;1321132122211322212221121123222113&#39;: {&#39;name&#39;: &#39;Os&#39;, &#39;number&#39;: 76}, &#39;111312211312113221133211322112211213322113&#39;: {&#39;name&#39;: &#39;Re&#39;, &#39;number&#39;: 75}, &#39;312211322212221121123222113&#39;: {&#39;name&#39;: &#39;W&#39;, &#39;number&#39;: 74}, &#39;13112221133211322112211213322113&#39;: {&#39;name&#39;: &#39;Ta&#39;, &#39;number&#39;: 73}, &#39;11132&#39;: {&#39;name&#39;: &#39;Hf&#39;, &#39;number&#39;: 72}, &#39;311312&#39;: {&#39;name&#39;: &#39;Lu&#39;, &#39;number&#39;: 71}, &#39;1321131112&#39;: {&#39;name&#39;: &#39;Yb&#39;, &#39;number&#39;: 70}, &#39;11131221133112&#39;: {&#39;name&#39;: &#39;Tm&#39;, &#39;number&#39;: 69}, &#39;311311222&#39;: {&#39;name&#39;: &#39;Er&#39;, &#39;number&#39;: 68}, &#39;1321132&#39;: {&#39;name&#39;: &#39;Ho&#39;, &#39;number&#39;: 67}, &#39;111312211312&#39;: {&#39;name&#39;: &#39;Dy&#39;, &#39;number&#39;: 66}, &#39;3113112221131112&#39;: {&#39;name&#39;: &#39;Tb&#39;, &#39;number&#39;: 65}, &#39;13221133112&#39;: {&#39;name&#39;: &#39;Gd&#39;, &#39;number&#39;: 64}, &#39;1113222&#39;: {&#39;name&#39;: &#39;Eu&#39;, &#39;number&#39;: 63}, &#39;311332&#39;: {&#39;name&#39;: &#39;Sm&#39;, &#39;number&#39;: 62}, &#39;132&#39;: {&#39;name&#39;: &#39;Pm&#39;, &#39;number&#39;: 61}, &#39;111312&#39;: {&#39;name&#39;: &#39;Nd&#39;, &#39;number&#39;: 60}, &#39;31131112&#39;: {&#39;name&#39;: &#39;Pr&#39;, &#39;number&#39;: 59}, &#39;1321133112&#39;: {&#39;name&#39;: &#39;Ce&#39;, &#39;number&#39;: 58}, &#39;11131&#39;: {&#39;name&#39;: &#39;La&#39;, &#39;number&#39;: 57}, &#39;311311&#39;: {&#39;name&#39;: &#39;Ba&#39;, &#39;number&#39;: 56}, &#39;13211321&#39;: {&#39;name&#39;: &#39;Cs&#39;, &#39;number&#39;: 55}, &#39;11131221131211&#39;: {&#39;name&#39;: &#39;Xe&#39;, &#39;number&#39;: 54}, &#39;311311222113111221&#39;: {&#39;name&#39;: &#39;I&#39;, &#39;number&#39;: 53}, &#39;1322113312211&#39;: {&#39;name&#39;: &#39;Te&#39;, &#39;number&#39;: 52}, &#39;3112221&#39;: {&#39;name&#39;: &#39;Sb&#39;, &#39;number&#39;: 51}, &#39;13211&#39;: {&#39;name&#39;: &#39;Sn&#39;, &#39;number&#39;: 50}, &#39;11131221&#39;: {&#39;name&#39;: &#39;In&#39;, &#39;number&#39;: 49}, &#39;3113112211&#39;: {&#39;name&#39;: &#39;Cd&#39;, &#39;number&#39;: 48}, &#39;132113212221&#39;: {&#39;name&#39;: &#39;Ag&#39;, &#39;number&#39;: 47}, &#39;111312211312113211&#39;: {&#39;name&#39;: &#39;Pd&#39;, &#39;number&#39;: 46}, &#39;311311222113111221131221&#39;: {&#39;name&#39;: &#39;Rh&#39;, &#39;number&#39;: 45}, &#39;132211331222113112211&#39;: {&#39;name&#39;: &#39;Ru&#39;, &#39;number&#39;: 44}, &#39;311322113212221&#39;: {&#39;name&#39;: &#39;Tc&#39;, &#39;number&#39;: 43}, &#39;13211322211312113211&#39;: {&#39;name&#39;: &#39;Mo&#39;, &#39;number&#39;: 42}, &#39;1113122113322113111221131221&#39;: {&#39;name&#39;: &#39;Nb&#39;, &#39;number&#39;: 41}, &#39;12322211331222113112211&#39;: {&#39;name&#39;: &#39;Zr&#39;, &#39;number&#39;: 40}, &#39;1112133&#39;: {&#39;name&#39;: &#39;Y&#39;, &#39;number&#39;: 39}, &#39;3112112&#39;: {&#39;name&#39;: &#39;Sr&#39;, &#39;number&#39;: 38}, &#39;1321122112&#39;: {&#39;name&#39;: &#39;Rb&#39;, &#39;number&#39;: 37}, &#39;11131221222112&#39;: {&#39;name&#39;: &#39;Kr&#39;, &#39;number&#39;: 36}, &#39;3113112211322112&#39;: {&#39;name&#39;: &#39;Br&#39;, &#39;number&#39;: 35}, &#39;13211321222113222112&#39;: {&#39;name&#39;: &#39;Se&#39;, &#39;number&#39;: 34}, &#39;11131221131211322113322112&#39;: {&#39;name&#39;: &#39;As&#39;, &#39;number&#39;: 33}, &#39;31131122211311122113222&#39;: {&#39;name&#39;: &#39;Ge&#39;, &#39;number&#39;: 32}, &#39;13221133122211332&#39;: {&#39;name&#39;: &#39;Ga&#39;, &#39;number&#39;: 31}, &#39;312&#39;: {&#39;name&#39;: &#39;Zn&#39;, &#39;number&#39;: 30}, &#39;131112&#39;: {&#39;name&#39;: &#39;Cu&#39;, &#39;number&#39;: 29}, &#39;11133112&#39;: {&#39;name&#39;: &#39;Ni&#39;, &#39;number&#39;: 28}, &#39;32112&#39;: {&#39;name&#39;: &#39;Co&#39;, &#39;number&#39;: 27}, &#39;13122112&#39;: {&#39;name&#39;: &#39;Fe&#39;, &#39;number&#39;: 26}, &#39;111311222112&#39;: {&#39;name&#39;: &#39;Mn&#39;, &#39;number&#39;: 25}, &#39;31132&#39;: {&#39;name&#39;: &#39;Cr&#39;, &#39;number&#39;: 24}, &#39;13211312&#39;: {&#39;name&#39;: &#39;V&#39;, &#39;number&#39;: 23}, &#39;11131221131112&#39;: {&#39;name&#39;: &#39;Ti&#39;, &#39;number&#39;: 22}, &#39;3113112221133112&#39;: {&#39;name&#39;: &#39;Sc&#39;, &#39;number&#39;: 21}, &#39;12&#39;: {&#39;name&#39;: &#39;Ca&#39;, &#39;number&#39;: 20}, &#39;1112&#39;: {&#39;name&#39;: &#39;K&#39;, &#39;number&#39;: 19}, &#39;3112&#39;: {&#39;name&#39;: &#39;Ar&#39;, &#39;number&#39;: 18}, &#39;132112&#39;: {&#39;name&#39;: &#39;Cl&#39;, &#39;number&#39;: 17}, &#39;1113122112&#39;: {&#39;name&#39;: &#39;S&#39;, &#39;number&#39;: 16}, &#39;311311222112&#39;: {&#39;name&#39;: &#39;P&#39;, &#39;number&#39;: 15}, &#39;1322112&#39;: {&#39;name&#39;: &#39;Si&#39;, &#39;number&#39;: 14}, &#39;1113222112&#39;: {&#39;name&#39;: &#39;Al&#39;, &#39;number&#39;: 13}, &#39;3113322112&#39;: {&#39;name&#39;: &#39;Mg&#39;, &#39;number&#39;: 12}, &#39;123222112&#39;: {&#39;name&#39;: &#39;Na&#39;, &#39;number&#39;: 11}, &#39;111213322112&#39;: {&#39;name&#39;: &#39;Ne&#39;, &#39;number&#39;: 10}, &#39;31121123222112&#39;: {&#39;name&#39;: &#39;F&#39;, &#39;number&#39;: 9}, &#39;132112211213322112&#39;: {&#39;name&#39;: &#39;O&#39;, &#39;number&#39;: 8}, &#39;111312212221121123222112&#39;: {&#39;name&#39;: &#39;N&#39;, &#39;number&#39;: 7}, &#39;3113112211322112211213322112&#39;: {&#39;name&#39;: &#39;C&#39;, &#39;number&#39;: 6}, &#39;1321132122211322212221121123222112&#39;: {&#39;name&#39;: &#39;B&#39;, &#39;number&#39;: 5}, &#39;111312211312113221133211322112211213322112&#39;: {&#39;name&#39;: &#39;Be&#39;, &#39;number&#39;: 4}, &#39;312211322212221121123222112&#39;: {&#39;name&#39;: &#39;Li&#39;, &#39;number&#39;: 3}, &#39;13112221133211322112211213322112&#39;: {&#39;name&#39;: &#39;He&#39;, &#39;number&#39;: 2}, &#39;22&#39;: {&#39;name&#39;: &#39;H&#39;, &#39;number&#39;: 1}}

def _conway_name(element):
    string = element.get_string()
    if string in _CONWAY_ELEMENTS:
        return _CONWAY_ELEMENTS[string][&#39;name&#39;]
    Pu = &#39;31221132221222112112322211n&#39;
    Np = &#39;1311222113321132211221121332211n&#39;
    if len(string) == len(Pu) and string[:-1] == Pu[:-1]:
        return &#39;Pu&#39; + string[-1]
    if len(string) == len(Np) and string[:-1] == Np[:-1]:
        return &#39;Np&#39; + string[-1]
    return element.get_name()

def _conway_number(element):
    string = element.get_string()
    if string in _CONWAY_ELEMENTS:
        return _CONWAY_ELEMENTS[string][&#39;number&#39;]
    else: # Handling transuranic elements
        return 92 * len(string) + ord(string[-1])

################# LOOK AND SAY #################################

class LookAndSay():
    &#34;&#34;&#34;
    A class responsible for the fundamental say-what-you-see operation
    that generates a look and say sequence. The parameter ``say`` in the
    constructor is a function that determines the decay of chunk of the form
    \\(a^b\\). The say function can have one or two parameters:

    * If the say function accepts one parameter, the LookAndSay object will correspond to the decay \\(a^b\\to say(b)a\\).
    * If the say function accepts two parameters, the LookAndSay object will correspond to the decay \\(a^b\\to say(b, a)\\).

    When no parameter is passed to the constructor, the LookAndSay
    object will correspond to standard base ten look and say sequences.

    
    ## Example Session: Default Constructor. 
    The following example uses the default (standard) look and say sequences.
    Note that the ratio of lengths are approaching Conway&#39;s constant.
    ```python 
    ls = LookAndSay()  
    ls.generate_sequence(&#39;55555&#39;, 50)
    sequence = ls.get_sequence()
    first_terms = sequence[:10]
    print(&#39;Sequence:&#39;, first_terms)
    print(&#39;Ratios of lengths:&#39;, ls.get_length_ratios())
    print(&#39;Just the last ratio:&#39;, ls.get_last_length_ratio())
    ```
    ### Output:

    ```sh
    Sequence: [&#39;55555&#39;, &#39;55&#39;, &#39;25&#39;, &#39;1215&#39;, &#39;11121115&#39;, &#39;31123115&#39;, &#39;132112132115&#39;, &#39;11131221121113122115&#39;, &#39;311311222112311311222115&#39;, &#39;1321132132211213211321322115&#39;]
    Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331, 1.2996264674493063, 1.3030178608088687, 1.3061288797857256, 1.3046441495778045, 1.300263510702233, 1.304700277323473, 1.3052921299324176, 1.299567840664732, 1.3057126333376172, 1.304461231821649, 1.3014789104353732, 1.3050192770385831, 1.304147670163319, 1.3026438489740129, 1.3036460274187538]
    Just the last ratio: 1.3036460274187538
    ```

    ## Example Sessions: One parameter say functions

    Here is an implementation of a Roman look and say:
    ```python
    def roman_say(num):
        assert num &lt; 10, &#34;This Roman can only count to 9.&#34;
        roman = {1:&#39;I&#39;, 2:&#39;II&#39;, 3:&#39;III&#39;, 4:&#39;IV&#39;, 5:&#39;V&#39;, 6:&#39;VI&#39;, 7:&#39;VII&#39;, 8:&#39;VIII&#39;, 9:&#39;IX&#39;}
        return roman[num]

    roman_ls = LookAndSay(roman_say)

    roman_ls.generate_sequence(&#39;I&#39;, 10)
    print(roman_ls.get_sequence())

    roman_ls.generate_sequence(&#39;V&#39;, 10)
    print(roman_ls.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IIII&#39;, &#39;IVI&#39;, &#39;IIIVII&#39;, &#39;IIIIIVIII&#39;, &#39;VIIVIIII&#39;, &#39;IVIIIIVIVI&#39;, &#39;IIIVIVIIVIIIVII&#39;, &#39;IIIIIVIIIVIIIIVIIIIIVIII&#39;]
    [&#39;V&#39;, &#39;IV&#39;, &#39;IIIV&#39;, &#39;IIIIIV&#39;, &#39;VIIV&#39;, &#39;IVIIIIV&#39;, &#39;IIIVIVIIV&#39;, &#39;IIIIIVIIIVIIIIV&#39;, &#39;VIIVIIIIIVIVIIV&#39;, &#39;IVIIIIVVIIVIIIVIIIIV&#39;, &#39;IIIVIVIIIVIIIIVIIIIIVIVIIV&#39;]
    ```
    Here is a standard binary look and say:
    ```python
    def binary_say(num):
        return &#34;{0:b}&#34;.format(num)

    binary_ls = LookAndSay(binary_say)

    binary_ls.generate_sequence(&#39;0&#39;, 9)
    print(binary_ls.get_sequence())

    binary_ls.generate_sequence(&#39;1&#39;, 9)
    print(binary_ls.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;0&#39;, &#39;10&#39;, &#39;1110&#39;, &#39;11110&#39;, &#39;100110&#39;, &#39;1110010110&#39;, &#39;111100111010110&#39;, &#39;100110011110111010110&#39;, &#39;1110010110010011011110111010110&#39;, &#39;1111001110101100111001011010011011110111010110&#39;]
    [&#39;1&#39;, &#39;11&#39;, &#39;101&#39;, &#39;111011&#39;, &#39;11110101&#39;, &#39;100110111011&#39;, &#39;111001011011110101&#39;, &#39;111100111010110100110111011&#39;, &#39;100110011110111010110111001011011110101&#39;, &#39;1110010110010011011110111010110111100111010110100110111011&#39;]
    ```
    ## Example Sessions: Two parameter say functions

    Here is a *look-and-say-again* from the paper *Stuttering Conway Sequences Are Still Conway Sequences* by Brier et al.
    ```python
    def say_again(char_count, char):
        return 2 * str(char_count) + 2 * char

    look_and_say_again = LookAndSay(say_again)

    look_and_say_again.generate_sequence(&#39;1&#39;, 10)
    print(look_and_say_again.get_sequence())

    look_and_say_again.generate_sequence(&#39;2&#39;, 10)
    print(look_and_say_again.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;1&#39;, &#39;1111&#39;, &#39;4411&#39;, &#39;22442211&#39;, &#39;2222224422222211&#39;, &#39;6622224466222211&#39;, &#39;226644222244226644222211&#39;, &#39;2222226622444422224422222266224444222211&#39;, &#39;662222662222444444222244662222662222444444222211&#39;, &#39;22664422226644226644442222442266442222664422664444222211&#39;, &#39;2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211&#39;]
    [&#39;2&#39;, &#39;1122&#39;, &#39;22112222&#39;, &#39;222222114422&#39;, &#39;6622221122442222&#39;, &#39;226644222211222222444422&#39;, &#39;22222266224444222211662244442222&#39;, &#39;6622226622224444442222112266222244444422&#39;, &#39;226644222266442266444422221122222266442266442222&#39;, &#39;222222662244442222662244222222664444442222116622226622442222226622444422&#39;, &#39;66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222&#39;]
    ```
    Here is Morrill&#39;s *Look Knave*.
    ```python
    def knave_say(bit_count, bit):
        flip = {&#39;0&#39;:&#39;1&#39;, &#39;1&#39;:&#39;0&#39;}
        return &#34;{0:b}&#34;.format(bit_count) + flip[bit]

    look_knave = LookAndSay(knave_say)

    look_knave.generate_sequence(&#39;0&#39;, 12)
    print(look_knave.get_sequence())

    look_knave.generate_sequence(&#39;1&#39;, 12)
    print(look_knave.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;0&#39;, &#39;11&#39;, &#39;100&#39;, &#39;10101&#39;, &#39;1011101110&#39;, &#39;10111101111011&#39;, &#39;1011100011100011100&#39;, &#39;1011110111110111110101&#39;, &#39;1011100011101011101011101110&#39;, &#39;10111101111101110111101110111101111011&#39;, &#39;10111000111010111101110001111011100011100011100&#39;, &#39;1011110111110111011100011110111100011110111110111110101&#39;, &#39;1011100011101011110111101111000111000111100011101011101011101110&#39;]
    [&#39;1&#39;, &#39;10&#39;, &#39;1011&#39;, &#39;1011100&#39;, &#39;1011110101&#39;, &#39;1011100011101110&#39;, &#39;10111101111101111011&#39;, &#39;1011100011101011100011100&#39;, &#39;1011110111110111011110111110101&#39;, &#39;101110001110101111011100011101011101110&#39;, &#39;10111101111101110111000111101111101110111101111011&#39;, &#39;10111000111010111101111011110001110101111011100011100011100&#39;, &#39;10111101111101110111000111000111000111110111011100011110111110111110101&#39;]
    ```
    &#34;&#34;&#34;
    def __init__(self, say = None):
        super(LookAndSay, self).__init__()
        self._is_Conway = False
        if say == None:
            say = (lambda n : str(n))
            self._is_Conway = True
        self.say = say
        self.sequence = []

    def _chunk_op(self, char_count, char):
        &#34;&#34;&#34;
        Conversion of the say function to a two parameter function 
        if the say function takes only one parameter; 
        just a copy of the say function otherwise.
        &#34;&#34;&#34;
        try:
            return self.say(char_count, char)
        except:
            return self.say(char_count) + char

    def get_sequence(self):
        &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
        return self.sequence

    def say_what_you_see(self, string):
        &#34;&#34;&#34;
        The fundamental look and say operation that generates each 
        term of a look and say sequence from its predecessor. For example, 
        using the standard (default) LookAndSay object, 
        ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
        &#34;&#34;&#34;
        if not string: return None # handles empty string, which is falsy
        letter = string[0]
        result = &#39;&#39;
        count = 0
        for ch in string:
            if ch == letter: 
                count += 1
            else:
                result += self._chunk_op(count, letter)
                count = 1
                letter = ch 
        result += self._chunk_op(count, letter)
        return result
     
    def generate_sequence(self, seed, num_iterations):
        &#34;&#34;&#34;
        Generates the look and say sequence. The parameter ``seed`` is 
        the initial term in the sequence, and ``num_iterations`` is the 
        number of terms generated.
        &#34;&#34;&#34;
        if not seed: return None # handles empty seed, which is falsy
        result = [seed]
        for _ in range(num_iterations):
            result.append(self.say_what_you_see(result[-1]))
        self.sequence = result

    def get_length_ratios(self):
        &#34;&#34;&#34;
        Returns a list of the ratios of lengths of 
        successive terms in the look and say sequence.
        &#34;&#34;&#34;
        num_iterations = len(self.sequence)
        assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
        return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]

    def get_last_length_ratio(self):
        &#34;&#34;&#34;
        Returns the ratio of the lengths of the last 
        two terms of the look and say sequence
        &#34;&#34;&#34;
        return self.get_length_ratios()[-1]


########### CHEMISTRY #####################

class Chemistry():
    &#34;&#34;&#34;
    A class responsible for generating all the persistent elements 
    appearing in look and say sequences, along with 
    the chemical properties of those elements.

    Parameters in the constructor are a LookAndSay object ``las`` and
    a splitting function ``split``. The user is responsible
    for verifying that the provided splitting function is valid for the given
    LookAndSay object. The default splitting function corresponds to 
    Conway&#39;s original Splitting Theorem.

    &#34;&#34;&#34;
    def __init__(self, las, split = split_Conway, elements = None):
        super(Chemistry, self).__init__()
        self.las = las
        self.split = split
        if elements == None:
            elements = []
        self.elements = elements

    def get_elements(self):
        &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
        return self.elements

    def clear_elements(self):
        &#34;&#34;&#34;Resets the list of elements back to the empty list&#34;&#34;&#34;
        self.elements = []

    def _split_to_elements(self, string): 
        return [Element(chunk, self.las) for chunk in self.split(string)]

    def _generate_all_elements(self, strings):
        for string in strings:
            for elt in self._split_to_elements(string):
                if elt not in self.elements:
                    # add elt to the chemistry:
                    self.elements.append(elt)
                    # recursively set the decay for elt:
                    decay_elts = self._split_to_elements(self.las.say_what_you_see(elt.get_string()))
                    self._generate_all_elements(map(lambda e : e.get_string(), decay_elts))
                    elt._set_decay(decay_elts)
        # clean up decay for all elements:
        for elt in self.elements:
            dec = []
            for d in elt.get_decay():
                dec += [e for e in self.elements if e == d]
            elt._set_decay(dec)

    def _remove_extinct_elements(self): 
        while True:
            common_elements = []
            for elt in self.elements:
                for d in elt.get_decay():
                    if d not in common_elements:
                        common_elements.append(d)
            if len(common_elements) &lt; len(self.elements):
                self.elements = common_elements[:]
            else: 
                break

    def generate_elements(self, seeds, reset = True):
        &#34;&#34;&#34;
        Collects all the persistent elements from all the look and
        say sequences generated by the given seeds. The parameter ``seeds``
        should be a nonempty list of strings. By default, this method will 
        clear any elements in the chemistry that exist before this method is called
        prior to collecting from the given seeds. Use ``reset = False`` 
        to keep the old elements. 
        &#34;&#34;&#34;
        assert type(seeds) == type([&#39;0&#39;]), &#34;The parameter seeds in generate_elements should be a list of strings.&#34;
        if reset:
            self.clear_elements()
        strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
        self._generate_all_elements(strings)
        self._remove_extinct_elements()
        self.order_elements(&#39;string&#39;)
        self._name_elements()

    def _name_elements(self):
        if self.las._is_Conway:
            for e in self.get_elements():
                e.set_name(_conway_name(e))
            self.elements = sorted(self.get_elements(), key = _conway_number)
        else:
            for i, e in enumerate(self.get_elements()):
                e.set_name(&#39;E&#39; + str(i + 1))

    def get_decay_matrix(self):
        &#34;&#34;&#34;
        Returns the decay matrix as a nested list of integers 
        (i.e. a list of the rows).
        The order of the columns and rows correspond to the order
        in the list of elements.
        &#34;&#34;&#34;
        mat = []
        e = self.elements
        for i in range(len(e)):
            row = []
            for j in range(len(e)):
                row.append(e[j].get_decay().count(e[i]))
            mat.append(row)
        return mat

    def get_max_eigenvalue(self):
        &#34;&#34;&#34;
        Returns the maximal real eigenvalue of the decay matrix.
        This method assumes the existence of a real eigenvalue which
        is larger than (the absolute value) of every other eigenvalue.
        This assumption is usually guaranteed by the Perron-Frobenius Theorem.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        return max(eigenvalues).real

    def get_char_poly(self, factor = True):
        &#34;&#34;&#34;
        Returns the characteristic polynomial of the decay matrix using sympy.
        By default the returned polynomial will be factored. 
        Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
        &#34;&#34;&#34;
        chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
        if factor:
            return sympy.factor(chi.as_expr())
        else:
            return chi.as_expr()

    def _get_abundances(self, dec_places = 8):
        &#34;&#34;&#34;
        Returns a list of relative abundances of each element.
        Note the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The order of the list corresponds to the order of the list of elements.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        eigenvectors = eigenstuff[1]
        index = numpy.where(eigenvalues == max(eigenvalues))
        limiting_eigenvector_nparray = eigenvectors[:,index].real
        # The next two lines are converting the numpy array to a list
        limiting_eigenvector = limiting_eigenvector_nparray.tolist()
        limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
        abundance = [round(100 * num / sum(limiting_eigenvector), dec_places) for num in limiting_eigenvector]
        return abundance

    def periodic_table(self, dec_places = 8):
        &#34;&#34;&#34;
        Creates a periodic table including each element&#39;s name, string, relative abundance, and decay.
        Returns the periodic table as a nested dictionary.
        &#34;&#34;&#34;
        return {e.get_name() : {&#39;string&#39; : e.get_string(), 
                                &#39;abundance&#39; : self._get_abundances(dec_places)[i],
                                &#39;decay&#39; : e.get_decay()}
                                for i, e in enumerate(self.get_elements())}

    def print_periodic_table(self, dec_places = 8):
        &#34;&#34;&#34;
        Prints the periodic table. Note the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The parameter ``dec_places`` refers to the accuracy of the abundances.
        &#34;&#34;&#34;
        pt = self.periodic_table(dec_places)
        elt_width = 2 + max(len(&#39;element&#39;), max([len(e.get_name()) for e in self.get_elements()]))
        str_width = 2 + max(len(&#39;string&#39;), max([len(e.get_string()) for e in self.get_elements()]))
        ab_width  = 2 + max(len(&#39;abundance&#39;), max([len(str(prop[&#39;abundance&#39;])) for elt, prop in pt.items()]))
        print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(&#39;element&#39;, &#39;string&#39;, &#39;abundance&#39;, &#39;decay&#39;, elt_width=elt_width, str_width=str_width, ab_width=ab_width))
        for elt, prop in pt.items():
            print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(elt, prop[&#39;string&#39;], prop[&#39;abundance&#39;], str(prop[&#39;decay&#39;]), elt_width=elt_width, str_width=str_width, ab_width=ab_width))

    def order_elements(self, order_on, key = None, reverse = False, rename = True):
        &#34;&#34;&#34;
        Reorders the list of elements depending on the parameter ``order_on`` as follows:

        * ``order_on=&#39;abundance&#39;``: Orders elements from highest abundance to lowest.
        * ``order_on=&#39;string&#39;``: Orders elements according to the lexicographic order of their strings.
        * ``order_on=&#39;string length&#39;``: Orders elements according to the lengths of their strings from shortest to longest.
        * ``order_on=&#39;name&#39;``: Orders elements alphabetically according to their names.
        * ``order_on=&#39;key&#39;``: Orders elements according to the function specified by the parameter ``key``.

        Note: By default this method will automatically rename the elements according to their new order.
        This will not happen if the elements are named via Conway or if the parameter ``rename = False`` is passed.
        &#34;&#34;&#34;
        assert order_on in [&#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, &#39;key&#39;], &#34;Invalid parameter passed to order_elements. Valid parameter are &#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, and &#39;key&#39;.&#34;
        pt = self.periodic_table()
        sorted_key = {
            &#39;abundance&#39;: lambda e : pt[e.get_name()][&#39;abundance&#39;],
            &#39;name&#39;: lambda e : pt[e.get_name()][&#39;name&#39;],
            &#39;string&#39;: lambda e : e.get_string(),
            &#39;string length&#39;: lambda e : len(e.get_string()),
            &#39;key&#39;: key
        }
        self.elements = sorted(self.get_elements(), key = sorted_key[order_on])
        if order_on == &#39;abundance&#39;:
            self.elements.reverse()
        if reverse:
            self.elements.reverse()
        if not self.las._is_Conway and rename:
            self._name_elements()

class BinaryChemistry(Chemistry):
    &#34;&#34;&#34;
    A chemistry for binary look and say sequences that split as 1.0 
    (i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
    the say-what-you-see operation maps 
    \\(a^b\\) to \\([b]a\\) where \\([b]\\) is a binary
    string that always starts with a 1. For example, this chemistry is 
    valid for standard base two binary look and say sequences. 

    ## Example Session: Standard Binary
    ```python
    def binary_say(num):
        return &#34;{0:b}&#34;.format(num)

    binary_ls = LookAndSay(binary_say)
    binary_chem = BinaryChemistry(binary_ls)
    binary_chem.generate_elements([&#39;1&#39;])
    binary_chem.order_elements(&#39;abundance&#39;)
    binary_chem.print_periodic_table()
    print(binary_chem.get_char_poly())
    print(binary_chem.get_max_eigenvalue())
    ```

    ### Output:

    ```sh
    element   string   abundance     decay
    E1        110      21.6756572    [E2, E1]
    E2        10       21.6756572    [E3]
    E3        1110     14.78990357   [E4]
    E4        11110    10.09156242   [E6, E1]
    E5        1100     10.09156242   [E2, E5]
    E6        100      10.09156242   [E7]
    E7        11100    6.88575362    [E8]
    E8        111100   4.69834115    [E6, E5]
    E9        11       0.0           [E2, E10]
    E10       1        0.0           [E9]
    lambda**4*(lambda - 1)**2*(lambda + 1)*(lambda**3 - lambda**2 - 1)
    1.4655712318767664
    ```
    &#34;&#34;&#34;
    def __init__(self, las, elements = None):
        sf = SplitFuncFactory()
        sf.declare_split_after(&#39;0&#39;)
        binary_split = sf.get_split()
        super().__init__(las, binary_split, elements)

########### ELEMENT #######################

class Element():
    &#34;&#34;&#34;
    An element consists of a string (usually a chunk of digits) and 
    a name. For example, in Conway&#39;s chemistry there is an element
    named H (short for Hydrogen) consisting of the string &#39;22&#39;. 
    Each element decays into a list of other elements. 
    &#34;&#34;&#34;
    def __init__(self, string, las, decay = []):
        super(Element, self).__init__()
        self.string = string
        self.las = las
        self.name = string
        self.decay = decay

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        if isinstance(other, Element):
                return self.string == other.string and self.las == other.las
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        return hash(tuple(sorted(self.__dict__.items())))

    def _set_decay(self, elements):
        self.decay = elements

    def get_decay(self):
        &#34;&#34;&#34;Returns the decay of the element as a list of elements.&#34;&#34;&#34;
        return self.decay

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def get_string(self):
        return self.string

########### SPLIT FUNCTION FACTORY #####################

class SplitFuncFactory():
    &#34;&#34;&#34;
    A class to help create a split function. The split function factory
    can produce a split function via any combination of the following:

    * Specifying specific chunks L and R such that LR splits as L.R.
    * Specifying specific characters or chunks to always split before or after.

    &#34;&#34;&#34;
    def __init__(self):
        self._splitting_pairs = []
        self._chunks_before_split = []
        self._chunks_after_split = []
        self._split_conditions = []

    def get_split(self):
        &#34;&#34;&#34;Return the split function&#34;&#34;&#34;
        return lambda string : self._split(string)

    def _split(self, string):
        chunks = []
        start = 0
        for i in range(1, len(string)):
            if self._is_split(string[start:i], string[i:]):
                chunks.append(string[start:i])
                start = i
        chunks.append(string[start:])
        return chunks

    def _is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
            return True
        if L[-1] == R[0]:
            return False
        for l in self._chunks_before_split:
            if len(l) &lt;= len(L) and l == L[-len(l):]:
                return True
        for r in self._chunks_after_split:
            if len(r) &lt;= len(R) and r == R[:len(r)]:
                return True
        for l, r in self._splitting_pairs:
            if len(l) &lt;= len(L) and len(r) &lt;= len(R) and l == L[-len(l):] and r == R[:len(r)]:
                return True
        for condition in self._split_conditions:
            if condition(L, R):
                return True
        return False

    def declare_splitting_pairs(self, *pairs):
        &#34;&#34;&#34;
        Specify pairs of chunks in the form (L, R) 
        such that LR always splits as L.R
        &#34;&#34;&#34;
        for pair in pairs:
            self._splitting_pairs.append(pair)

    def declare_split_after(self, *chunks):
        &#34;&#34;&#34;Specify chunks L such that LR splits for every possible R&#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_before_split.append(chunk)

    def declare_split_before(self, *chunks):
        &#34;&#34;&#34;Specify chunks R such that LR splits for every possible L&#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_after_split.append(chunk)

    # def add_splitting_condition(self, *args):
    #     &#34;&#34;&#34;
    #     Specify functions ``is_split`` such that 
    #     ``is_split(L,R)`` returns True for some splittable pairs 
    #     (L,R). 
    #     &#34;&#34;&#34;
    #     for arg in args:
    #         self._split_conditions.append(arg)


    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="look_and_say.split_Conway"><code class="name flex">
<span>def <span class="ident">split_Conway</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits a string into a list of substrings according to Conway's Splitting Theorem.
Assumes the string is not empty. </p>
<h2 id="example-session">Example Session:</h2>
<pre><code class="language-python">string = '1211132213'
chunks = split_Conway(string)
print(chunks)
</code></pre>
<h3 id="output">Output:</h3>
<pre><code class="language-sh">['12', '1113', '22', '13']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_Conway(string):
    &#34;&#34;&#34;
    Splits a string into a list of substrings according to Conway&#39;s Splitting Theorem.
    Assumes the string is not empty. 

    ## Example Session:
    ```python
    string = &#39;1211132213&#39;
    chunks = split_Conway(string)
    print(chunks)
    ```
    ### Output:

    ```sh
    [&#39;12&#39;, &#39;1113&#39;, &#39;22&#39;, &#39;13&#39;]
    ```
    &#34;&#34;&#34;
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if _is_split_pair_Conway(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="look_and_say.BinaryChemistry"><code class="flex name class">
<span>class <span class="ident">BinaryChemistry</span></span>
<span>(</span><span>las, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A chemistry for binary look and say sequences that split as 1.0
(i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
the say-what-you-see operation maps
<span><span class="MathJax_Preview">a^b</span><script type="math/tex">a^b</script></span> to <span><span class="MathJax_Preview">[b]a</span><script type="math/tex">[b]a</script></span> where <span><span class="MathJax_Preview">[b]</span><script type="math/tex">[b]</script></span> is a binary
string that always starts with a 1. For example, this chemistry is
valid for standard base two binary look and say sequences. </p>
<h2 id="example-session-standard-binary">Example Session: Standard Binary</h2>
<pre><code class="language-python">def binary_say(num):
    return &quot;{0:b}&quot;.format(num)

binary_ls = LookAndSay(binary_say)
binary_chem = BinaryChemistry(binary_ls)
binary_chem.generate_elements(['1'])
binary_chem.order_elements('abundance')
binary_chem.print_periodic_table()
print(binary_chem.get_char_poly())
print(binary_chem.get_max_eigenvalue())
</code></pre>
<h3 id="output">Output:</h3>
<pre><code class="language-sh">element   string   abundance     decay
E1        110      21.6756572    [E2, E1]
E2        10       21.6756572    [E3]
E3        1110     14.78990357   [E4]
E4        11110    10.09156242   [E6, E1]
E5        1100     10.09156242   [E2, E5]
E6        100      10.09156242   [E7]
E7        11100    6.88575362    [E8]
E8        111100   4.69834115    [E6, E5]
E9        11       0.0           [E2, E10]
E10       1        0.0           [E9]
lambda**4*(lambda - 1)**2*(lambda + 1)*(lambda**3 - lambda**2 - 1)
1.4655712318767664
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryChemistry(Chemistry):
    &#34;&#34;&#34;
    A chemistry for binary look and say sequences that split as 1.0 
    (i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
    the say-what-you-see operation maps 
    \\(a^b\\) to \\([b]a\\) where \\([b]\\) is a binary
    string that always starts with a 1. For example, this chemistry is 
    valid for standard base two binary look and say sequences. 

    ## Example Session: Standard Binary
    ```python
    def binary_say(num):
        return &#34;{0:b}&#34;.format(num)

    binary_ls = LookAndSay(binary_say)
    binary_chem = BinaryChemistry(binary_ls)
    binary_chem.generate_elements([&#39;1&#39;])
    binary_chem.order_elements(&#39;abundance&#39;)
    binary_chem.print_periodic_table()
    print(binary_chem.get_char_poly())
    print(binary_chem.get_max_eigenvalue())
    ```

    ### Output:

    ```sh
    element   string   abundance     decay
    E1        110      21.6756572    [E2, E1]
    E2        10       21.6756572    [E3]
    E3        1110     14.78990357   [E4]
    E4        11110    10.09156242   [E6, E1]
    E5        1100     10.09156242   [E2, E5]
    E6        100      10.09156242   [E7]
    E7        11100    6.88575362    [E8]
    E8        111100   4.69834115    [E6, E5]
    E9        11       0.0           [E2, E10]
    E10       1        0.0           [E9]
    lambda**4*(lambda - 1)**2*(lambda + 1)*(lambda**3 - lambda**2 - 1)
    1.4655712318767664
    ```
    &#34;&#34;&#34;
    def __init__(self, las, elements = None):
        sf = SplitFuncFactory()
        sf.declare_split_after(&#39;0&#39;)
        binary_split = sf.get_split()
        super().__init__(las, binary_split, elements)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></b></code>:
<ul class="hlist">
<li><code><a title="look_and_say.Chemistry.clear_elements" href="#look_and_say.Chemistry.clear_elements">clear_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.generate_elements" href="#look_and_say.Chemistry.generate_elements">generate_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_char_poly" href="#look_and_say.Chemistry.get_char_poly">get_char_poly</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_decay_matrix" href="#look_and_say.Chemistry.get_decay_matrix">get_decay_matrix</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_elements" href="#look_and_say.Chemistry.get_elements">get_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_max_eigenvalue" href="#look_and_say.Chemistry.get_max_eigenvalue">get_max_eigenvalue</a></code></li>
<li><code><a title="look_and_say.Chemistry.order_elements" href="#look_and_say.Chemistry.order_elements">order_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.periodic_table" href="#look_and_say.Chemistry.periodic_table">periodic_table</a></code></li>
<li><code><a title="look_and_say.Chemistry.print_periodic_table" href="#look_and_say.Chemistry.print_periodic_table">print_periodic_table</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="look_and_say.Chemistry"><code class="flex name class">
<span>class <span class="ident">Chemistry</span></span>
<span>(</span><span>las, split=&lt;function split_Conway&gt;, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class responsible for generating all the persistent elements
appearing in look and say sequences, along with
the chemical properties of those elements.</p>
<p>Parameters in the constructor are a LookAndSay object <code>las</code> and
a splitting function <code>split</code>. The user is responsible
for verifying that the provided splitting function is valid for the given
LookAndSay object. The default splitting function corresponds to
Conway's original Splitting Theorem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chemistry():
    &#34;&#34;&#34;
    A class responsible for generating all the persistent elements 
    appearing in look and say sequences, along with 
    the chemical properties of those elements.

    Parameters in the constructor are a LookAndSay object ``las`` and
    a splitting function ``split``. The user is responsible
    for verifying that the provided splitting function is valid for the given
    LookAndSay object. The default splitting function corresponds to 
    Conway&#39;s original Splitting Theorem.

    &#34;&#34;&#34;
    def __init__(self, las, split = split_Conway, elements = None):
        super(Chemistry, self).__init__()
        self.las = las
        self.split = split
        if elements == None:
            elements = []
        self.elements = elements

    def get_elements(self):
        &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
        return self.elements

    def clear_elements(self):
        &#34;&#34;&#34;Resets the list of elements back to the empty list&#34;&#34;&#34;
        self.elements = []

    def _split_to_elements(self, string): 
        return [Element(chunk, self.las) for chunk in self.split(string)]

    def _generate_all_elements(self, strings):
        for string in strings:
            for elt in self._split_to_elements(string):
                if elt not in self.elements:
                    # add elt to the chemistry:
                    self.elements.append(elt)
                    # recursively set the decay for elt:
                    decay_elts = self._split_to_elements(self.las.say_what_you_see(elt.get_string()))
                    self._generate_all_elements(map(lambda e : e.get_string(), decay_elts))
                    elt._set_decay(decay_elts)
        # clean up decay for all elements:
        for elt in self.elements:
            dec = []
            for d in elt.get_decay():
                dec += [e for e in self.elements if e == d]
            elt._set_decay(dec)

    def _remove_extinct_elements(self): 
        while True:
            common_elements = []
            for elt in self.elements:
                for d in elt.get_decay():
                    if d not in common_elements:
                        common_elements.append(d)
            if len(common_elements) &lt; len(self.elements):
                self.elements = common_elements[:]
            else: 
                break

    def generate_elements(self, seeds, reset = True):
        &#34;&#34;&#34;
        Collects all the persistent elements from all the look and
        say sequences generated by the given seeds. The parameter ``seeds``
        should be a nonempty list of strings. By default, this method will 
        clear any elements in the chemistry that exist before this method is called
        prior to collecting from the given seeds. Use ``reset = False`` 
        to keep the old elements. 
        &#34;&#34;&#34;
        assert type(seeds) == type([&#39;0&#39;]), &#34;The parameter seeds in generate_elements should be a list of strings.&#34;
        if reset:
            self.clear_elements()
        strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
        self._generate_all_elements(strings)
        self._remove_extinct_elements()
        self.order_elements(&#39;string&#39;)
        self._name_elements()

    def _name_elements(self):
        if self.las._is_Conway:
            for e in self.get_elements():
                e.set_name(_conway_name(e))
            self.elements = sorted(self.get_elements(), key = _conway_number)
        else:
            for i, e in enumerate(self.get_elements()):
                e.set_name(&#39;E&#39; + str(i + 1))

    def get_decay_matrix(self):
        &#34;&#34;&#34;
        Returns the decay matrix as a nested list of integers 
        (i.e. a list of the rows).
        The order of the columns and rows correspond to the order
        in the list of elements.
        &#34;&#34;&#34;
        mat = []
        e = self.elements
        for i in range(len(e)):
            row = []
            for j in range(len(e)):
                row.append(e[j].get_decay().count(e[i]))
            mat.append(row)
        return mat

    def get_max_eigenvalue(self):
        &#34;&#34;&#34;
        Returns the maximal real eigenvalue of the decay matrix.
        This method assumes the existence of a real eigenvalue which
        is larger than (the absolute value) of every other eigenvalue.
        This assumption is usually guaranteed by the Perron-Frobenius Theorem.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        return max(eigenvalues).real

    def get_char_poly(self, factor = True):
        &#34;&#34;&#34;
        Returns the characteristic polynomial of the decay matrix using sympy.
        By default the returned polynomial will be factored. 
        Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
        &#34;&#34;&#34;
        chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
        if factor:
            return sympy.factor(chi.as_expr())
        else:
            return chi.as_expr()

    def _get_abundances(self, dec_places = 8):
        &#34;&#34;&#34;
        Returns a list of relative abundances of each element.
        Note the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The order of the list corresponds to the order of the list of elements.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        eigenvectors = eigenstuff[1]
        index = numpy.where(eigenvalues == max(eigenvalues))
        limiting_eigenvector_nparray = eigenvectors[:,index].real
        # The next two lines are converting the numpy array to a list
        limiting_eigenvector = limiting_eigenvector_nparray.tolist()
        limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
        abundance = [round(100 * num / sum(limiting_eigenvector), dec_places) for num in limiting_eigenvector]
        return abundance

    def periodic_table(self, dec_places = 8):
        &#34;&#34;&#34;
        Creates a periodic table including each element&#39;s name, string, relative abundance, and decay.
        Returns the periodic table as a nested dictionary.
        &#34;&#34;&#34;
        return {e.get_name() : {&#39;string&#39; : e.get_string(), 
                                &#39;abundance&#39; : self._get_abundances(dec_places)[i],
                                &#39;decay&#39; : e.get_decay()}
                                for i, e in enumerate(self.get_elements())}

    def print_periodic_table(self, dec_places = 8):
        &#34;&#34;&#34;
        Prints the periodic table. Note the abundances are given as percentages, 
        so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
        The parameter ``dec_places`` refers to the accuracy of the abundances.
        &#34;&#34;&#34;
        pt = self.periodic_table(dec_places)
        elt_width = 2 + max(len(&#39;element&#39;), max([len(e.get_name()) for e in self.get_elements()]))
        str_width = 2 + max(len(&#39;string&#39;), max([len(e.get_string()) for e in self.get_elements()]))
        ab_width  = 2 + max(len(&#39;abundance&#39;), max([len(str(prop[&#39;abundance&#39;])) for elt, prop in pt.items()]))
        print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(&#39;element&#39;, &#39;string&#39;, &#39;abundance&#39;, &#39;decay&#39;, elt_width=elt_width, str_width=str_width, ab_width=ab_width))
        for elt, prop in pt.items():
            print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(elt, prop[&#39;string&#39;], prop[&#39;abundance&#39;], str(prop[&#39;decay&#39;]), elt_width=elt_width, str_width=str_width, ab_width=ab_width))

    def order_elements(self, order_on, key = None, reverse = False, rename = True):
        &#34;&#34;&#34;
        Reorders the list of elements depending on the parameter ``order_on`` as follows:

        * ``order_on=&#39;abundance&#39;``: Orders elements from highest abundance to lowest.
        * ``order_on=&#39;string&#39;``: Orders elements according to the lexicographic order of their strings.
        * ``order_on=&#39;string length&#39;``: Orders elements according to the lengths of their strings from shortest to longest.
        * ``order_on=&#39;name&#39;``: Orders elements alphabetically according to their names.
        * ``order_on=&#39;key&#39;``: Orders elements according to the function specified by the parameter ``key``.

        Note: By default this method will automatically rename the elements according to their new order.
        This will not happen if the elements are named via Conway or if the parameter ``rename = False`` is passed.
        &#34;&#34;&#34;
        assert order_on in [&#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, &#39;key&#39;], &#34;Invalid parameter passed to order_elements. Valid parameter are &#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, and &#39;key&#39;.&#34;
        pt = self.periodic_table()
        sorted_key = {
            &#39;abundance&#39;: lambda e : pt[e.get_name()][&#39;abundance&#39;],
            &#39;name&#39;: lambda e : pt[e.get_name()][&#39;name&#39;],
            &#39;string&#39;: lambda e : e.get_string(),
            &#39;string length&#39;: lambda e : len(e.get_string()),
            &#39;key&#39;: key
        }
        self.elements = sorted(self.get_elements(), key = sorted_key[order_on])
        if order_on == &#39;abundance&#39;:
            self.elements.reverse()
        if reverse:
            self.elements.reverse()
        if not self.las._is_Conway and rename:
            self._name_elements()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="look_and_say.BinaryChemistry" href="#look_and_say.BinaryChemistry">BinaryChemistry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Chemistry.clear_elements"><code class="name flex">
<span>def <span class="ident">clear_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the list of elements back to the empty list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_elements(self):
    &#34;&#34;&#34;Resets the list of elements back to the empty list&#34;&#34;&#34;
    self.elements = []</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.generate_elements"><code class="name flex">
<span>def <span class="ident">generate_elements</span></span>(<span>self, seeds, reset=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects all the persistent elements from all the look and
say sequences generated by the given seeds. The parameter <code>seeds</code>
should be a nonempty list of strings. By default, this method will
clear any elements in the chemistry that exist before this method is called
prior to collecting from the given seeds. Use <code>reset = False</code>
to keep the old elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_elements(self, seeds, reset = True):
    &#34;&#34;&#34;
    Collects all the persistent elements from all the look and
    say sequences generated by the given seeds. The parameter ``seeds``
    should be a nonempty list of strings. By default, this method will 
    clear any elements in the chemistry that exist before this method is called
    prior to collecting from the given seeds. Use ``reset = False`` 
    to keep the old elements. 
    &#34;&#34;&#34;
    assert type(seeds) == type([&#39;0&#39;]), &#34;The parameter seeds in generate_elements should be a list of strings.&#34;
    if reset:
        self.clear_elements()
    strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
    self._generate_all_elements(strings)
    self._remove_extinct_elements()
    self.order_elements(&#39;string&#39;)
    self._name_elements()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_char_poly"><code class="name flex">
<span>def <span class="ident">get_char_poly</span></span>(<span>self, factor=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the characteristic polynomial of the decay matrix using sympy.
By default the returned polynomial will be factored.
Use <code>factor = False</code> to get the expanded (i.e. unfactored) polynomial.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_char_poly(self, factor = True):
    &#34;&#34;&#34;
    Returns the characteristic polynomial of the decay matrix using sympy.
    By default the returned polynomial will be factored. 
    Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
    &#34;&#34;&#34;
    chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
    if factor:
        return sympy.factor(chi.as_expr())
    else:
        return chi.as_expr()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_decay_matrix"><code class="name flex">
<span>def <span class="ident">get_decay_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the decay matrix as a nested list of integers
(i.e. a list of the rows).
The order of the columns and rows correspond to the order
in the list of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decay_matrix(self):
    &#34;&#34;&#34;
    Returns the decay matrix as a nested list of integers 
    (i.e. a list of the rows).
    The order of the columns and rows correspond to the order
    in the list of elements.
    &#34;&#34;&#34;
    mat = []
    e = self.elements
    for i in range(len(e)):
        row = []
        for j in range(len(e)):
            row.append(e[j].get_decay().count(e[i]))
        mat.append(row)
    return mat</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_elements"><code class="name flex">
<span>def <span class="ident">get_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the elements as a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements(self):
    &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
    return self.elements</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_max_eigenvalue"><code class="name flex">
<span>def <span class="ident">get_max_eigenvalue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximal real eigenvalue of the decay matrix.
This method assumes the existence of a real eigenvalue which
is larger than (the absolute value) of every other eigenvalue.
This assumption is usually guaranteed by the Perron-Frobenius Theorem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_eigenvalue(self):
    &#34;&#34;&#34;
    Returns the maximal real eigenvalue of the decay matrix.
    This method assumes the existence of a real eigenvalue which
    is larger than (the absolute value) of every other eigenvalue.
    This assumption is usually guaranteed by the Perron-Frobenius Theorem.
    &#34;&#34;&#34;
    eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
    eigenvalues = eigenstuff[0]
    return max(eigenvalues).real</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.order_elements"><code class="name flex">
<span>def <span class="ident">order_elements</span></span>(<span>self, order_on, key=None, reverse=False, rename=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorders the list of elements depending on the parameter <code>order_on</code> as follows:</p>
<ul>
<li><code>order_on='abundance'</code>: Orders elements from highest abundance to lowest.</li>
<li><code>order_on='string'</code>: Orders elements according to the lexicographic order of their strings.</li>
<li><code>order_on='string length'</code>: Orders elements according to the lengths of their strings from shortest to longest.</li>
<li><code>order_on='name'</code>: Orders elements alphabetically according to their names.</li>
<li><code>order_on='key'</code>: Orders elements according to the function specified by the parameter <code>key</code>.</li>
</ul>
<p>Note: By default this method will automatically rename the elements according to their new order.
This will not happen if the elements are named via Conway or if the parameter <code>rename = False</code> is passed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_elements(self, order_on, key = None, reverse = False, rename = True):
    &#34;&#34;&#34;
    Reorders the list of elements depending on the parameter ``order_on`` as follows:

    * ``order_on=&#39;abundance&#39;``: Orders elements from highest abundance to lowest.
    * ``order_on=&#39;string&#39;``: Orders elements according to the lexicographic order of their strings.
    * ``order_on=&#39;string length&#39;``: Orders elements according to the lengths of their strings from shortest to longest.
    * ``order_on=&#39;name&#39;``: Orders elements alphabetically according to their names.
    * ``order_on=&#39;key&#39;``: Orders elements according to the function specified by the parameter ``key``.

    Note: By default this method will automatically rename the elements according to their new order.
    This will not happen if the elements are named via Conway or if the parameter ``rename = False`` is passed.
    &#34;&#34;&#34;
    assert order_on in [&#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, &#39;key&#39;], &#34;Invalid parameter passed to order_elements. Valid parameter are &#39;abundance&#39;, &#39;name&#39;, &#39;string&#39;, &#39;string length&#39;, and &#39;key&#39;.&#34;
    pt = self.periodic_table()
    sorted_key = {
        &#39;abundance&#39;: lambda e : pt[e.get_name()][&#39;abundance&#39;],
        &#39;name&#39;: lambda e : pt[e.get_name()][&#39;name&#39;],
        &#39;string&#39;: lambda e : e.get_string(),
        &#39;string length&#39;: lambda e : len(e.get_string()),
        &#39;key&#39;: key
    }
    self.elements = sorted(self.get_elements(), key = sorted_key[order_on])
    if order_on == &#39;abundance&#39;:
        self.elements.reverse()
    if reverse:
        self.elements.reverse()
    if not self.las._is_Conway and rename:
        self._name_elements()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.periodic_table"><code class="name flex">
<span>def <span class="ident">periodic_table</span></span>(<span>self, dec_places=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a periodic table including each element's name, string, relative abundance, and decay.
Returns the periodic table as a nested dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def periodic_table(self, dec_places = 8):
    &#34;&#34;&#34;
    Creates a periodic table including each element&#39;s name, string, relative abundance, and decay.
    Returns the periodic table as a nested dictionary.
    &#34;&#34;&#34;
    return {e.get_name() : {&#39;string&#39; : e.get_string(), 
                            &#39;abundance&#39; : self._get_abundances(dec_places)[i],
                            &#39;decay&#39; : e.get_decay()}
                            for i, e in enumerate(self.get_elements())}</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.print_periodic_table"><code class="name flex">
<span>def <span class="ident">print_periodic_table</span></span>(<span>self, dec_places=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the periodic table. Note the abundances are given as percentages,
so they will differ from Conway's abundances by a factor of <span><span class="MathJax_Preview">10^4</span><script type="math/tex">10^4</script></span>.
The parameter <code>dec_places</code> refers to the accuracy of the abundances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_periodic_table(self, dec_places = 8):
    &#34;&#34;&#34;
    Prints the periodic table. Note the abundances are given as percentages, 
    so they will differ from Conway&#39;s abundances by a factor of \\(10^4\\).
    The parameter ``dec_places`` refers to the accuracy of the abundances.
    &#34;&#34;&#34;
    pt = self.periodic_table(dec_places)
    elt_width = 2 + max(len(&#39;element&#39;), max([len(e.get_name()) for e in self.get_elements()]))
    str_width = 2 + max(len(&#39;string&#39;), max([len(e.get_string()) for e in self.get_elements()]))
    ab_width  = 2 + max(len(&#39;abundance&#39;), max([len(str(prop[&#39;abundance&#39;])) for elt, prop in pt.items()]))
    print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(&#39;element&#39;, &#39;string&#39;, &#39;abundance&#39;, &#39;decay&#39;, elt_width=elt_width, str_width=str_width, ab_width=ab_width))
    for elt, prop in pt.items():
        print(&#34;{:&lt;{elt_width}} {:&lt;{str_width}} {:&lt;{ab_width}} {}&#34;.format(elt, prop[&#39;string&#39;], prop[&#39;abundance&#39;], str(prop[&#39;decay&#39;]), elt_width=elt_width, str_width=str_width, ab_width=ab_width))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>string, las, decay=[])</span>
</code></dt>
<dd>
<div class="desc"><p>An element consists of a string (usually a chunk of digits) and
a name. For example, in Conway's chemistry there is an element
named H (short for Hydrogen) consisting of the string '22'.
Each element decays into a list of other elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element():
    &#34;&#34;&#34;
    An element consists of a string (usually a chunk of digits) and 
    a name. For example, in Conway&#39;s chemistry there is an element
    named H (short for Hydrogen) consisting of the string &#39;22&#39;. 
    Each element decays into a list of other elements. 
    &#34;&#34;&#34;
    def __init__(self, string, las, decay = []):
        super(Element, self).__init__()
        self.string = string
        self.las = las
        self.name = string
        self.decay = decay

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        if isinstance(other, Element):
                return self.string == other.string and self.las == other.las
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        return hash(tuple(sorted(self.__dict__.items())))

    def _set_decay(self, elements):
        self.decay = elements

    def get_decay(self):
        &#34;&#34;&#34;Returns the decay of the element as a list of elements.&#34;&#34;&#34;
        return self.decay

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def get_string(self):
        return self.string</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Element.get_decay"><code class="name flex">
<span>def <span class="ident">get_decay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the decay of the element as a list of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decay(self):
    &#34;&#34;&#34;Returns the decay of the element as a list of elements.&#34;&#34;&#34;
    return self.decay</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    return self.name</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.get_string"><code class="name flex">
<span>def <span class="ident">get_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string(self):
    return self.string</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    self.name = name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.LookAndSay"><code class="flex name class">
<span>class <span class="ident">LookAndSay</span></span>
<span>(</span><span>say=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class responsible for the fundamental say-what-you-see operation
that generates a look and say sequence. The parameter <code>say</code> in the
constructor is a function that determines the decay of chunk of the form
<span><span class="MathJax_Preview">a^b</span><script type="math/tex">a^b</script></span>. The say function can have one or two parameters:</p>
<ul>
<li>If the say function accepts one parameter, the LookAndSay object will correspond to the decay <span><span class="MathJax_Preview">a^b\to say(b)a</span><script type="math/tex">a^b\to say(b)a</script></span>.</li>
<li>If the say function accepts two parameters, the LookAndSay object will correspond to the decay <span><span class="MathJax_Preview">a^b\to say(b, a)</span><script type="math/tex">a^b\to say(b, a)</script></span>.</li>
</ul>
<p>When no parameter is passed to the constructor, the LookAndSay
object will correspond to standard base ten look and say sequences.</p>
<h2 id="example-session-default-constructor">Example Session: Default Constructor.</h2>
<p>The following example uses the default (standard) look and say sequences.
Note that the ratio of lengths are approaching Conway's constant.</p>
<pre><code class="language-python">ls = LookAndSay()  
ls.generate_sequence('55555', 50)
sequence = ls.get_sequence()
first_terms = sequence[:10]
print('Sequence:', first_terms)
print('Ratios of lengths:', ls.get_length_ratios())
print('Just the last ratio:', ls.get_last_length_ratio())
</code></pre>
<h3 id="output">Output:</h3>
<pre><code class="language-sh">Sequence: ['55555', '55', '25', '1215', '11121115', '31123115', '132112132115', '11131221121113122115', '311311222112311311222115', '1321132132211213211321322115']
Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331, 1.2996264674493063, 1.3030178608088687, 1.3061288797857256, 1.3046441495778045, 1.300263510702233, 1.304700277323473, 1.3052921299324176, 1.299567840664732, 1.3057126333376172, 1.304461231821649, 1.3014789104353732, 1.3050192770385831, 1.304147670163319, 1.3026438489740129, 1.3036460274187538]
Just the last ratio: 1.3036460274187538
</code></pre>
<h2 id="example-sessions-one-parameter-say-functions">Example Sessions: One parameter say functions</h2>
<p>Here is an implementation of a Roman look and say:</p>
<pre><code class="language-python">def roman_say(num):
    assert num &lt; 10, &quot;This Roman can only count to 9.&quot;
    roman = {1:'I', 2:'II', 3:'III', 4:'IV', 5:'V', 6:'VI', 7:'VII', 8:'VIII', 9:'IX'}
    return roman[num]

roman_ls = LookAndSay(roman_say)

roman_ls.generate_sequence('I', 10)
print(roman_ls.get_sequence())

roman_ls.generate_sequence('V', 10)
print(roman_ls.get_sequence())
</code></pre>
<h3 id="output_1">Output:</h3>
<pre><code class="language-sh">['I', 'II', 'III', 'IIII', 'IVI', 'IIIVII', 'IIIIIVIII', 'VIIVIIII', 'IVIIIIVIVI', 'IIIVIVIIVIIIVII', 'IIIIIVIIIVIIIIVIIIIIVIII']
['V', 'IV', 'IIIV', 'IIIIIV', 'VIIV', 'IVIIIIV', 'IIIVIVIIV', 'IIIIIVIIIVIIIIV', 'VIIVIIIIIVIVIIV', 'IVIIIIVVIIVIIIVIIIIV', 'IIIVIVIIIVIIIIVIIIIIVIVIIV']
</code></pre>
<p>Here is a standard binary look and say:</p>
<pre><code class="language-python">def binary_say(num):
    return &quot;{0:b}&quot;.format(num)

binary_ls = LookAndSay(binary_say)

binary_ls.generate_sequence('0', 9)
print(binary_ls.get_sequence())

binary_ls.generate_sequence('1', 9)
print(binary_ls.get_sequence())
</code></pre>
<h3 id="output_2">Output:</h3>
<pre><code class="language-sh">['0', '10', '1110', '11110', '100110', '1110010110', '111100111010110', '100110011110111010110', '1110010110010011011110111010110', '1111001110101100111001011010011011110111010110']
['1', '11', '101', '111011', '11110101', '100110111011', '111001011011110101', '111100111010110100110111011', '100110011110111010110111001011011110101', '1110010110010011011110111010110111100111010110100110111011']
</code></pre>
<h2 id="example-sessions-two-parameter-say-functions">Example Sessions: Two parameter say functions</h2>
<p>Here is a <em>look-and-say-again</em> from the paper <em>Stuttering Conway Sequences Are Still Conway Sequences</em> by Brier et al.</p>
<pre><code class="language-python">def say_again(char_count, char):
    return 2 * str(char_count) + 2 * char

look_and_say_again = LookAndSay(say_again)

look_and_say_again.generate_sequence('1', 10)
print(look_and_say_again.get_sequence())

look_and_say_again.generate_sequence('2', 10)
print(look_and_say_again.get_sequence())
</code></pre>
<h3 id="output_3">Output:</h3>
<pre><code class="language-sh">['1', '1111', '4411', '22442211', '2222224422222211', '6622224466222211', '226644222244226644222211', '2222226622444422224422222266224444222211', '662222662222444444222244662222662222444444222211', '22664422226644226644442222442266442222664422664444222211', '2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211']
['2', '1122', '22112222', '222222114422', '6622221122442222', '226644222211222222444422', '22222266224444222211662244442222', '6622226622224444442222112266222244444422', '226644222266442266444422221122222266442266442222', '222222662244442222662244222222664444442222116622226622442222226622444422', '66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222']
</code></pre>
<p>Here is Morrill's <em>Look Knave</em>.</p>
<pre><code class="language-python">def knave_say(bit_count, bit):
    flip = {'0':'1', '1':'0'}
    return &quot;{0:b}&quot;.format(bit_count) + flip[bit]

look_knave = LookAndSay(knave_say)

look_knave.generate_sequence('0', 12)
print(look_knave.get_sequence())

look_knave.generate_sequence('1', 12)
print(look_knave.get_sequence())
</code></pre>
<h3 id="output_4">Output:</h3>
<pre><code class="language-sh">['0', '11', '100', '10101', '1011101110', '10111101111011', '1011100011100011100', '1011110111110111110101', '1011100011101011101011101110', '10111101111101110111101110111101111011', '10111000111010111101110001111011100011100011100', '1011110111110111011100011110111100011110111110111110101', '1011100011101011110111101111000111000111100011101011101011101110']
['1', '10', '1011', '1011100', '1011110101', '1011100011101110', '10111101111101111011', '1011100011101011100011100', '1011110111110111011110111110101', '101110001110101111011100011101011101110', '10111101111101110111000111101111101110111101111011', '10111000111010111101111011110001110101111011100011100011100', '10111101111101110111000111000111000111110111011100011110111110111110101']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LookAndSay():
    &#34;&#34;&#34;
    A class responsible for the fundamental say-what-you-see operation
    that generates a look and say sequence. The parameter ``say`` in the
    constructor is a function that determines the decay of chunk of the form
    \\(a^b\\). The say function can have one or two parameters:

    * If the say function accepts one parameter, the LookAndSay object will correspond to the decay \\(a^b\\to say(b)a\\).
    * If the say function accepts two parameters, the LookAndSay object will correspond to the decay \\(a^b\\to say(b, a)\\).

    When no parameter is passed to the constructor, the LookAndSay
    object will correspond to standard base ten look and say sequences.

    
    ## Example Session: Default Constructor. 
    The following example uses the default (standard) look and say sequences.
    Note that the ratio of lengths are approaching Conway&#39;s constant.
    ```python 
    ls = LookAndSay()  
    ls.generate_sequence(&#39;55555&#39;, 50)
    sequence = ls.get_sequence()
    first_terms = sequence[:10]
    print(&#39;Sequence:&#39;, first_terms)
    print(&#39;Ratios of lengths:&#39;, ls.get_length_ratios())
    print(&#39;Just the last ratio:&#39;, ls.get_last_length_ratio())
    ```
    ### Output:

    ```sh
    Sequence: [&#39;55555&#39;, &#39;55&#39;, &#39;25&#39;, &#39;1215&#39;, &#39;11121115&#39;, &#39;31123115&#39;, &#39;132112132115&#39;, &#39;11131221121113122115&#39;, &#39;311311222112311311222115&#39;, &#39;1321132132211213211321322115&#39;]
    Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331, 1.2996264674493063, 1.3030178608088687, 1.3061288797857256, 1.3046441495778045, 1.300263510702233, 1.304700277323473, 1.3052921299324176, 1.299567840664732, 1.3057126333376172, 1.304461231821649, 1.3014789104353732, 1.3050192770385831, 1.304147670163319, 1.3026438489740129, 1.3036460274187538]
    Just the last ratio: 1.3036460274187538
    ```

    ## Example Sessions: One parameter say functions

    Here is an implementation of a Roman look and say:
    ```python
    def roman_say(num):
        assert num &lt; 10, &#34;This Roman can only count to 9.&#34;
        roman = {1:&#39;I&#39;, 2:&#39;II&#39;, 3:&#39;III&#39;, 4:&#39;IV&#39;, 5:&#39;V&#39;, 6:&#39;VI&#39;, 7:&#39;VII&#39;, 8:&#39;VIII&#39;, 9:&#39;IX&#39;}
        return roman[num]

    roman_ls = LookAndSay(roman_say)

    roman_ls.generate_sequence(&#39;I&#39;, 10)
    print(roman_ls.get_sequence())

    roman_ls.generate_sequence(&#39;V&#39;, 10)
    print(roman_ls.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IIII&#39;, &#39;IVI&#39;, &#39;IIIVII&#39;, &#39;IIIIIVIII&#39;, &#39;VIIVIIII&#39;, &#39;IVIIIIVIVI&#39;, &#39;IIIVIVIIVIIIVII&#39;, &#39;IIIIIVIIIVIIIIVIIIIIVIII&#39;]
    [&#39;V&#39;, &#39;IV&#39;, &#39;IIIV&#39;, &#39;IIIIIV&#39;, &#39;VIIV&#39;, &#39;IVIIIIV&#39;, &#39;IIIVIVIIV&#39;, &#39;IIIIIVIIIVIIIIV&#39;, &#39;VIIVIIIIIVIVIIV&#39;, &#39;IVIIIIVVIIVIIIVIIIIV&#39;, &#39;IIIVIVIIIVIIIIVIIIIIVIVIIV&#39;]
    ```
    Here is a standard binary look and say:
    ```python
    def binary_say(num):
        return &#34;{0:b}&#34;.format(num)

    binary_ls = LookAndSay(binary_say)

    binary_ls.generate_sequence(&#39;0&#39;, 9)
    print(binary_ls.get_sequence())

    binary_ls.generate_sequence(&#39;1&#39;, 9)
    print(binary_ls.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;0&#39;, &#39;10&#39;, &#39;1110&#39;, &#39;11110&#39;, &#39;100110&#39;, &#39;1110010110&#39;, &#39;111100111010110&#39;, &#39;100110011110111010110&#39;, &#39;1110010110010011011110111010110&#39;, &#39;1111001110101100111001011010011011110111010110&#39;]
    [&#39;1&#39;, &#39;11&#39;, &#39;101&#39;, &#39;111011&#39;, &#39;11110101&#39;, &#39;100110111011&#39;, &#39;111001011011110101&#39;, &#39;111100111010110100110111011&#39;, &#39;100110011110111010110111001011011110101&#39;, &#39;1110010110010011011110111010110111100111010110100110111011&#39;]
    ```
    ## Example Sessions: Two parameter say functions

    Here is a *look-and-say-again* from the paper *Stuttering Conway Sequences Are Still Conway Sequences* by Brier et al.
    ```python
    def say_again(char_count, char):
        return 2 * str(char_count) + 2 * char

    look_and_say_again = LookAndSay(say_again)

    look_and_say_again.generate_sequence(&#39;1&#39;, 10)
    print(look_and_say_again.get_sequence())

    look_and_say_again.generate_sequence(&#39;2&#39;, 10)
    print(look_and_say_again.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;1&#39;, &#39;1111&#39;, &#39;4411&#39;, &#39;22442211&#39;, &#39;2222224422222211&#39;, &#39;6622224466222211&#39;, &#39;226644222244226644222211&#39;, &#39;2222226622444422224422222266224444222211&#39;, &#39;662222662222444444222244662222662222444444222211&#39;, &#39;22664422226644226644442222442266442222664422664444222211&#39;, &#39;2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211&#39;]
    [&#39;2&#39;, &#39;1122&#39;, &#39;22112222&#39;, &#39;222222114422&#39;, &#39;6622221122442222&#39;, &#39;226644222211222222444422&#39;, &#39;22222266224444222211662244442222&#39;, &#39;6622226622224444442222112266222244444422&#39;, &#39;226644222266442266444422221122222266442266442222&#39;, &#39;222222662244442222662244222222664444442222116622226622442222226622444422&#39;, &#39;66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222&#39;]
    ```
    Here is Morrill&#39;s *Look Knave*.
    ```python
    def knave_say(bit_count, bit):
        flip = {&#39;0&#39;:&#39;1&#39;, &#39;1&#39;:&#39;0&#39;}
        return &#34;{0:b}&#34;.format(bit_count) + flip[bit]

    look_knave = LookAndSay(knave_say)

    look_knave.generate_sequence(&#39;0&#39;, 12)
    print(look_knave.get_sequence())

    look_knave.generate_sequence(&#39;1&#39;, 12)
    print(look_knave.get_sequence())
    ```
    ### Output:

    ```sh
    [&#39;0&#39;, &#39;11&#39;, &#39;100&#39;, &#39;10101&#39;, &#39;1011101110&#39;, &#39;10111101111011&#39;, &#39;1011100011100011100&#39;, &#39;1011110111110111110101&#39;, &#39;1011100011101011101011101110&#39;, &#39;10111101111101110111101110111101111011&#39;, &#39;10111000111010111101110001111011100011100011100&#39;, &#39;1011110111110111011100011110111100011110111110111110101&#39;, &#39;1011100011101011110111101111000111000111100011101011101011101110&#39;]
    [&#39;1&#39;, &#39;10&#39;, &#39;1011&#39;, &#39;1011100&#39;, &#39;1011110101&#39;, &#39;1011100011101110&#39;, &#39;10111101111101111011&#39;, &#39;1011100011101011100011100&#39;, &#39;1011110111110111011110111110101&#39;, &#39;101110001110101111011100011101011101110&#39;, &#39;10111101111101110111000111101111101110111101111011&#39;, &#39;10111000111010111101111011110001110101111011100011100011100&#39;, &#39;10111101111101110111000111000111000111110111011100011110111110111110101&#39;]
    ```
    &#34;&#34;&#34;
    def __init__(self, say = None):
        super(LookAndSay, self).__init__()
        self._is_Conway = False
        if say == None:
            say = (lambda n : str(n))
            self._is_Conway = True
        self.say = say
        self.sequence = []

    def _chunk_op(self, char_count, char):
        &#34;&#34;&#34;
        Conversion of the say function to a two parameter function 
        if the say function takes only one parameter; 
        just a copy of the say function otherwise.
        &#34;&#34;&#34;
        try:
            return self.say(char_count, char)
        except:
            return self.say(char_count) + char

    def get_sequence(self):
        &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
        return self.sequence

    def say_what_you_see(self, string):
        &#34;&#34;&#34;
        The fundamental look and say operation that generates each 
        term of a look and say sequence from its predecessor. For example, 
        using the standard (default) LookAndSay object, 
        ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
        &#34;&#34;&#34;
        if not string: return None # handles empty string, which is falsy
        letter = string[0]
        result = &#39;&#39;
        count = 0
        for ch in string:
            if ch == letter: 
                count += 1
            else:
                result += self._chunk_op(count, letter)
                count = 1
                letter = ch 
        result += self._chunk_op(count, letter)
        return result
     
    def generate_sequence(self, seed, num_iterations):
        &#34;&#34;&#34;
        Generates the look and say sequence. The parameter ``seed`` is 
        the initial term in the sequence, and ``num_iterations`` is the 
        number of terms generated.
        &#34;&#34;&#34;
        if not seed: return None # handles empty seed, which is falsy
        result = [seed]
        for _ in range(num_iterations):
            result.append(self.say_what_you_see(result[-1]))
        self.sequence = result

    def get_length_ratios(self):
        &#34;&#34;&#34;
        Returns a list of the ratios of lengths of 
        successive terms in the look and say sequence.
        &#34;&#34;&#34;
        num_iterations = len(self.sequence)
        assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
        return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]

    def get_last_length_ratio(self):
        &#34;&#34;&#34;
        Returns the ratio of the lengths of the last 
        two terms of the look and say sequence
        &#34;&#34;&#34;
        return self.get_length_ratios()[-1]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.LookAndSay.generate_sequence"><code class="name flex">
<span>def <span class="ident">generate_sequence</span></span>(<span>self, seed, num_iterations)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the look and say sequence. The parameter <code>seed</code> is
the initial term in the sequence, and <code>num_iterations</code> is the
number of terms generated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_sequence(self, seed, num_iterations):
    &#34;&#34;&#34;
    Generates the look and say sequence. The parameter ``seed`` is 
    the initial term in the sequence, and ``num_iterations`` is the 
    number of terms generated.
    &#34;&#34;&#34;
    if not seed: return None # handles empty seed, which is falsy
    result = [seed]
    for _ in range(num_iterations):
        result.append(self.say_what_you_see(result[-1]))
    self.sequence = result</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_last_length_ratio"><code class="name flex">
<span>def <span class="ident">get_last_length_ratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ratio of the lengths of the last
two terms of the look and say sequence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_length_ratio(self):
    &#34;&#34;&#34;
    Returns the ratio of the lengths of the last 
    two terms of the look and say sequence
    &#34;&#34;&#34;
    return self.get_length_ratios()[-1]</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_length_ratios"><code class="name flex">
<span>def <span class="ident">get_length_ratios</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the ratios of lengths of
successive terms in the look and say sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length_ratios(self):
    &#34;&#34;&#34;
    Returns a list of the ratios of lengths of 
    successive terms in the look and say sequence.
    &#34;&#34;&#34;
    num_iterations = len(self.sequence)
    assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
    return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_sequence"><code class="name flex">
<span>def <span class="ident">get_sequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the look and say sequence as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequence(self):
    &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
    return self.sequence</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.say_what_you_see"><code class="name flex">
<span>def <span class="ident">say_what_you_see</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>The fundamental look and say operation that generates each
term of a look and say sequence from its predecessor. For example,
using the standard (default) LookAndSay object,
<code>say_what_you_see('1112222333')</code> returns <code>'314233'</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def say_what_you_see(self, string):
    &#34;&#34;&#34;
    The fundamental look and say operation that generates each 
    term of a look and say sequence from its predecessor. For example, 
    using the standard (default) LookAndSay object, 
    ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
    &#34;&#34;&#34;
    if not string: return None # handles empty string, which is falsy
    letter = string[0]
    result = &#39;&#39;
    count = 0
    for ch in string:
        if ch == letter: 
            count += 1
        else:
            result += self._chunk_op(count, letter)
            count = 1
            letter = ch 
    result += self._chunk_op(count, letter)
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.SplitFuncFactory"><code class="flex name class">
<span>class <span class="ident">SplitFuncFactory</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to help create a split function. The split function factory
can produce a split function via any combination of the following:</p>
<ul>
<li>Specifying specific chunks L and R such that LR splits as L.R.</li>
<li>Specifying specific characters or chunks to always split before or after.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SplitFuncFactory():
    &#34;&#34;&#34;
    A class to help create a split function. The split function factory
    can produce a split function via any combination of the following:

    * Specifying specific chunks L and R such that LR splits as L.R.
    * Specifying specific characters or chunks to always split before or after.

    &#34;&#34;&#34;
    def __init__(self):
        self._splitting_pairs = []
        self._chunks_before_split = []
        self._chunks_after_split = []
        self._split_conditions = []

    def get_split(self):
        &#34;&#34;&#34;Return the split function&#34;&#34;&#34;
        return lambda string : self._split(string)

    def _split(self, string):
        chunks = []
        start = 0
        for i in range(1, len(string)):
            if self._is_split(string[start:i], string[i:]):
                chunks.append(string[start:i])
                start = i
        chunks.append(string[start:])
        return chunks

    def _is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
            return True
        if L[-1] == R[0]:
            return False
        for l in self._chunks_before_split:
            if len(l) &lt;= len(L) and l == L[-len(l):]:
                return True
        for r in self._chunks_after_split:
            if len(r) &lt;= len(R) and r == R[:len(r)]:
                return True
        for l, r in self._splitting_pairs:
            if len(l) &lt;= len(L) and len(r) &lt;= len(R) and l == L[-len(l):] and r == R[:len(r)]:
                return True
        for condition in self._split_conditions:
            if condition(L, R):
                return True
        return False

    def declare_splitting_pairs(self, *pairs):
        &#34;&#34;&#34;
        Specify pairs of chunks in the form (L, R) 
        such that LR always splits as L.R
        &#34;&#34;&#34;
        for pair in pairs:
            self._splitting_pairs.append(pair)

    def declare_split_after(self, *chunks):
        &#34;&#34;&#34;Specify chunks L such that LR splits for every possible R&#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_before_split.append(chunk)

    def declare_split_before(self, *chunks):
        &#34;&#34;&#34;Specify chunks R such that LR splits for every possible L&#34;&#34;&#34;
        for chunk in chunks:
            self._chunks_after_split.append(chunk)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.SplitFuncFactory.declare_split_after"><code class="name flex">
<span>def <span class="ident">declare_split_after</span></span>(<span>self, *chunks)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify chunks L such that LR splits for every possible R</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_split_after(self, *chunks):
    &#34;&#34;&#34;Specify chunks L such that LR splits for every possible R&#34;&#34;&#34;
    for chunk in chunks:
        self._chunks_before_split.append(chunk)</code></pre>
</details>
</dd>
<dt id="look_and_say.SplitFuncFactory.declare_split_before"><code class="name flex">
<span>def <span class="ident">declare_split_before</span></span>(<span>self, *chunks)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify chunks R such that LR splits for every possible L</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_split_before(self, *chunks):
    &#34;&#34;&#34;Specify chunks R such that LR splits for every possible L&#34;&#34;&#34;
    for chunk in chunks:
        self._chunks_after_split.append(chunk)</code></pre>
</details>
</dd>
<dt id="look_and_say.SplitFuncFactory.declare_splitting_pairs"><code class="name flex">
<span>def <span class="ident">declare_splitting_pairs</span></span>(<span>self, *pairs)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify pairs of chunks in the form (L, R)
such that LR always splits as L.R</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_splitting_pairs(self, *pairs):
    &#34;&#34;&#34;
    Specify pairs of chunks in the form (L, R) 
    such that LR always splits as L.R
    &#34;&#34;&#34;
    for pair in pairs:
        self._splitting_pairs.append(pair)</code></pre>
</details>
</dd>
<dt id="look_and_say.SplitFuncFactory.get_split"><code class="name flex">
<span>def <span class="ident">get_split</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the split function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_split(self):
    &#34;&#34;&#34;Return the split function&#34;&#34;&#34;
    return lambda string : self._split(string)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="look_and_say.split_Conway" href="#look_and_say.split_Conway">split_Conway</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="look_and_say.BinaryChemistry" href="#look_and_say.BinaryChemistry">BinaryChemistry</a></code></h4>
</li>
<li>
<h4><code><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Chemistry.clear_elements" href="#look_and_say.Chemistry.clear_elements">clear_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.generate_elements" href="#look_and_say.Chemistry.generate_elements">generate_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_char_poly" href="#look_and_say.Chemistry.get_char_poly">get_char_poly</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_decay_matrix" href="#look_and_say.Chemistry.get_decay_matrix">get_decay_matrix</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_elements" href="#look_and_say.Chemistry.get_elements">get_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_max_eigenvalue" href="#look_and_say.Chemistry.get_max_eigenvalue">get_max_eigenvalue</a></code></li>
<li><code><a title="look_and_say.Chemistry.order_elements" href="#look_and_say.Chemistry.order_elements">order_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.periodic_table" href="#look_and_say.Chemistry.periodic_table">periodic_table</a></code></li>
<li><code><a title="look_and_say.Chemistry.print_periodic_table" href="#look_and_say.Chemistry.print_periodic_table">print_periodic_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.Element" href="#look_and_say.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Element.get_decay" href="#look_and_say.Element.get_decay">get_decay</a></code></li>
<li><code><a title="look_and_say.Element.get_name" href="#look_and_say.Element.get_name">get_name</a></code></li>
<li><code><a title="look_and_say.Element.get_string" href="#look_and_say.Element.get_string">get_string</a></code></li>
<li><code><a title="look_and_say.Element.set_name" href="#look_and_say.Element.set_name">set_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.LookAndSay" href="#look_and_say.LookAndSay">LookAndSay</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.LookAndSay.generate_sequence" href="#look_and_say.LookAndSay.generate_sequence">generate_sequence</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_last_length_ratio" href="#look_and_say.LookAndSay.get_last_length_ratio">get_last_length_ratio</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_length_ratios" href="#look_and_say.LookAndSay.get_length_ratios">get_length_ratios</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_sequence" href="#look_and_say.LookAndSay.get_sequence">get_sequence</a></code></li>
<li><code><a title="look_and_say.LookAndSay.say_what_you_see" href="#look_and_say.LookAndSay.say_what_you_see">say_what_you_see</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.SplitFuncFactory" href="#look_and_say.SplitFuncFactory">SplitFuncFactory</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.SplitFuncFactory.declare_split_after" href="#look_and_say.SplitFuncFactory.declare_split_after">declare_split_after</a></code></li>
<li><code><a title="look_and_say.SplitFuncFactory.declare_split_before" href="#look_and_say.SplitFuncFactory.declare_split_before">declare_split_before</a></code></li>
<li><code><a title="look_and_say.SplitFuncFactory.declare_splitting_pairs" href="#look_and_say.SplitFuncFactory.declare_splitting_pairs">declare_splitting_pairs</a></code></li>
<li><code><a title="look_and_say.SplitFuncFactory.get_split" href="#look_and_say.SplitFuncFactory.get_split">get_split</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>