<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>look_and_say API documentation</title>
<meta name="description" content="A module for playing with look and say sequences in the spirit of John Conway." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>look_and_say</code></h1>
</header>
<section id="section-intro">
<p>A module for playing with look and say sequences in the spirit of John Conway.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    A module for playing with look and say sequences in the spirit of John Conway.
&#34;&#34;&#34;

import numpy
import sympy


def split_Conway(string):
    &#34;&#34;&#34;
    Splits a string into a list of substrings according to Conway&#39;s Splitting Theorem.
    Assumes the string is not empty. 

    Example usage:

        string = &#39;121113&#39;
        chunks = split_Conway(string)
        print(chunks)

    Output:

        ```
        [&#39;12&#39;, &#39;1113&#39;]
        ```
    &#34;&#34;&#34;
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if _is_split_pair_Conway(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks

def _is_split_pair_Conway(L, R):
    &#34;&#34;&#34;Implementation of Conway&#39;s Splitting Theorem&#34;&#34;&#34;
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    if L[-1] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and R[0] in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]: # n] and [m
            return True
    if L[-1] == &#39;2&#39;: # 2]
            if len(R) &gt; 1 and R[0] == &#39;1&#39; and R[1] != &#39;1&#39; and (len(R) == 2 or R[2] != R[1]): #[1^1X^1
                    return True
            if len(R) &gt; 2 and R[0] == &#39;1&#39; and R[1] == &#39;1&#39; and R[2] == &#39;1&#39; and (len(R) == 3 or R[3] != &#39;1&#39;): #[1^3
                    return True
            if R[0] == &#39;3&#39; and (len(R) == 1 or (R[1] != &#39;3&#39; and (len(R) &lt; 4 or R[2] != R[1] or R[3] != R[1]))): #[3^1X^\not=3
                    return True
            if R[0] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 1 or R[1] != R[0]): #[n^1
                    return True
    if L[-1] != &#39;2&#39; and len(R) &gt; 1 and R[0] == &#39;2&#39; and R[1] == &#39;2&#39;: # \not=2]
            if len(R) &gt; 3 and R[2] == &#39;1&#39; and R[3] != &#39;1&#39; and (len(R) == 4 or R[4] != R[3]): #[2^21^1X^1
                    return True
            if len(R) &gt; 4 and R[2] == &#39;1&#39; and R[3] == &#39;1&#39; and R[4] == &#39;1&#39; and (len(R) == 5 or R[5] != &#39;1&#39;): #[2^21^3
                    return True
            if len(R) &gt; 2 and R[2] == &#39;3&#39; and (len(R) == 3 or (R[3] != &#39;3&#39; and (len(R) &lt; 6 or R[4] != R[3] or R[5] != R[3]))): #[2^23^1X^\not=3
                    return True 
            if len(R) == 2 or (len(R) &gt; 2 and R[2] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 3 or R[3] != R[2])): #[2^2n^(0 or 1)
                    return True
    return False

class LookAndSay():
    &#34;&#34;&#34;
    A class responsible for the fundamental say-what-you-see operation
    that generates a look and say sequence. The parameter ``say`` in the
    constructor is a function that determines the decay of chunk of the form
    \\(a^b\\). The say function can have one or two parameters:

    * If the say function accepts one parameter, the LookAndSay object will correspond to the decay \\(a^b\\to say(b)a\\).
    * If the say function accepts two parameters, the LookAndSay object will correspond to the decay \\(a^b\\to say(b, a)\\).

    When no parameter is passed to the constructor, the LookAndSay
    object will correspond to standard base ten look and say sequences.

    The following example uses the default (standard) look and say sequences.
    Note that the ratio of lengths are approaching Conway&#39;s constant.
        
        ls = LookAndSay()  
        ls.generate_sequence(&#39;55555&#39;, 50)
        sequence = ls.get_sequence()
        first_terms = sequence[:10]
        print(&#39;Sequence:&#39;, first_terms)
        print(&#39;Ratios of lengths:&#39;, ls.get_length_ratios())
        print(&#39;Just the last ratio:&#39;, ls.get_last_length_ratio())

    Output:

        ```
        Sequence: [&#39;55555&#39;, &#39;55&#39;, &#39;25&#39;, &#39;1215&#39;, &#39;11121115&#39;, &#39;31123115&#39;, &#39;132112132115&#39;, &#39;11131221121113122115&#39;, &#39;311311222112311311222115&#39;, &#39;1321132132211213211321322115&#39;]
        Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331, 1.2996264674493063, 1.3030178608088687, 1.3061288797857256, 1.3046441495778045, 1.300263510702233, 1.304700277323473, 1.3052921299324176, 1.299567840664732, 1.3057126333376172, 1.304461231821649, 1.3014789104353732, 1.3050192770385831, 1.304147670163319, 1.3026438489740129, 1.3036460274187538]
        Just the last ratio: 1.3036460274187538
        ```

    Here is a Roman look and say:

        def roman_say(num):
            assert num &lt; 10, &#34;This Roman can only count to 9.&#34;
            roman = {1:&#39;I&#39;, 2:&#39;II&#39;, 3:&#39;III&#39;, 4:&#39;IV&#39;, 5:&#39;V&#39;, 6:&#39;VI&#39;, 7:&#39;VII&#39;, 8:&#39;VIII&#39;, 9:&#39;IX&#39;}
            return roman[num]

        roman_ls = LookAndSay(roman_say)

        roman_ls.generate_sequence(&#39;I&#39;, 10)
        print(roman_ls.get_sequence())

        roman_ls.generate_sequence(&#39;V&#39;, 10)
        print(roman_ls.get_sequence())

    Output:

        ```
        [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IIII&#39;, &#39;IVI&#39;, &#39;IIIVII&#39;, &#39;IIIIIVIII&#39;, &#39;VIIVIIII&#39;, &#39;IVIIIIVIVI&#39;, &#39;IIIVIVIIVIIIVII&#39;, &#39;IIIIIVIIIVIIIIVIIIIIVIII&#39;]
        [&#39;V&#39;, &#39;IV&#39;, &#39;IIIV&#39;, &#39;IIIIIV&#39;, &#39;VIIV&#39;, &#39;IVIIIIV&#39;, &#39;IIIVIVIIV&#39;, &#39;IIIIIVIIIVIIIIV&#39;, &#39;VIIVIIIIIVIVIIV&#39;, &#39;IVIIIIVVIIVIIIVIIIIV&#39;, &#39;IIIVIVIIIVIIIIVIIIIIVIVIIV&#39;]
        ```
    
    Here is a standard binary look and say:

        def binary_say(num):
            return &#34;{0:b}&#34;.format(num)

        binary_ls = LookAndSay(binary_say)

        binary_ls.generate_sequence(&#39;0&#39;, 9)
        print(binary_ls.get_sequence())

        binary_ls.generate_sequence(&#39;1&#39;, 9)
        print(binary_ls.get_sequence())

    Output:

        ```
        [&#39;0&#39;, &#39;10&#39;, &#39;1110&#39;, &#39;11110&#39;, &#39;100110&#39;, &#39;1110010110&#39;, &#39;111100111010110&#39;, &#39;100110011110111010110&#39;, &#39;1110010110010011011110111010110&#39;, &#39;1111001110101100111001011010011011110111010110&#39;]
        [&#39;1&#39;, &#39;11&#39;, &#39;101&#39;, &#39;111011&#39;, &#39;11110101&#39;, &#39;100110111011&#39;, &#39;111001011011110101&#39;, &#39;111100111010110100110111011&#39;, &#39;100110011110111010110111001011011110101&#39;, &#39;1110010110010011011110111010110111100111010110100110111011&#39;]
        ```
    
    Here is a *look-and-say-again* from the paper *Stuttering Conway Sequences Are Still Conway Sequences* by Brier et al.
    
        def say_again(char_count, char):
            return 2 * str(char_count) + 2 * char

        look_and_say_again = LookAndSay(say_again)

        look_and_say_again.generate_sequence(&#39;1&#39;, 10)
        print(look_and_say_again.get_sequence())

        look_and_say_again.generate_sequence(&#39;2&#39;, 10)
        print(look_and_say_again.get_sequence())

    Output:

        ```
        [&#39;1&#39;, &#39;1111&#39;, &#39;4411&#39;, &#39;22442211&#39;, &#39;2222224422222211&#39;, &#39;6622224466222211&#39;, &#39;226644222244226644222211&#39;, &#39;2222226622444422224422222266224444222211&#39;, &#39;662222662222444444222244662222662222444444222211&#39;, &#39;22664422226644226644442222442266442222664422664444222211&#39;, &#39;2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211&#39;]
        [&#39;2&#39;, &#39;1122&#39;, &#39;22112222&#39;, &#39;222222114422&#39;, &#39;6622221122442222&#39;, &#39;226644222211222222444422&#39;, &#39;22222266224444222211662244442222&#39;, &#39;6622226622224444442222112266222244444422&#39;, &#39;226644222266442266444422221122222266442266442222&#39;, &#39;222222662244442222662244222222664444442222116622226622442222226622444422&#39;, &#39;66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222&#39;]
        ```

    Here is Morrill&#39;s *Look Knave*.

        def knave_say(bit_count, bit):
            flip = {&#39;0&#39;:&#39;1&#39;, &#39;1&#39;:&#39;0&#39;}
            return &#34;{0:b}&#34;.format(bit_count) + flip[bit]

        look_knave = LookAndSay(knave_say)

        look_knave.generate_sequence(&#39;0&#39;, 12)
        print(look_knave.get_sequence())

        look_knave.generate_sequence(&#39;1&#39;, 12)
        print(look_knave.get_sequence())

    Output:

        ```
        [&#39;0&#39;, &#39;11&#39;, &#39;100&#39;, &#39;10101&#39;, &#39;1011101110&#39;, &#39;10111101111011&#39;, &#39;1011100011100011100&#39;, &#39;1011110111110111110101&#39;, &#39;1011100011101011101011101110&#39;, &#39;10111101111101110111101110111101111011&#39;, &#39;10111000111010111101110001111011100011100011100&#39;, &#39;1011110111110111011100011110111100011110111110111110101&#39;, &#39;1011100011101011110111101111000111000111100011101011101011101110&#39;]
        [&#39;1&#39;, &#39;10&#39;, &#39;1011&#39;, &#39;1011100&#39;, &#39;1011110101&#39;, &#39;1011100011101110&#39;, &#39;10111101111101111011&#39;, &#39;1011100011101011100011100&#39;, &#39;1011110111110111011110111110101&#39;, &#39;101110001110101111011100011101011101110&#39;, &#39;10111101111101110111000111101111101110111101111011&#39;, &#39;10111000111010111101111011110001110101111011100011100011100&#39;, &#39;10111101111101110111000111000111000111110111011100011110111110111110101&#39;]
        ```

    &#34;&#34;&#34;
    def __init__(self, say = None):
        super(LookAndSay, self).__init__()
        if say == None:
            say = (lambda n : str(n))
        self.say = say
        self.sequence = []

    def _chunk_op(self, char_count, char):
        &#34;&#34;&#34;
        Conversion of the say function to a two parameter function 
        if the say function takes only one parameter; 
        just a copy of the say function otherwise.
        &#34;&#34;&#34;
        try:
            return self.say(char_count, char)
        except:
            return self.say(char_count) + char

    def get_sequence(self):
        &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
        return self.sequence

    def say_what_you_see(self, string):
        &#34;&#34;&#34;
        The fundamental look and say operation that generates each 
        term of a look and say sequence from its predecessor. For example, 
        using the standard (default) LookAndSay object, 
        ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
        &#34;&#34;&#34;
        if not string: return None # handles empty string, which is falsy
        letter = string[0]
        result = &#39;&#39;
        count = 0
        for ch in string:
            if ch == letter: 
                count += 1
            else:
                result += self._chunk_op(count, letter)
                count = 1
                letter = ch 
        result += self._chunk_op(count, letter)
        return result
     
    def generate_sequence(self, seed, num_iterations):
        &#34;&#34;&#34;
        Generates the look and say sequence. The parameter ``seed`` is 
        the initial term in the sequence, and ``num_iterations`` is the 
        number of terms generated.
        &#34;&#34;&#34;
        if not seed: return None # handles empty seed, which is falsy
        result = [seed]
        for _ in range(num_iterations):
            result.append(self.say_what_you_see(result[-1]))
        self.sequence = result

    def get_length_ratios(self):
        &#34;&#34;&#34;
        Returns a list of the ratios of lengths of 
        successive terms in the look and say sequence.
        &#34;&#34;&#34;
        num_iterations = len(self.sequence)
        assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
        return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]

    def get_last_length_ratio(self):
        &#34;&#34;&#34;
        Returns the ratio of the lengths of the last 
        two terms of the look and say sequence
        &#34;&#34;&#34;
        return self.get_length_ratios()[-1]


########### CHEMISTRY #####################

class Chemistry():
    &#34;&#34;&#34;
    A class responsible for generating all the persistent elements 
    appearing in look and say sequences, along with 
    the chemical properties of those elements.

    Parameters in the constructor are a LookAndSay object ``las`` and
    a splitting function ``split``. The user is responsible
    for verifying that the provided splitting function is valid for the given
    LookAndSay object. The default splitting function corresponds to 
    Conway&#39;s original Splitting Theorem.

    &#34;&#34;&#34;
    def __init__(self, las, split = split_Conway, elements = None):
        super(Chemistry, self).__init__()
        self.las = las
        self.split = split
        if elements == None:
            elements = []
        self.elements = elements

    def get_elements(self):
        &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
        return self.elements

    def clear_elements(self):
        &#34;&#34;&#34;Resets the list of elements back to the empty list&#34;&#34;&#34;
        self.elements = []

    def _split_to_elements(self, string): 
        return [Element(chunk, self.las) for chunk in self.split(string)]

    def _generate_all_elements(self, strings):
        for string in strings:
            for elt in self._split_to_elements(string):
                if elt not in self.elements:
                    # add elt to the chemistry:
                    self.elements.append(elt)
                    # recursively set the decay for elt:
                    decay_elts = self._split_to_elements(self.las.say_what_you_see(elt.get_string()))
                    self._generate_all_elements(map(lambda e : e.get_string(), decay_elts))
                    elt._set_decay(decay_elts)
        # clean up decay for all elements:
        for elt in self.elements:
            dec = []
            for d in elt.get_decay():
                dec += [e for e in self.elements if e == d]
            elt._set_decay(dec)

    def _remove_extinct_elements(self): 
        while True:
            common_elements = []
            for elt in self.elements:
                for d in elt.get_decay():
                    if d not in common_elements:
                        common_elements.append(d)
            if len(common_elements) &lt; len(self.elements):
                self.elements = common_elements[:]
            else: 
                break

    def generate_elements(self, seeds, reset = True):
        &#34;&#34;&#34;
        Collects all the persistent elements from all the look and
        say sequences generated by the given seeds. The parameter ``seeds``
        should be a nonempty list of strings. By default, this method will 
        clear any elements in the chemistry that exist before this method is called
        prior to collecting from the given seeds. Use ``reset = False`` 
        to keep the old elements. 
        &#34;&#34;&#34;
        assert type(seeds) == type([&#39;0&#39;]), &#34;The parameter seeds in generate_elements should be a list of strings.&#34;
        if reset:
            self.clear_elements()
        strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
        self._generate_all_elements(strings)
        self._remove_extinct_elements()

    def get_decay_matrix(self):
        &#34;&#34;&#34;
        Returns the decay matrix as a nested list of integers 
        (i.e. a list of the rows).
        The order of the columns and rows correspond to the order
        in the list of elements.
        &#34;&#34;&#34;
        mat = []
        e = self.elements
        for i in range(len(e)):
            row = []
            for j in range(len(e)):
                row.append(e[j].get_decay().count(e[i]))
            mat.append(row)
        return mat

    def get_max_eigenvalue(self):
        &#34;&#34;&#34;
        Returns the maximal real eigenvalue of the decay matrix.
        This method assumes the existence of a real eigenvalue which
        is larger than (the absolute value) of every other eigenvalue.
        This assumption is usually guaranteed by the Perron-Frobenius Theorem.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        return max(eigenvalues).real

    def get_char_poly(self, factor = True):
        &#34;&#34;&#34;
        Returns the characteristic polynomial of the decay matrix using sympy.
        By default the returned polynomial will be factored. 
        Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
        &#34;&#34;&#34;
        chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
        if factor:
            return sympy.factor(chi.as_expr())
        else:
            return chi.as_expr()

    def get_abundances(self):
        &#34;&#34;&#34;
        Returns a list of relative abundances of each element.
        Note that the abundances are given in percentages, so they will
        differ from Conway&#39;s abundances by a factor of \\(10^6\\). 
        The order of the list corresponds to the order of the list of elements.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        eigenvectors = eigenstuff[1]
        index = numpy.where(eigenvalues == max(eigenvalues))
        limiting_eigenvector_nparray = eigenvectors[:,index].real
        # The next two lines are converting the numpy array to a list
        limiting_eigenvector = limiting_eigenvector_nparray.tolist()
        limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
        abundance = [num / sum(limiting_eigenvector) for num in limiting_eigenvector]
        return abundance

class BinaryChemistry(Chemistry):
    &#34;&#34;&#34;
    A chemistry for binary look and say sequences that split as 1.0 
    (i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
    the say-what-you-see operation maps 
    \\(a^b\\) to \\([b]a\\) where \\([b]\\) is a binary
    string that always starts with a 1. For example, this chemistry is 
    valid for the standard base two binary look and say sequences. 
    &#34;&#34;&#34;
    def __init__(self, las, elements = None):
        super().__init__(las, Leading1SplittingStrategy(), elements)


########### ELEMENT #######################

class Element():
    &#34;&#34;&#34;docstring for Element&#34;&#34;&#34;
    def __init__(self, string, las, decay = []):
        super(Element, self).__init__()
        self.string = string
        self.las = las
        self.name = string
        self.decay = decay

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        if isinstance(other, Element):
                return self.string == other.string and self.las == other.las
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        return hash(tuple(sorted(self.__dict__.items())))

    def _set_decay(self, elements):
        self.decay = elements

    def get_decay(self):
        return self.decay

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def get_string(self):
        return self.string

########### SPLITTING STRATEGY #####################

class SplittingStrategy():
    &#34;&#34;&#34;docstring for SplittingStrategy&#34;&#34;&#34;
    def __init__(self, splitting_function):
        self.splitting_function = splitting_function

    def split(self, string):
        self.splitting_function(string)


class SplittingStrategyBySplittablePairs(SplittingStrategy):
    &#34;&#34;&#34;docstring for SplittingStrategyBySplittablePairs&#34;&#34;&#34;
    def __init__(self):
        super().__init__(None)
    
    def is_split(self, L, R):
        pass

    def split(self, string):
        chunks = []
        start = 0
        for i in range(1, len(string)):
            if self.is_split(string[start:i], string[i:]):
                chunks.append(string[start:i])
                start = i
        chunks.append(string[start:])
        return chunks


class Ending0SplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for Ending0SplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__()

    def is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        return L[-1] == &#39;0&#39; and R[0] != &#39;0&#39;

class EndingWithCharsSplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for EndingWithCharsSplittingStrategy&#34;&#34;&#34;
    def __init__(self, ending_characters):
        super().__init__()
        self.ending_characters = ending_characters

    def is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        return L[-1] in self.ending_characters and R[0] not in self.ending_characters

class LeadingCharSplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for LeadingCharSplittingStrategy&#34;&#34;&#34;
    def __init__(self, leading_chars):
        super().__init__()
        self.leading_chars = leading_chars

    def is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        return L[-1] not in self.leading_chars and L[-1] != R[0]

class Leading1SplittingStrategy(LeadingCharSplittingStrategy):
    &#34;&#34;&#34;docstring for Leading1SplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;1&#39;)

class Leading0SplittingStrategy(LeadingCharSplittingStrategy):
    &#34;&#34;&#34;docstring for Leading1SplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;0&#39;)

class ConwaySplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for ConwaySplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__()

    def is_split(self, L, R):
        # Implementing Conway&#39;s Splitting Theorem:
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        if L[-1] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and R[0] in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]: # n] and [m
                return True
        if L[-1] == &#39;2&#39;: # 2]
                if len(R) &gt; 1 and R[0] == &#39;1&#39; and R[1] != &#39;1&#39; and (len(R) == 2 or R[2] != R[1]): #[1^1X^1
                        return True
                if len(R) &gt; 2 and R[0] == &#39;1&#39; and R[1] == &#39;1&#39; and R[2] == &#39;1&#39; and (len(R) == 3 or R[3] != &#39;1&#39;): #[1^3
                        return True
                if R[0] == &#39;3&#39; and (len(R) == 1 or (R[1] != &#39;3&#39; and (len(R) &lt; 4 or R[2] != R[1] or R[3] != R[1]))): #[3^1X^\not=3
                        return True
                if R[0] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 1 or R[1] != R[0]): #[n^1
                        return True
        if L[-1] != &#39;2&#39; and len(R) &gt; 1 and R[0] == &#39;2&#39; and R[1] == &#39;2&#39;: # \not=2]
                if len(R) &gt; 3 and R[2] == &#39;1&#39; and R[3] != &#39;1&#39; and (len(R) == 4 or R[4] != R[3]): #[2^21^1X^1
                        return True
                if len(R) &gt; 4 and R[2] == &#39;1&#39; and R[3] == &#39;1&#39; and R[4] == &#39;1&#39; and (len(R) == 5 or R[5] != &#39;1&#39;): #[2^21^3
                        return True
                if len(R) &gt; 2 and R[2] == &#39;3&#39; and (len(R) == 3 or (R[3] != &#39;3&#39; and (len(R) &lt; 6 or R[4] != R[3] or R[5] != R[3]))): #[2^23^1X^\not=3
                        return True 
                if len(R) == 2 or (len(R) &gt; 2 and R[2] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 3 or R[3] != R[2])): #[2^2n^(0 or 1)
                        return True
        return False

# ls = LookAndSay()
# chem = Chemistry(ls)
# chem.generate_elements(&#39;1&#39;)
# print(len(chem.get_elements()))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="look_and_say.split_Conway"><code class="name flex">
<span>def <span class="ident">split_Conway</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits a string into a list of substrings according to Conway's Splitting Theorem.
Assumes the string is not empty. </p>
<p>Example usage:</p>
<pre><code>string = '121113'
chunks = split_Conway(string)
print(chunks)
</code></pre>
<h2 id="output">Output</h2>
<pre><code>['12', '1113']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_Conway(string):
    &#34;&#34;&#34;
    Splits a string into a list of substrings according to Conway&#39;s Splitting Theorem.
    Assumes the string is not empty. 

    Example usage:

        string = &#39;121113&#39;
        chunks = split_Conway(string)
        print(chunks)

    Output:

        ```
        [&#39;12&#39;, &#39;1113&#39;]
        ```
    &#34;&#34;&#34;
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if _is_split_pair_Conway(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="look_and_say.BinaryChemistry"><code class="flex name class">
<span>class <span class="ident">BinaryChemistry</span></span>
<span>(</span><span>las, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A chemistry for binary look and say sequences that split as 1.0
(i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
the say-what-you-see operation maps
<span><span class="MathJax_Preview">a^b</span><script type="math/tex">a^b</script></span> to <span><span class="MathJax_Preview">[b]a</span><script type="math/tex">[b]a</script></span> where <span><span class="MathJax_Preview">[b]</span><script type="math/tex">[b]</script></span> is a binary
string that always starts with a 1. For example, this chemistry is
valid for the standard base two binary look and say sequences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryChemistry(Chemistry):
    &#34;&#34;&#34;
    A chemistry for binary look and say sequences that split as 1.0 
    (i.e. whenever a 1 is left of a 0). This chemistry is valid whenever
    the say-what-you-see operation maps 
    \\(a^b\\) to \\([b]a\\) where \\([b]\\) is a binary
    string that always starts with a 1. For example, this chemistry is 
    valid for the standard base two binary look and say sequences. 
    &#34;&#34;&#34;
    def __init__(self, las, elements = None):
        super().__init__(las, Leading1SplittingStrategy(), elements)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></b></code>:
<ul class="hlist">
<li><code><a title="look_and_say.Chemistry.clear_elements" href="#look_and_say.Chemistry.clear_elements">clear_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.generate_elements" href="#look_and_say.Chemistry.generate_elements">generate_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_abundances" href="#look_and_say.Chemistry.get_abundances">get_abundances</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_char_poly" href="#look_and_say.Chemistry.get_char_poly">get_char_poly</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_decay_matrix" href="#look_and_say.Chemistry.get_decay_matrix">get_decay_matrix</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_elements" href="#look_and_say.Chemistry.get_elements">get_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_max_eigenvalue" href="#look_and_say.Chemistry.get_max_eigenvalue">get_max_eigenvalue</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="look_and_say.Chemistry"><code class="flex name class">
<span>class <span class="ident">Chemistry</span></span>
<span>(</span><span>las, split=&lt;function split_Conway&gt;, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class responsible for generating all the persistent elements
appearing in look and say sequences, along with
the chemical properties of those elements.</p>
<p>Parameters in the constructor are a LookAndSay object <code>las</code> and
a splitting function <code>split</code>. The user is responsible
for verifying that the provided splitting function is valid for the given
LookAndSay object. The default splitting function corresponds to
Conway's original Splitting Theorem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chemistry():
    &#34;&#34;&#34;
    A class responsible for generating all the persistent elements 
    appearing in look and say sequences, along with 
    the chemical properties of those elements.

    Parameters in the constructor are a LookAndSay object ``las`` and
    a splitting function ``split``. The user is responsible
    for verifying that the provided splitting function is valid for the given
    LookAndSay object. The default splitting function corresponds to 
    Conway&#39;s original Splitting Theorem.

    &#34;&#34;&#34;
    def __init__(self, las, split = split_Conway, elements = None):
        super(Chemistry, self).__init__()
        self.las = las
        self.split = split
        if elements == None:
            elements = []
        self.elements = elements

    def get_elements(self):
        &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
        return self.elements

    def clear_elements(self):
        &#34;&#34;&#34;Resets the list of elements back to the empty list&#34;&#34;&#34;
        self.elements = []

    def _split_to_elements(self, string): 
        return [Element(chunk, self.las) for chunk in self.split(string)]

    def _generate_all_elements(self, strings):
        for string in strings:
            for elt in self._split_to_elements(string):
                if elt not in self.elements:
                    # add elt to the chemistry:
                    self.elements.append(elt)
                    # recursively set the decay for elt:
                    decay_elts = self._split_to_elements(self.las.say_what_you_see(elt.get_string()))
                    self._generate_all_elements(map(lambda e : e.get_string(), decay_elts))
                    elt._set_decay(decay_elts)
        # clean up decay for all elements:
        for elt in self.elements:
            dec = []
            for d in elt.get_decay():
                dec += [e for e in self.elements if e == d]
            elt._set_decay(dec)

    def _remove_extinct_elements(self): 
        while True:
            common_elements = []
            for elt in self.elements:
                for d in elt.get_decay():
                    if d not in common_elements:
                        common_elements.append(d)
            if len(common_elements) &lt; len(self.elements):
                self.elements = common_elements[:]
            else: 
                break

    def generate_elements(self, seeds, reset = True):
        &#34;&#34;&#34;
        Collects all the persistent elements from all the look and
        say sequences generated by the given seeds. The parameter ``seeds``
        should be a nonempty list of strings. By default, this method will 
        clear any elements in the chemistry that exist before this method is called
        prior to collecting from the given seeds. Use ``reset = False`` 
        to keep the old elements. 
        &#34;&#34;&#34;
        assert type(seeds) == type([&#39;0&#39;]), &#34;The parameter seeds in generate_elements should be a list of strings.&#34;
        if reset:
            self.clear_elements()
        strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
        self._generate_all_elements(strings)
        self._remove_extinct_elements()

    def get_decay_matrix(self):
        &#34;&#34;&#34;
        Returns the decay matrix as a nested list of integers 
        (i.e. a list of the rows).
        The order of the columns and rows correspond to the order
        in the list of elements.
        &#34;&#34;&#34;
        mat = []
        e = self.elements
        for i in range(len(e)):
            row = []
            for j in range(len(e)):
                row.append(e[j].get_decay().count(e[i]))
            mat.append(row)
        return mat

    def get_max_eigenvalue(self):
        &#34;&#34;&#34;
        Returns the maximal real eigenvalue of the decay matrix.
        This method assumes the existence of a real eigenvalue which
        is larger than (the absolute value) of every other eigenvalue.
        This assumption is usually guaranteed by the Perron-Frobenius Theorem.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        return max(eigenvalues).real

    def get_char_poly(self, factor = True):
        &#34;&#34;&#34;
        Returns the characteristic polynomial of the decay matrix using sympy.
        By default the returned polynomial will be factored. 
        Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
        &#34;&#34;&#34;
        chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
        if factor:
            return sympy.factor(chi.as_expr())
        else:
            return chi.as_expr()

    def get_abundances(self):
        &#34;&#34;&#34;
        Returns a list of relative abundances of each element.
        Note that the abundances are given in percentages, so they will
        differ from Conway&#39;s abundances by a factor of \\(10^6\\). 
        The order of the list corresponds to the order of the list of elements.
        &#34;&#34;&#34;
        eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
        eigenvalues = eigenstuff[0]
        eigenvectors = eigenstuff[1]
        index = numpy.where(eigenvalues == max(eigenvalues))
        limiting_eigenvector_nparray = eigenvectors[:,index].real
        # The next two lines are converting the numpy array to a list
        limiting_eigenvector = limiting_eigenvector_nparray.tolist()
        limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
        abundance = [num / sum(limiting_eigenvector) for num in limiting_eigenvector]
        return abundance</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="look_and_say.BinaryChemistry" href="#look_and_say.BinaryChemistry">BinaryChemistry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Chemistry.clear_elements"><code class="name flex">
<span>def <span class="ident">clear_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the list of elements back to the empty list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_elements(self):
    &#34;&#34;&#34;Resets the list of elements back to the empty list&#34;&#34;&#34;
    self.elements = []</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.generate_elements"><code class="name flex">
<span>def <span class="ident">generate_elements</span></span>(<span>self, seeds, reset=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects all the persistent elements from all the look and
say sequences generated by the given seeds. The parameter <code>seeds</code>
should be a nonempty list of strings. By default, this method will
clear any elements in the chemistry that exist before this method is called
prior to collecting from the given seeds. Use <code>reset = False</code>
to keep the old elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_elements(self, seeds, reset = True):
    &#34;&#34;&#34;
    Collects all the persistent elements from all the look and
    say sequences generated by the given seeds. The parameter ``seeds``
    should be a nonempty list of strings. By default, this method will 
    clear any elements in the chemistry that exist before this method is called
    prior to collecting from the given seeds. Use ``reset = False`` 
    to keep the old elements. 
    &#34;&#34;&#34;
    assert type(seeds) == type([&#39;0&#39;]), &#34;The parameter seeds in generate_elements should be a list of strings.&#34;
    if reset:
        self.clear_elements()
    strings = [self.las.say_what_you_see(seed) for seed in seeds] #only look at 2-day-old strings
    self._generate_all_elements(strings)
    self._remove_extinct_elements()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_abundances"><code class="name flex">
<span>def <span class="ident">get_abundances</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of relative abundances of each element.
Note that the abundances are given in percentages, so they will
differ from Conway's abundances by a factor of <span><span class="MathJax_Preview">10^6</span><script type="math/tex">10^6</script></span>.
The order of the list corresponds to the order of the list of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_abundances(self):
    &#34;&#34;&#34;
    Returns a list of relative abundances of each element.
    Note that the abundances are given in percentages, so they will
    differ from Conway&#39;s abundances by a factor of \\(10^6\\). 
    The order of the list corresponds to the order of the list of elements.
    &#34;&#34;&#34;
    eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
    eigenvalues = eigenstuff[0]
    eigenvectors = eigenstuff[1]
    index = numpy.where(eigenvalues == max(eigenvalues))
    limiting_eigenvector_nparray = eigenvectors[:,index].real
    # The next two lines are converting the numpy array to a list
    limiting_eigenvector = limiting_eigenvector_nparray.tolist()
    limiting_eigenvector = [elt[0][0] for elt in limiting_eigenvector]
    abundance = [num / sum(limiting_eigenvector) for num in limiting_eigenvector]
    return abundance</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_char_poly"><code class="name flex">
<span>def <span class="ident">get_char_poly</span></span>(<span>self, factor=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the characteristic polynomial of the decay matrix using sympy.
By default the returned polynomial will be factored.
Use <code>factor = False</code> to get the expanded (i.e. unfactored) polynomial.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_char_poly(self, factor = True):
    &#34;&#34;&#34;
    Returns the characteristic polynomial of the decay matrix using sympy.
    By default the returned polynomial will be factored. 
    Use ``factor = False`` to get the expanded (i.e. unfactored) polynomial. 
    &#34;&#34;&#34;
    chi = sympy.Matrix(self.get_decay_matrix()).charpoly()
    if factor:
        return sympy.factor(chi.as_expr())
    else:
        return chi.as_expr()</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_decay_matrix"><code class="name flex">
<span>def <span class="ident">get_decay_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the decay matrix as a nested list of integers
(i.e. a list of the rows).
The order of the columns and rows correspond to the order
in the list of elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decay_matrix(self):
    &#34;&#34;&#34;
    Returns the decay matrix as a nested list of integers 
    (i.e. a list of the rows).
    The order of the columns and rows correspond to the order
    in the list of elements.
    &#34;&#34;&#34;
    mat = []
    e = self.elements
    for i in range(len(e)):
        row = []
        for j in range(len(e)):
            row.append(e[j].get_decay().count(e[i]))
        mat.append(row)
    return mat</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_elements"><code class="name flex">
<span>def <span class="ident">get_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the elements as a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elements(self):
    &#34;&#34;&#34;Returns the elements as a list.&#34;&#34;&#34;
    return self.elements</code></pre>
</details>
</dd>
<dt id="look_and_say.Chemistry.get_max_eigenvalue"><code class="name flex">
<span>def <span class="ident">get_max_eigenvalue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximal real eigenvalue of the decay matrix.
This method assumes the existence of a real eigenvalue which
is larger than (the absolute value) of every other eigenvalue.
This assumption is usually guaranteed by the Perron-Frobenius Theorem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_eigenvalue(self):
    &#34;&#34;&#34;
    Returns the maximal real eigenvalue of the decay matrix.
    This method assumes the existence of a real eigenvalue which
    is larger than (the absolute value) of every other eigenvalue.
    This assumption is usually guaranteed by the Perron-Frobenius Theorem.
    &#34;&#34;&#34;
    eigenstuff = numpy.linalg.eig(numpy.array(self.get_decay_matrix()))
    eigenvalues = eigenstuff[0]
    return max(eigenvalues).real</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.ConwaySplittingStrategy"><code class="flex name class">
<span>class <span class="ident">ConwaySplittingStrategy</span></span>
</code></dt>
<dd>
<div class="desc"><p>docstring for ConwaySplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConwaySplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for ConwaySplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__()

    def is_split(self, L, R):
        # Implementing Conway&#39;s Splitting Theorem:
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        if L[-1] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and R[0] in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]: # n] and [m
                return True
        if L[-1] == &#39;2&#39;: # 2]
                if len(R) &gt; 1 and R[0] == &#39;1&#39; and R[1] != &#39;1&#39; and (len(R) == 2 or R[2] != R[1]): #[1^1X^1
                        return True
                if len(R) &gt; 2 and R[0] == &#39;1&#39; and R[1] == &#39;1&#39; and R[2] == &#39;1&#39; and (len(R) == 3 or R[3] != &#39;1&#39;): #[1^3
                        return True
                if R[0] == &#39;3&#39; and (len(R) == 1 or (R[1] != &#39;3&#39; and (len(R) &lt; 4 or R[2] != R[1] or R[3] != R[1]))): #[3^1X^\not=3
                        return True
                if R[0] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 1 or R[1] != R[0]): #[n^1
                        return True
        if L[-1] != &#39;2&#39; and len(R) &gt; 1 and R[0] == &#39;2&#39; and R[1] == &#39;2&#39;: # \not=2]
                if len(R) &gt; 3 and R[2] == &#39;1&#39; and R[3] != &#39;1&#39; and (len(R) == 4 or R[4] != R[3]): #[2^21^1X^1
                        return True
                if len(R) &gt; 4 and R[2] == &#39;1&#39; and R[3] == &#39;1&#39; and R[4] == &#39;1&#39; and (len(R) == 5 or R[5] != &#39;1&#39;): #[2^21^3
                        return True
                if len(R) &gt; 2 and R[2] == &#39;3&#39; and (len(R) == 3 or (R[3] != &#39;3&#39; and (len(R) &lt; 6 or R[4] != R[3] or R[5] != R[3]))): #[2^23^1X^\not=3
                        return True 
                if len(R) == 2 or (len(R) &gt; 2 and R[2] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 3 or R[3] != R[2])): #[2^2n^(0 or 1)
                        return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.ConwaySplittingStrategy.is_split"><code class="name flex">
<span>def <span class="ident">is_split</span></span>(<span>self, L, R)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_split(self, L, R):
    # Implementing Conway&#39;s Splitting Theorem:
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    if L[-1] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and R[0] in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]: # n] and [m
            return True
    if L[-1] == &#39;2&#39;: # 2]
            if len(R) &gt; 1 and R[0] == &#39;1&#39; and R[1] != &#39;1&#39; and (len(R) == 2 or R[2] != R[1]): #[1^1X^1
                    return True
            if len(R) &gt; 2 and R[0] == &#39;1&#39; and R[1] == &#39;1&#39; and R[2] == &#39;1&#39; and (len(R) == 3 or R[3] != &#39;1&#39;): #[1^3
                    return True
            if R[0] == &#39;3&#39; and (len(R) == 1 or (R[1] != &#39;3&#39; and (len(R) &lt; 4 or R[2] != R[1] or R[3] != R[1]))): #[3^1X^\not=3
                    return True
            if R[0] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 1 or R[1] != R[0]): #[n^1
                    return True
    if L[-1] != &#39;2&#39; and len(R) &gt; 1 and R[0] == &#39;2&#39; and R[1] == &#39;2&#39;: # \not=2]
            if len(R) &gt; 3 and R[2] == &#39;1&#39; and R[3] != &#39;1&#39; and (len(R) == 4 or R[4] != R[3]): #[2^21^1X^1
                    return True
            if len(R) &gt; 4 and R[2] == &#39;1&#39; and R[3] == &#39;1&#39; and R[4] == &#39;1&#39; and (len(R) == 5 or R[5] != &#39;1&#39;): #[2^21^3
                    return True
            if len(R) &gt; 2 and R[2] == &#39;3&#39; and (len(R) == 3 or (R[3] != &#39;3&#39; and (len(R) &lt; 6 or R[4] != R[3] or R[5] != R[3]))): #[2^23^1X^\not=3
                    return True 
            if len(R) == 2 or (len(R) &gt; 2 and R[2] not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] and (len(R) == 3 or R[3] != R[2])): #[2^2n^(0 or 1)
                    return True
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>string, las, decay=[])</span>
</code></dt>
<dd>
<div class="desc"><p>docstring for Element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element():
    &#34;&#34;&#34;docstring for Element&#34;&#34;&#34;
    def __init__(self, string, las, decay = []):
        super(Element, self).__init__()
        self.string = string
        self.las = las
        self.name = string
        self.decay = decay

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        if isinstance(other, Element):
                return self.string == other.string and self.las == other.las
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        return hash(tuple(sorted(self.__dict__.items())))

    def _set_decay(self, elements):
        self.decay = elements

    def get_decay(self):
        return self.decay

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def get_string(self):
        return self.string</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Element.get_decay"><code class="name flex">
<span>def <span class="ident">get_decay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decay(self):
    return self.decay</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    return self.name</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.get_string"><code class="name flex">
<span>def <span class="ident">get_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string(self):
    return self.string</code></pre>
</details>
</dd>
<dt id="look_and_say.Element.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    self.name = name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.Ending0SplittingStrategy"><code class="flex name class">
<span>class <span class="ident">Ending0SplittingStrategy</span></span>
</code></dt>
<dd>
<div class="desc"><p>docstring for Ending0SplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ending0SplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for Ending0SplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__()

    def is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        return L[-1] == &#39;0&#39; and R[0] != &#39;0&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.Ending0SplittingStrategy.is_split"><code class="name flex">
<span>def <span class="ident">is_split</span></span>(<span>self, L, R)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_split(self, L, R):
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    return L[-1] == &#39;0&#39; and R[0] != &#39;0&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.EndingWithCharsSplittingStrategy"><code class="flex name class">
<span>class <span class="ident">EndingWithCharsSplittingStrategy</span></span>
<span>(</span><span>ending_characters)</span>
</code></dt>
<dd>
<div class="desc"><p>docstring for EndingWithCharsSplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EndingWithCharsSplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for EndingWithCharsSplittingStrategy&#34;&#34;&#34;
    def __init__(self, ending_characters):
        super().__init__()
        self.ending_characters = ending_characters

    def is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        return L[-1] in self.ending_characters and R[0] not in self.ending_characters</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.EndingWithCharsSplittingStrategy.is_split"><code class="name flex">
<span>def <span class="ident">is_split</span></span>(<span>self, L, R)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_split(self, L, R):
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    return L[-1] in self.ending_characters and R[0] not in self.ending_characters</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.Leading0SplittingStrategy"><code class="flex name class">
<span>class <span class="ident">Leading0SplittingStrategy</span></span>
</code></dt>
<dd>
<div class="desc"><p>docstring for Leading1SplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Leading0SplittingStrategy(LeadingCharSplittingStrategy):
    &#34;&#34;&#34;docstring for Leading1SplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;0&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.LeadingCharSplittingStrategy" href="#look_and_say.LeadingCharSplittingStrategy">LeadingCharSplittingStrategy</a></li>
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
</dd>
<dt id="look_and_say.Leading1SplittingStrategy"><code class="flex name class">
<span>class <span class="ident">Leading1SplittingStrategy</span></span>
</code></dt>
<dd>
<div class="desc"><p>docstring for Leading1SplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Leading1SplittingStrategy(LeadingCharSplittingStrategy):
    &#34;&#34;&#34;docstring for Leading1SplittingStrategy&#34;&#34;&#34;
    def __init__(self):
        super().__init__(&#39;1&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.LeadingCharSplittingStrategy" href="#look_and_say.LeadingCharSplittingStrategy">LeadingCharSplittingStrategy</a></li>
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
</dd>
<dt id="look_and_say.LeadingCharSplittingStrategy"><code class="flex name class">
<span>class <span class="ident">LeadingCharSplittingStrategy</span></span>
<span>(</span><span>leading_chars)</span>
</code></dt>
<dd>
<div class="desc"><p>docstring for LeadingCharSplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LeadingCharSplittingStrategy(SplittingStrategyBySplittablePairs):
    &#34;&#34;&#34;docstring for LeadingCharSplittingStrategy&#34;&#34;&#34;
    def __init__(self, leading_chars):
        super().__init__()
        self.leading_chars = leading_chars

    def is_split(self, L, R):
        if L == &#39;&#39; or R == &#39;&#39;:
                return True
        return L[-1] not in self.leading_chars and L[-1] != R[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="look_and_say.Leading0SplittingStrategy" href="#look_and_say.Leading0SplittingStrategy">Leading0SplittingStrategy</a></li>
<li><a title="look_and_say.Leading1SplittingStrategy" href="#look_and_say.Leading1SplittingStrategy">Leading1SplittingStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.LeadingCharSplittingStrategy.is_split"><code class="name flex">
<span>def <span class="ident">is_split</span></span>(<span>self, L, R)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_split(self, L, R):
    if L == &#39;&#39; or R == &#39;&#39;:
            return True
    return L[-1] not in self.leading_chars and L[-1] != R[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.LookAndSay"><code class="flex name class">
<span>class <span class="ident">LookAndSay</span></span>
<span>(</span><span>say=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class responsible for the fundamental say-what-you-see operation
that generates a look and say sequence. The parameter <code>say</code> in the
constructor is a function that determines the decay of chunk of the form
<span><span class="MathJax_Preview">a^b</span><script type="math/tex">a^b</script></span>. The say function can have one or two parameters:</p>
<ul>
<li>If the say function accepts one parameter, the LookAndSay object will correspond to the decay <span><span class="MathJax_Preview">a^b\to say(b)a</span><script type="math/tex">a^b\to say(b)a</script></span>.</li>
<li>If the say function accepts two parameters, the LookAndSay object will correspond to the decay <span><span class="MathJax_Preview">a^b\to say(b, a)</span><script type="math/tex">a^b\to say(b, a)</script></span>.</li>
</ul>
<p>When no parameter is passed to the constructor, the LookAndSay
object will correspond to standard base ten look and say sequences.</p>
<p>The following example uses the default (standard) look and say sequences.
Note that the ratio of lengths are approaching Conway's constant.</p>
<pre><code>ls = LookAndSay()  
ls.generate_sequence('55555', 50)
sequence = ls.get_sequence()
first_terms = sequence[:10]
print('Sequence:', first_terms)
print('Ratios of lengths:', ls.get_length_ratios())
print('Just the last ratio:', ls.get_last_length_ratio())
</code></pre>
<h2 id="output">Output</h2>
<pre><code>Sequence: ['55555', '55', '25', '1215', '11121115', '31123115', '132112132115', '11131221121113122115', '311311222112311311222115', '1321132132211213211321322115']
Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331, 1.2996264674493063, 1.3030178608088687, 1.3061288797857256, 1.3046441495778045, 1.300263510702233, 1.304700277323473, 1.3052921299324176, 1.299567840664732, 1.3057126333376172, 1.304461231821649, 1.3014789104353732, 1.3050192770385831, 1.304147670163319, 1.3026438489740129, 1.3036460274187538]
Just the last ratio: 1.3036460274187538
</code></pre>
<p>Here is a Roman look and say:</p>
<pre><code>def roman_say(num):
    assert num &lt; 10, "This Roman can only count to 9."
    roman = {1:'I', 2:'II', 3:'III', 4:'IV', 5:'V', 6:'VI', 7:'VII', 8:'VIII', 9:'IX'}
    return roman[num]

roman_ls = LookAndSay(roman_say)

roman_ls.generate_sequence('I', 10)
print(roman_ls.get_sequence())

roman_ls.generate_sequence('V', 10)
print(roman_ls.get_sequence())
</code></pre>
<h2 id="output_1">Output</h2>
<pre><code>['I', 'II', 'III', 'IIII', 'IVI', 'IIIVII', 'IIIIIVIII', 'VIIVIIII', 'IVIIIIVIVI', 'IIIVIVIIVIIIVII', 'IIIIIVIIIVIIIIVIIIIIVIII']
['V', 'IV', 'IIIV', 'IIIIIV', 'VIIV', 'IVIIIIV', 'IIIVIVIIV', 'IIIIIVIIIVIIIIV', 'VIIVIIIIIVIVIIV', 'IVIIIIVVIIVIIIVIIIIV', 'IIIVIVIIIVIIIIVIIIIIVIVIIV']
</code></pre>
<p>Here is a standard binary look and say:</p>
<pre><code>def binary_say(num):
    return "{0:b}".format(num)

binary_ls = LookAndSay(binary_say)

binary_ls.generate_sequence('0', 9)
print(binary_ls.get_sequence())

binary_ls.generate_sequence('1', 9)
print(binary_ls.get_sequence())
</code></pre>
<h2 id="output_2">Output</h2>
<pre><code>['0', '10', '1110', '11110', '100110', '1110010110', '111100111010110', '100110011110111010110', '1110010110010011011110111010110', '1111001110101100111001011010011011110111010110']
['1', '11', '101', '111011', '11110101', '100110111011', '111001011011110101', '111100111010110100110111011', '100110011110111010110111001011011110101', '1110010110010011011110111010110111100111010110100110111011']
</code></pre>
<p>Here is a <em>look-and-say-again</em> from the paper <em>Stuttering Conway Sequences Are Still Conway Sequences</em> by Brier et al.</p>
<pre><code>def say_again(char_count, char):
    return 2 * str(char_count) + 2 * char

look_and_say_again = LookAndSay(say_again)

look_and_say_again.generate_sequence('1', 10)
print(look_and_say_again.get_sequence())

look_and_say_again.generate_sequence('2', 10)
print(look_and_say_again.get_sequence())
</code></pre>
<h2 id="output_3">Output</h2>
<pre><code>['1', '1111', '4411', '22442211', '2222224422222211', '6622224466222211', '226644222244226644222211', '2222226622444422224422222266224444222211', '662222662222444444222244662222662222444444222211', '22664422226644226644442222442266442222664422664444222211', '2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211']
['2', '1122', '22112222', '222222114422', '6622221122442222', '226644222211222222444422', '22222266224444222211662244442222', '6622226622224444442222112266222244444422', '226644222266442266444422221122222266442266442222', '222222662244442222662244222222664444442222116622226622442222226622444422', '66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222']
</code></pre>
<p>Here is Morrill's <em>Look Knave</em>.</p>
<pre><code>def knave_say(bit_count, bit):
    flip = {'0':'1', '1':'0'}
    return "{0:b}".format(bit_count) + flip[bit]

look_knave = LookAndSay(knave_say)

look_knave.generate_sequence('0', 12)
print(look_knave.get_sequence())

look_knave.generate_sequence('1', 12)
print(look_knave.get_sequence())
</code></pre>
<h2 id="output_4">Output</h2>
<pre><code>['0', '11', '100', '10101', '1011101110', '10111101111011', '1011100011100011100', '1011110111110111110101', '1011100011101011101011101110', '10111101111101110111101110111101111011', '10111000111010111101110001111011100011100011100', '1011110111110111011100011110111100011110111110111110101', '1011100011101011110111101111000111000111100011101011101011101110']
['1', '10', '1011', '1011100', '1011110101', '1011100011101110', '10111101111101111011', '1011100011101011100011100', '1011110111110111011110111110101', '101110001110101111011100011101011101110', '10111101111101110111000111101111101110111101111011', '10111000111010111101111011110001110101111011100011100011100', '10111101111101110111000111000111000111110111011100011110111110111110101']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LookAndSay():
    &#34;&#34;&#34;
    A class responsible for the fundamental say-what-you-see operation
    that generates a look and say sequence. The parameter ``say`` in the
    constructor is a function that determines the decay of chunk of the form
    \\(a^b\\). The say function can have one or two parameters:

    * If the say function accepts one parameter, the LookAndSay object will correspond to the decay \\(a^b\\to say(b)a\\).
    * If the say function accepts two parameters, the LookAndSay object will correspond to the decay \\(a^b\\to say(b, a)\\).

    When no parameter is passed to the constructor, the LookAndSay
    object will correspond to standard base ten look and say sequences.

    The following example uses the default (standard) look and say sequences.
    Note that the ratio of lengths are approaching Conway&#39;s constant.
        
        ls = LookAndSay()  
        ls.generate_sequence(&#39;55555&#39;, 50)
        sequence = ls.get_sequence()
        first_terms = sequence[:10]
        print(&#39;Sequence:&#39;, first_terms)
        print(&#39;Ratios of lengths:&#39;, ls.get_length_ratios())
        print(&#39;Just the last ratio:&#39;, ls.get_last_length_ratio())

    Output:

        ```
        Sequence: [&#39;55555&#39;, &#39;55&#39;, &#39;25&#39;, &#39;1215&#39;, &#39;11121115&#39;, &#39;31123115&#39;, &#39;132112132115&#39;, &#39;11131221121113122115&#39;, &#39;311311222112311311222115&#39;, &#39;1321132132211213211321322115&#39;]
        Ratios of lengths: [0.4, 1.0, 2.0, 2.0, 1.0, 1.5, 1.6666666666666667, 1.2, 1.1666666666666667, 1.5714285714285714, 1.1818181818181819, 1.1538461538461537, 1.4666666666666666, 1.2727272727272727, 1.25, 1.4, 1.3265306122448979, 1.2461538461538462, 1.3333333333333333, 1.3518518518518519, 1.226027397260274, 1.312849162011173, 1.3361702127659574, 1.2611464968152866, 1.3257575757575757, 1.318095238095238, 1.2919075144508672, 1.3053691275167785, 1.3161953727506426, 1.2936197916666667, 1.2989431303472572, 1.3142192948469587, 1.2951061320754718, 1.2997951286137037, 1.312784588441331, 1.2996264674493063, 1.3030178608088687, 1.3061288797857256, 1.3046441495778045, 1.300263510702233, 1.304700277323473, 1.3052921299324176, 1.299567840664732, 1.3057126333376172, 1.304461231821649, 1.3014789104353732, 1.3050192770385831, 1.304147670163319, 1.3026438489740129, 1.3036460274187538]
        Just the last ratio: 1.3036460274187538
        ```

    Here is a Roman look and say:

        def roman_say(num):
            assert num &lt; 10, &#34;This Roman can only count to 9.&#34;
            roman = {1:&#39;I&#39;, 2:&#39;II&#39;, 3:&#39;III&#39;, 4:&#39;IV&#39;, 5:&#39;V&#39;, 6:&#39;VI&#39;, 7:&#39;VII&#39;, 8:&#39;VIII&#39;, 9:&#39;IX&#39;}
            return roman[num]

        roman_ls = LookAndSay(roman_say)

        roman_ls.generate_sequence(&#39;I&#39;, 10)
        print(roman_ls.get_sequence())

        roman_ls.generate_sequence(&#39;V&#39;, 10)
        print(roman_ls.get_sequence())

    Output:

        ```
        [&#39;I&#39;, &#39;II&#39;, &#39;III&#39;, &#39;IIII&#39;, &#39;IVI&#39;, &#39;IIIVII&#39;, &#39;IIIIIVIII&#39;, &#39;VIIVIIII&#39;, &#39;IVIIIIVIVI&#39;, &#39;IIIVIVIIVIIIVII&#39;, &#39;IIIIIVIIIVIIIIVIIIIIVIII&#39;]
        [&#39;V&#39;, &#39;IV&#39;, &#39;IIIV&#39;, &#39;IIIIIV&#39;, &#39;VIIV&#39;, &#39;IVIIIIV&#39;, &#39;IIIVIVIIV&#39;, &#39;IIIIIVIIIVIIIIV&#39;, &#39;VIIVIIIIIVIVIIV&#39;, &#39;IVIIIIVVIIVIIIVIIIIV&#39;, &#39;IIIVIVIIIVIIIIVIIIIIVIVIIV&#39;]
        ```
    
    Here is a standard binary look and say:

        def binary_say(num):
            return &#34;{0:b}&#34;.format(num)

        binary_ls = LookAndSay(binary_say)

        binary_ls.generate_sequence(&#39;0&#39;, 9)
        print(binary_ls.get_sequence())

        binary_ls.generate_sequence(&#39;1&#39;, 9)
        print(binary_ls.get_sequence())

    Output:

        ```
        [&#39;0&#39;, &#39;10&#39;, &#39;1110&#39;, &#39;11110&#39;, &#39;100110&#39;, &#39;1110010110&#39;, &#39;111100111010110&#39;, &#39;100110011110111010110&#39;, &#39;1110010110010011011110111010110&#39;, &#39;1111001110101100111001011010011011110111010110&#39;]
        [&#39;1&#39;, &#39;11&#39;, &#39;101&#39;, &#39;111011&#39;, &#39;11110101&#39;, &#39;100110111011&#39;, &#39;111001011011110101&#39;, &#39;111100111010110100110111011&#39;, &#39;100110011110111010110111001011011110101&#39;, &#39;1110010110010011011110111010110111100111010110100110111011&#39;]
        ```
    
    Here is a *look-and-say-again* from the paper *Stuttering Conway Sequences Are Still Conway Sequences* by Brier et al.
    
        def say_again(char_count, char):
            return 2 * str(char_count) + 2 * char

        look_and_say_again = LookAndSay(say_again)

        look_and_say_again.generate_sequence(&#39;1&#39;, 10)
        print(look_and_say_again.get_sequence())

        look_and_say_again.generate_sequence(&#39;2&#39;, 10)
        print(look_and_say_again.get_sequence())

    Output:

        ```
        [&#39;1&#39;, &#39;1111&#39;, &#39;4411&#39;, &#39;22442211&#39;, &#39;2222224422222211&#39;, &#39;6622224466222211&#39;, &#39;226644222244226644222211&#39;, &#39;2222226622444422224422222266224444222211&#39;, &#39;662222662222444444222244662222662222444444222211&#39;, &#39;22664422226644226644442222442266442222664422664444222211&#39;, &#39;2222226622444422226622442222226644444422224422222266224444222266224422222266444444222211&#39;]
        [&#39;2&#39;, &#39;1122&#39;, &#39;22112222&#39;, &#39;222222114422&#39;, &#39;6622221122442222&#39;, &#39;226644222211222222444422&#39;, &#39;22222266224444222211662244442222&#39;, &#39;6622226622224444442222112266222244444422&#39;, &#39;226644222266442266444422221122222266442266442222&#39;, &#39;222222662244442222662244222222664444442222116622226622442222226622444422&#39;, &#39;66222266222244444422226622222244662222666644442222112266442222662222224466222266222244442222&#39;]
        ```

    Here is Morrill&#39;s *Look Knave*.

        def knave_say(bit_count, bit):
            flip = {&#39;0&#39;:&#39;1&#39;, &#39;1&#39;:&#39;0&#39;}
            return &#34;{0:b}&#34;.format(bit_count) + flip[bit]

        look_knave = LookAndSay(knave_say)

        look_knave.generate_sequence(&#39;0&#39;, 12)
        print(look_knave.get_sequence())

        look_knave.generate_sequence(&#39;1&#39;, 12)
        print(look_knave.get_sequence())

    Output:

        ```
        [&#39;0&#39;, &#39;11&#39;, &#39;100&#39;, &#39;10101&#39;, &#39;1011101110&#39;, &#39;10111101111011&#39;, &#39;1011100011100011100&#39;, &#39;1011110111110111110101&#39;, &#39;1011100011101011101011101110&#39;, &#39;10111101111101110111101110111101111011&#39;, &#39;10111000111010111101110001111011100011100011100&#39;, &#39;1011110111110111011100011110111100011110111110111110101&#39;, &#39;1011100011101011110111101111000111000111100011101011101011101110&#39;]
        [&#39;1&#39;, &#39;10&#39;, &#39;1011&#39;, &#39;1011100&#39;, &#39;1011110101&#39;, &#39;1011100011101110&#39;, &#39;10111101111101111011&#39;, &#39;1011100011101011100011100&#39;, &#39;1011110111110111011110111110101&#39;, &#39;101110001110101111011100011101011101110&#39;, &#39;10111101111101110111000111101111101110111101111011&#39;, &#39;10111000111010111101111011110001110101111011100011100011100&#39;, &#39;10111101111101110111000111000111000111110111011100011110111110111110101&#39;]
        ```

    &#34;&#34;&#34;
    def __init__(self, say = None):
        super(LookAndSay, self).__init__()
        if say == None:
            say = (lambda n : str(n))
        self.say = say
        self.sequence = []

    def _chunk_op(self, char_count, char):
        &#34;&#34;&#34;
        Conversion of the say function to a two parameter function 
        if the say function takes only one parameter; 
        just a copy of the say function otherwise.
        &#34;&#34;&#34;
        try:
            return self.say(char_count, char)
        except:
            return self.say(char_count) + char

    def get_sequence(self):
        &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
        return self.sequence

    def say_what_you_see(self, string):
        &#34;&#34;&#34;
        The fundamental look and say operation that generates each 
        term of a look and say sequence from its predecessor. For example, 
        using the standard (default) LookAndSay object, 
        ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
        &#34;&#34;&#34;
        if not string: return None # handles empty string, which is falsy
        letter = string[0]
        result = &#39;&#39;
        count = 0
        for ch in string:
            if ch == letter: 
                count += 1
            else:
                result += self._chunk_op(count, letter)
                count = 1
                letter = ch 
        result += self._chunk_op(count, letter)
        return result
     
    def generate_sequence(self, seed, num_iterations):
        &#34;&#34;&#34;
        Generates the look and say sequence. The parameter ``seed`` is 
        the initial term in the sequence, and ``num_iterations`` is the 
        number of terms generated.
        &#34;&#34;&#34;
        if not seed: return None # handles empty seed, which is falsy
        result = [seed]
        for _ in range(num_iterations):
            result.append(self.say_what_you_see(result[-1]))
        self.sequence = result

    def get_length_ratios(self):
        &#34;&#34;&#34;
        Returns a list of the ratios of lengths of 
        successive terms in the look and say sequence.
        &#34;&#34;&#34;
        num_iterations = len(self.sequence)
        assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
        return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]

    def get_last_length_ratio(self):
        &#34;&#34;&#34;
        Returns the ratio of the lengths of the last 
        two terms of the look and say sequence
        &#34;&#34;&#34;
        return self.get_length_ratios()[-1]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.LookAndSay.generate_sequence"><code class="name flex">
<span>def <span class="ident">generate_sequence</span></span>(<span>self, seed, num_iterations)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the look and say sequence. The parameter <code>seed</code> is
the initial term in the sequence, and <code>num_iterations</code> is the
number of terms generated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_sequence(self, seed, num_iterations):
    &#34;&#34;&#34;
    Generates the look and say sequence. The parameter ``seed`` is 
    the initial term in the sequence, and ``num_iterations`` is the 
    number of terms generated.
    &#34;&#34;&#34;
    if not seed: return None # handles empty seed, which is falsy
    result = [seed]
    for _ in range(num_iterations):
        result.append(self.say_what_you_see(result[-1]))
    self.sequence = result</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_last_length_ratio"><code class="name flex">
<span>def <span class="ident">get_last_length_ratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ratio of the lengths of the last
two terms of the look and say sequence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_length_ratio(self):
    &#34;&#34;&#34;
    Returns the ratio of the lengths of the last 
    two terms of the look and say sequence
    &#34;&#34;&#34;
    return self.get_length_ratios()[-1]</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_length_ratios"><code class="name flex">
<span>def <span class="ident">get_length_ratios</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the ratios of lengths of
successive terms in the look and say sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length_ratios(self):
    &#34;&#34;&#34;
    Returns a list of the ratios of lengths of 
    successive terms in the look and say sequence.
    &#34;&#34;&#34;
    num_iterations = len(self.sequence)
    assert num_iterations &gt; 1, &#39;Look and say sequence does not have enough terms to compute the ratio of lengths.&#39;
    return [len(self.sequence[i+1]) / len(self.sequence[i]) for i in range(num_iterations - 1)]</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.get_sequence"><code class="name flex">
<span>def <span class="ident">get_sequence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the look and say sequence as a list of strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequence(self):
    &#34;&#34;&#34;Returns the look and say sequence as a list of strings&#34;&#34;&#34;
    return self.sequence</code></pre>
</details>
</dd>
<dt id="look_and_say.LookAndSay.say_what_you_see"><code class="name flex">
<span>def <span class="ident">say_what_you_see</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"><p>The fundamental look and say operation that generates each
term of a look and say sequence from its predecessor. For example,
using the standard (default) LookAndSay object,
<code>say_what_you_see('1112222333')</code> returns <code>'314233'</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def say_what_you_see(self, string):
    &#34;&#34;&#34;
    The fundamental look and say operation that generates each 
    term of a look and say sequence from its predecessor. For example, 
    using the standard (default) LookAndSay object, 
    ``say_what_you_see(&#39;1112222333&#39;)`` returns ``&#39;314233&#39;``.
    &#34;&#34;&#34;
    if not string: return None # handles empty string, which is falsy
    letter = string[0]
    result = &#39;&#39;
    count = 0
    for ch in string:
        if ch == letter: 
            count += 1
        else:
            result += self._chunk_op(count, letter)
            count = 1
            letter = ch 
    result += self._chunk_op(count, letter)
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.SplittingStrategy"><code class="flex name class">
<span>class <span class="ident">SplittingStrategy</span></span>
<span>(</span><span>splitting_function)</span>
</code></dt>
<dd>
<div class="desc"><p>docstring for SplittingStrategy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SplittingStrategy():
    &#34;&#34;&#34;docstring for SplittingStrategy&#34;&#34;&#34;
    def __init__(self, splitting_function):
        self.splitting_function = splitting_function

    def split(self, string):
        self.splitting_function(string)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.SplittingStrategy.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, string):
    self.splitting_function(string)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="look_and_say.SplittingStrategyBySplittablePairs"><code class="flex name class">
<span>class <span class="ident">SplittingStrategyBySplittablePairs</span></span>
</code></dt>
<dd>
<div class="desc"><p>docstring for SplittingStrategyBySplittablePairs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SplittingStrategyBySplittablePairs(SplittingStrategy):
    &#34;&#34;&#34;docstring for SplittingStrategyBySplittablePairs&#34;&#34;&#34;
    def __init__(self):
        super().__init__(None)
    
    def is_split(self, L, R):
        pass

    def split(self, string):
        chunks = []
        start = 0
        for i in range(1, len(string)):
            if self.is_split(string[start:i], string[i:]):
                chunks.append(string[start:i])
                start = i
        chunks.append(string[start:])
        return chunks</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="look_and_say.ConwaySplittingStrategy" href="#look_and_say.ConwaySplittingStrategy">ConwaySplittingStrategy</a></li>
<li><a title="look_and_say.Ending0SplittingStrategy" href="#look_and_say.Ending0SplittingStrategy">Ending0SplittingStrategy</a></li>
<li><a title="look_and_say.EndingWithCharsSplittingStrategy" href="#look_and_say.EndingWithCharsSplittingStrategy">EndingWithCharsSplittingStrategy</a></li>
<li><a title="look_and_say.LeadingCharSplittingStrategy" href="#look_and_say.LeadingCharSplittingStrategy">LeadingCharSplittingStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="look_and_say.SplittingStrategyBySplittablePairs.is_split"><code class="name flex">
<span>def <span class="ident">is_split</span></span>(<span>self, L, R)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_split(self, L, R):
    pass</code></pre>
</details>
</dd>
<dt id="look_and_say.SplittingStrategyBySplittablePairs.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, string):
    chunks = []
    start = 0
    for i in range(1, len(string)):
        if self.is_split(string[start:i], string[i:]):
            chunks.append(string[start:i])
            start = i
    chunks.append(string[start:])
    return chunks</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="look_and_say.split_Conway" href="#look_and_say.split_Conway">split_Conway</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="look_and_say.BinaryChemistry" href="#look_and_say.BinaryChemistry">BinaryChemistry</a></code></h4>
</li>
<li>
<h4><code><a title="look_and_say.Chemistry" href="#look_and_say.Chemistry">Chemistry</a></code></h4>
<ul class="two-column">
<li><code><a title="look_and_say.Chemistry.clear_elements" href="#look_and_say.Chemistry.clear_elements">clear_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.generate_elements" href="#look_and_say.Chemistry.generate_elements">generate_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_abundances" href="#look_and_say.Chemistry.get_abundances">get_abundances</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_char_poly" href="#look_and_say.Chemistry.get_char_poly">get_char_poly</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_decay_matrix" href="#look_and_say.Chemistry.get_decay_matrix">get_decay_matrix</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_elements" href="#look_and_say.Chemistry.get_elements">get_elements</a></code></li>
<li><code><a title="look_and_say.Chemistry.get_max_eigenvalue" href="#look_and_say.Chemistry.get_max_eigenvalue">get_max_eigenvalue</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.ConwaySplittingStrategy" href="#look_and_say.ConwaySplittingStrategy">ConwaySplittingStrategy</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.ConwaySplittingStrategy.is_split" href="#look_and_say.ConwaySplittingStrategy.is_split">is_split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.Element" href="#look_and_say.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Element.get_decay" href="#look_and_say.Element.get_decay">get_decay</a></code></li>
<li><code><a title="look_and_say.Element.get_name" href="#look_and_say.Element.get_name">get_name</a></code></li>
<li><code><a title="look_and_say.Element.get_string" href="#look_and_say.Element.get_string">get_string</a></code></li>
<li><code><a title="look_and_say.Element.set_name" href="#look_and_say.Element.set_name">set_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.Ending0SplittingStrategy" href="#look_and_say.Ending0SplittingStrategy">Ending0SplittingStrategy</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.Ending0SplittingStrategy.is_split" href="#look_and_say.Ending0SplittingStrategy.is_split">is_split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.EndingWithCharsSplittingStrategy" href="#look_and_say.EndingWithCharsSplittingStrategy">EndingWithCharsSplittingStrategy</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.EndingWithCharsSplittingStrategy.is_split" href="#look_and_say.EndingWithCharsSplittingStrategy.is_split">is_split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.Leading0SplittingStrategy" href="#look_and_say.Leading0SplittingStrategy">Leading0SplittingStrategy</a></code></h4>
</li>
<li>
<h4><code><a title="look_and_say.Leading1SplittingStrategy" href="#look_and_say.Leading1SplittingStrategy">Leading1SplittingStrategy</a></code></h4>
</li>
<li>
<h4><code><a title="look_and_say.LeadingCharSplittingStrategy" href="#look_and_say.LeadingCharSplittingStrategy">LeadingCharSplittingStrategy</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.LeadingCharSplittingStrategy.is_split" href="#look_and_say.LeadingCharSplittingStrategy.is_split">is_split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.LookAndSay" href="#look_and_say.LookAndSay">LookAndSay</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.LookAndSay.generate_sequence" href="#look_and_say.LookAndSay.generate_sequence">generate_sequence</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_last_length_ratio" href="#look_and_say.LookAndSay.get_last_length_ratio">get_last_length_ratio</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_length_ratios" href="#look_and_say.LookAndSay.get_length_ratios">get_length_ratios</a></code></li>
<li><code><a title="look_and_say.LookAndSay.get_sequence" href="#look_and_say.LookAndSay.get_sequence">get_sequence</a></code></li>
<li><code><a title="look_and_say.LookAndSay.say_what_you_see" href="#look_and_say.LookAndSay.say_what_you_see">say_what_you_see</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.SplittingStrategy" href="#look_and_say.SplittingStrategy">SplittingStrategy</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.SplittingStrategy.split" href="#look_and_say.SplittingStrategy.split">split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="look_and_say.SplittingStrategyBySplittablePairs" href="#look_and_say.SplittingStrategyBySplittablePairs">SplittingStrategyBySplittablePairs</a></code></h4>
<ul class="">
<li><code><a title="look_and_say.SplittingStrategyBySplittablePairs.is_split" href="#look_and_say.SplittingStrategyBySplittablePairs.is_split">is_split</a></code></li>
<li><code><a title="look_and_say.SplittingStrategyBySplittablePairs.split" href="#look_and_say.SplittingStrategyBySplittablePairs.split">split</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>